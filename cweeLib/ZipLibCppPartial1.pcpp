

#ifndef NOUNCRYPT
#define NOUNCRYPT
#endif

//#include "zlib.h"
//#include "unzip.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
extern int errno;
#else
#   include <errno.h>
#endif


#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */


#ifndef CASESENSITIVITYDEFAULT_NO
#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)
#    define CASESENSITIVITYDEFAULT_NO
#  endif
#endif


#ifndef UNZ_BUFSIZE
#define UNZ_BUFSIZE (16384)
#endif

#ifndef UNZ_MAXFILENAMEINZIP
#define UNZ_MAXFILENAMEINZIP (256)
#endif

#ifndef ALLOC
# define ALLOC(size) (malloc(size))
#endif
#ifndef TRYFREE
# define TRYFREE(p) {if (p) free(p);}
#endif

#define SIZECENTRALDIRITEM (0x2e)
#define SIZEZIPLOCALHEADER (0x1e)


const char unz_copyright[] =
" unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";

/* unz_file_info_interntal contain internal info about a file in zipfile*/
typedef struct unz_file_info64_internal_s
{
	ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */
} unz_file_info64_internal;


/* file_in_zip_read_info_s contain internal information about a file in zipfile,
	when reading and decompress it */
typedef struct
{
	char* read_buffer;         /* internal buffer for compressed data */
	z_stream stream;            /* zLib stream structure for inflate */

#ifdef HAVE_BZIP2
	bz_stream bstream;          /* bzLib stream structure for bziped */
#endif

	ZPOS64_T pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
	uLong stream_initialised;   /* flag set if stream structure is initialised*/

	ZPOS64_T offset_local_extrafield;/* offset of the local extra field */
	uInt  size_local_extrafield;/* size of the local extra field */
	ZPOS64_T pos_local_extrafield;   /* position in the local extra field in read*/
	ZPOS64_T total_out_64;

	uLong crc32;                /* crc32 of all data uncompressed */
	uLong crc32_wait;           /* crc32 we must obtain after decompress all */
	ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */
	ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/
	zlib_filefunc64_32_def z_filefunc;
	voidpf filestream;        /* io structore of the zipfile */
	uLong compression_method;   /* compression method (0==store) */
	ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
	int   raw;
} file_in_zip64_read_info_s;


/* unz64_s contain internal information about the zipfile
*/
typedef struct
{
	zlib_filefunc64_32_def z_filefunc;
	int is64bitOpenFunction;
	voidpf filestream;        /* io structore of the zipfile */
	unz_global_info64 gi;       /* public global information */
	ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
	ZPOS64_T num_file;             /* number of the current file in the zipfile*/
	ZPOS64_T pos_in_central_dir;   /* pos of the current file in the central dir*/
	ZPOS64_T current_file_ok;      /* flag about the usability of the current file*/
	ZPOS64_T central_pos;          /* position of the beginning of the central dir*/

	ZPOS64_T size_central_dir;     /* size of the central directory  */
	ZPOS64_T offset_central_dir;   /* offset of start of central directory with
								   respect to the starting disk number */

	unz_file_info64 cur_file_info; /* public info about the current file in zip*/
	unz_file_info64_internal cur_file_info_internal; /* private info about it*/
	file_in_zip64_read_info_s* pfile_in_zip_read; /* structure about the current
										file if we are decompressing it */
	int encrypted;

	int isZip64;

#    ifndef NOUNCRYPT
	unsigned long keys[3];     /* keys defining the pseudo-random sequence */
	const z_crc_t* pcrc_32_tab;
#    endif
} unz64_s;


#ifndef NOUNCRYPT
#include "crypt.h"
#endif

/* ===========================================================================
	 Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been successfully opened for reading.
*/


local int unz64local_getByte OF((
	const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream,
	int* pi));

local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int* pi)
{
	unsigned char c;
	int err = (int)ZREAD64(*pzlib_filefunc_def, filestream, &c, 1);
	if (err == 1)
	{
		*pi = (int)c;
		return UNZ_OK;
	}
	else
	{
		if (ZERROR64(*pzlib_filefunc_def, filestream))
			return UNZ_ERRNO;
		else
			return UNZ_EOF;
	}
}


/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets
*/
local int unz64local_getShort OF((
	const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream,
	uLong* pX));

local int unz64local_getShort(const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream,
	uLong* pX)
{
	uLong x;
	int i = 0;
	int err;

	err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x = (uLong)i;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((uLong)i) << 8;

	if (err == UNZ_OK)
		*pX = x;
	else
		*pX = 0;
	return err;
}

local int unz64local_getLong OF((
	const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream,
	uLong* pX));

local int unz64local_getLong(const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream,
	uLong* pX)
{
	uLong x;
	int i = 0;
	int err;

	err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x = (uLong)i;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((uLong)i) << 8;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((uLong)i) << 16;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((uLong)i) << 24;

	if (err == UNZ_OK)
		*pX = x;
	else
		*pX = 0;
	return err;
}

local int unz64local_getLong64 OF((
	const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream,
	ZPOS64_T* pX));


local int unz64local_getLong64(const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream,
	ZPOS64_T* pX)
{
	ZPOS64_T x;
	int i = 0;
	int err;

	err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x = (ZPOS64_T)i;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((ZPOS64_T)i) << 8;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((ZPOS64_T)i) << 16;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((ZPOS64_T)i) << 24;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((ZPOS64_T)i) << 32;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((ZPOS64_T)i) << 40;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((ZPOS64_T)i) << 48;

	if (err == UNZ_OK)
		err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
	x |= ((ZPOS64_T)i) << 56;

	if (err == UNZ_OK)
		*pX = x;
	else
		*pX = 0;
	return err;
}

/* My own strcmpi / strcasecmp */
local int strcmpcasenosensitive_internal(const char* fileName1, const char* fileName2)
{
	for (;;)
	{
		char c1 = *(fileName1++);
		char c2 = *(fileName2++);
		if ((c1 >= 'a') && (c1 <= 'z'))
			c1 -= 0x20;
		if ((c2 >= 'a') && (c2 <= 'z'))
			c2 -= 0x20;
		if (c1 == '\0')
			return ((c2 == '\0') ? 0 : -1);
		if (c2 == '\0')
			return 1;
		if (c1 < c2)
			return -1;
		if (c1 > c2)
			return 1;
	}
}


#ifdef  CASESENSITIVITYDEFAULT_NO
#define CASESENSITIVITYDEFAULTVALUE 2
#else
#define CASESENSITIVITYDEFAULTVALUE 1
#endif

#ifndef STRCMPCASENOSENTIVEFUNCTION
#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
#endif

/*
   Compare two filename (fileName1,fileName2).
   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
																or strcasecmp)
   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
		(like 1 on Unix, 2 on Windows)

*/
extern int ZEXPORT unzStringFileNameCompare(const char* fileName1,
	const char* fileName2,
	int iCaseSensitivity)

{
	if (iCaseSensitivity == 0)
		iCaseSensitivity = CASESENSITIVITYDEFAULTVALUE;

	if (iCaseSensitivity == 1)
		return strcmp(fileName1, fileName2);

	return STRCMPCASENOSENTIVEFUNCTION(fileName1, fileName2);
}

#ifndef BUFREADCOMMENT
#define BUFREADCOMMENT (0x400)
#endif

/*
  Locate the Central directory of a zipfile (at the end, just before
	the global comment)
*/
local ZPOS64_T unz64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
{
	unsigned char* buf;
	ZPOS64_T uSizeFile;
	ZPOS64_T uBackRead;
	ZPOS64_T uMaxBack = 0xffff; /* maximum size of global comment */
	ZPOS64_T uPosFound = 0;

	if (ZSEEK64(*pzlib_filefunc_def, filestream, 0, ZLIB_FILEFUNC_SEEK_END) != 0)
		return 0;


	uSizeFile = ZTELL64(*pzlib_filefunc_def, filestream);

	if (uMaxBack > uSizeFile)
		uMaxBack = uSizeFile;

	buf = (unsigned char*)ALLOC(BUFREADCOMMENT + 4);
	if (buf == NULL)
		return 0;

	uBackRead = 4;
	while (uBackRead < uMaxBack)
	{
		uLong uReadSize;
		ZPOS64_T uReadPos;
		int i;
		if (uBackRead + BUFREADCOMMENT > uMaxBack)
			uBackRead = uMaxBack;
		else
			uBackRead += BUFREADCOMMENT;
		uReadPos = uSizeFile - uBackRead;

		uReadSize = ((BUFREADCOMMENT + 4) < (uSizeFile - uReadPos)) ?
			(BUFREADCOMMENT + 4) : (uLong)(uSizeFile - uReadPos);
		if (ZSEEK64(*pzlib_filefunc_def, filestream, uReadPos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			break;

		if (ZREAD64(*pzlib_filefunc_def, filestream, buf, uReadSize) != uReadSize)
			break;

		for (i = (int)uReadSize - 3; (i--) > 0;)
			if (((*(buf + i)) == 0x50) && ((*(buf + i + 1)) == 0x4b) &&
				((*(buf + i + 2)) == 0x05) && ((*(buf + i + 3)) == 0x06))
			{
				uPosFound = uReadPos + i;
				break;
			}

		if (uPosFound != 0)
			break;
	}
	TRYFREE(buf);
	return uPosFound;
}


/*
  Locate the Central directory 64 of a zipfile (at the end, just before
	the global comment)
*/
local ZPOS64_T unz64local_SearchCentralDir64 OF((
	const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream));

local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,
	voidpf filestream)
{
	unsigned char* buf;
	ZPOS64_T uSizeFile;
	ZPOS64_T uBackRead;
	ZPOS64_T uMaxBack = 0xffff; /* maximum size of global comment */
	ZPOS64_T uPosFound = 0;
	uLong uL;
	ZPOS64_T relativeOffset;

	if (ZSEEK64(*pzlib_filefunc_def, filestream, 0, ZLIB_FILEFUNC_SEEK_END) != 0)
		return 0;


	uSizeFile = ZTELL64(*pzlib_filefunc_def, filestream);

	if (uMaxBack > uSizeFile)
		uMaxBack = uSizeFile;

	buf = (unsigned char*)ALLOC(BUFREADCOMMENT + 4);
	if (buf == NULL)
		return 0;

	uBackRead = 4;
	while (uBackRead < uMaxBack)
	{
		uLong uReadSize;
		ZPOS64_T uReadPos;
		int i;
		if (uBackRead + BUFREADCOMMENT > uMaxBack)
			uBackRead = uMaxBack;
		else
			uBackRead += BUFREADCOMMENT;
		uReadPos = uSizeFile - uBackRead;

		uReadSize = ((BUFREADCOMMENT + 4) < (uSizeFile - uReadPos)) ?
			(BUFREADCOMMENT + 4) : (uLong)(uSizeFile - uReadPos);
		if (ZSEEK64(*pzlib_filefunc_def, filestream, uReadPos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			break;

		if (ZREAD64(*pzlib_filefunc_def, filestream, buf, uReadSize) != uReadSize)
			break;

		for (i = (int)uReadSize - 3; (i--) > 0;)
			if (((*(buf + i)) == 0x50) && ((*(buf + i + 1)) == 0x4b) &&
				((*(buf + i + 2)) == 0x06) && ((*(buf + i + 3)) == 0x07))
			{
				uPosFound = uReadPos + i;
				break;
			}

		if (uPosFound != 0)
			break;
	}
	TRYFREE(buf);
	if (uPosFound == 0)
		return 0;

	/* Zip64 end of central directory locator */
	if (ZSEEK64(*pzlib_filefunc_def, filestream, uPosFound, ZLIB_FILEFUNC_SEEK_SET) != 0)
		return 0;

	/* the signature, already checked */
	if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
		return 0;

	/* number of the disk with the start of the zip64 end of  central directory */
	if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
		return 0;
	if (uL != 0)
		return 0;

	/* relative offset of the zip64 end of central directory record */
	if (unz64local_getLong64(pzlib_filefunc_def, filestream, &relativeOffset) != UNZ_OK)
		return 0;

	/* total number of disks */
	if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
		return 0;
	if (uL != 1)
		return 0;

	/* Goto end of central directory record */
	if (ZSEEK64(*pzlib_filefunc_def, filestream, relativeOffset, ZLIB_FILEFUNC_SEEK_SET) != 0)
		return 0;

	/* the signature */
	if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
		return 0;

	if (uL != 0x06064b50)
		return 0;

	return relativeOffset;
}

/*
  Open a Zip file. path contain the full pathname (by example,
	 on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
	 "zlib/zlib114.zip".
	 If the zipfile cannot be opened (file doesn't exist or in not valid), the
	   return value is NULL.
	 Else, the return value is a unzFile Handle, usable with other function
	   of this unzip package.
*/
local unzFile unzOpenInternal(const void* path,
	zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
	int is64bitOpenFunction)
{
	unz64_s us;
	unz64_s* s;
	ZPOS64_T central_pos;
	uLong   uL;

	uLong number_disk;          /* number of the current dist, used for
								   spaning ZIP, unsupported, always 0*/
	uLong number_disk_with_CD;  /* number the the disk with central dir, used
								   for spaning ZIP, unsupported, always 0*/
	ZPOS64_T number_entry_CD;      /* total number of entries in
								   the central dir
								   (same than number_entry on nospan) */

	int err = UNZ_OK;

	if (unz_copyright[0] != ' ')
		return NULL;

	us.z_filefunc.zseek32_file = NULL;
	us.z_filefunc.ztell32_file = NULL;
	if (pzlib_filefunc64_32_def == NULL)
		fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);
	else
		us.z_filefunc = *pzlib_filefunc64_32_def;
	us.is64bitOpenFunction = is64bitOpenFunction;



	us.filestream = ZOPEN64(us.z_filefunc,
		path,
		ZLIB_FILEFUNC_MODE_READ |
		ZLIB_FILEFUNC_MODE_EXISTING);
	if (us.filestream == NULL)
		return NULL;

	central_pos = unz64local_SearchCentralDir64(&us.z_filefunc, us.filestream);
	if (central_pos)
	{
		uLong uS;
		ZPOS64_T uL64;

		us.isZip64 = 1;

		if (ZSEEK64(us.z_filefunc, us.filestream,
			central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			err = UNZ_ERRNO;

		/* the signature, already checked */
		if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
			err = UNZ_ERRNO;

		/* size of zip64 end of central directory record */
		if (unz64local_getLong64(&us.z_filefunc, us.filestream, &uL64) != UNZ_OK)
			err = UNZ_ERRNO;

		/* version made by */
		if (unz64local_getShort(&us.z_filefunc, us.filestream, &uS) != UNZ_OK)
			err = UNZ_ERRNO;

		/* version needed to extract */
		if (unz64local_getShort(&us.z_filefunc, us.filestream, &uS) != UNZ_OK)
			err = UNZ_ERRNO;

		/* number of this disk */
		if (unz64local_getLong(&us.z_filefunc, us.filestream, &number_disk) != UNZ_OK)
			err = UNZ_ERRNO;

		/* number of the disk with the start of the central directory */
		if (unz64local_getLong(&us.z_filefunc, us.filestream, &number_disk_with_CD) != UNZ_OK)
			err = UNZ_ERRNO;

		/* total number of entries in the central directory on this disk */
		if (unz64local_getLong64(&us.z_filefunc, us.filestream, &us.gi.number_entry) != UNZ_OK)
			err = UNZ_ERRNO;

		/* total number of entries in the central directory */
		if (unz64local_getLong64(&us.z_filefunc, us.filestream, &number_entry_CD) != UNZ_OK)
			err = UNZ_ERRNO;

		if ((number_entry_CD != us.gi.number_entry) ||
			(number_disk_with_CD != 0) ||
			(number_disk != 0))
			err = UNZ_BADZIPFILE;

		/* size of the central directory */
		if (unz64local_getLong64(&us.z_filefunc, us.filestream, &us.size_central_dir) != UNZ_OK)
			err = UNZ_ERRNO;

		/* offset of start of central directory with respect to the
		  starting disk number */
		if (unz64local_getLong64(&us.z_filefunc, us.filestream, &us.offset_central_dir) != UNZ_OK)
			err = UNZ_ERRNO;

		us.gi.size_comment = 0;
	}
	else
	{
		central_pos = unz64local_SearchCentralDir(&us.z_filefunc, us.filestream);
		if (central_pos == 0)
			err = UNZ_ERRNO;

		us.isZip64 = 0;

		if (ZSEEK64(us.z_filefunc, us.filestream,
			central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			err = UNZ_ERRNO;

		/* the signature, already checked */
		if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
			err = UNZ_ERRNO;

		/* number of this disk */
		if (unz64local_getShort(&us.z_filefunc, us.filestream, &number_disk) != UNZ_OK)
			err = UNZ_ERRNO;

		/* number of the disk with the start of the central directory */
		if (unz64local_getShort(&us.z_filefunc, us.filestream, &number_disk_with_CD) != UNZ_OK)
			err = UNZ_ERRNO;

		/* total number of entries in the central dir on this disk */
		if (unz64local_getShort(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
			err = UNZ_ERRNO;
		us.gi.number_entry = uL;

		/* total number of entries in the central dir */
		if (unz64local_getShort(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
			err = UNZ_ERRNO;
		number_entry_CD = uL;

		if ((number_entry_CD != us.gi.number_entry) ||
			(number_disk_with_CD != 0) ||
			(number_disk != 0))
			err = UNZ_BADZIPFILE;

		/* size of the central directory */
		if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
			err = UNZ_ERRNO;
		us.size_central_dir = uL;

		/* offset of start of central directory with respect to the
			starting disk number */
		if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
			err = UNZ_ERRNO;
		us.offset_central_dir = uL;

		/* zipfile comment length */
		if (unz64local_getShort(&us.z_filefunc, us.filestream, &us.gi.size_comment) != UNZ_OK)
			err = UNZ_ERRNO;
	}

	if ((central_pos < us.offset_central_dir + us.size_central_dir) &&
		(err == UNZ_OK))
		err = UNZ_BADZIPFILE;

	if (err != UNZ_OK)
	{
		ZCLOSE64(us.z_filefunc, us.filestream);
		return NULL;
	}

	us.byte_before_the_zipfile = central_pos -
		(us.offset_central_dir + us.size_central_dir);
	us.central_pos = central_pos;
	us.pfile_in_zip_read = NULL;
	us.encrypted = 0;


	s = (unz64_s*)ALLOC(sizeof(unz64_s));
	if (s != NULL)
	{
		*s = us;
		unzGoToFirstFile((unzFile)s);
	}
	return (unzFile)s;
}


extern unzFile ZEXPORT unzOpen2(const char* path,
	zlib_filefunc_def* pzlib_filefunc32_def)
{
	if (pzlib_filefunc32_def != NULL)
	{
		zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
		fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill, pzlib_filefunc32_def);
		return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 0);
	}
	else
		return unzOpenInternal(path, NULL, 0);
}

extern unzFile ZEXPORT unzOpen2_64(const void* path,
	zlib_filefunc64_def* pzlib_filefunc_def)
{
	if (pzlib_filefunc_def != NULL)
	{
		zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
		zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
		zlib_filefunc64_32_def_fill.ztell32_file = NULL;
		zlib_filefunc64_32_def_fill.zseek32_file = NULL;
		return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 1);
	}
	else
		return unzOpenInternal(path, NULL, 1);
}

extern unzFile ZEXPORT unzOpen(const char* path)
{
	return unzOpenInternal(path, NULL, 0);
}

extern unzFile ZEXPORT unzOpen64(const void* path)
{
	return unzOpenInternal(path, NULL, 1);
}

/*
  Close a ZipFile opened with unzOpen.
  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
	these files MUST be closed with unzCloseCurrentFile before call unzClose.
  return UNZ_OK if there is no problem. */
extern int ZEXPORT unzClose(unzFile file)
{
	unz64_s* s;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;

	if (s->pfile_in_zip_read != NULL)
		unzCloseCurrentFile(file);

	ZCLOSE64(s->z_filefunc, s->filestream);
	TRYFREE(s);
	return UNZ_OK;
}


/*
  Write info about the ZipFile in the *pglobal_info structure.
  No preparation of the structure is needed
  return UNZ_OK if there is no problem. */
extern int ZEXPORT unzGetGlobalInfo64(unzFile file, unz_global_info64* pglobal_info)
{
	unz64_s* s;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	*pglobal_info = s->gi;
	return UNZ_OK;
}

extern int ZEXPORT unzGetGlobalInfo(unzFile file, unz_global_info* pglobal_info32)
{
	unz64_s* s;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	/* to do : check if number_entry is not truncated */
	pglobal_info32->number_entry = (uLong)s->gi.number_entry;
	pglobal_info32->size_comment = s->gi.size_comment;
	return UNZ_OK;
}
/*
   Translate date/zl_TIME from Dos format to tm_unz (readable more easilty)
*/
local void unz64local_DosDateToTmuDate(ZPOS64_T ulDosDate, tm_unz* ptm)
{
	ZPOS64_T uDate;
	uDate = (ZPOS64_T)(ulDosDate >> 16);
	ptm->tm_mday = (uInt)(uDate & 0x1f);
	ptm->tm_mon = (uInt)((((uDate) & 0x1E0) / 0x20) - 1);
	ptm->tm_year = (uInt)(((uDate & 0x0FE00) / 0x0200) + 1980);

	ptm->tm_hour = (uInt)((ulDosDate & 0xF800) / 0x800);
	ptm->tm_min = (uInt)((ulDosDate & 0x7E0) / 0x20);
	ptm->tm_sec = (uInt)(2 * (ulDosDate & 0x1f));
}

/*
  Get Info about the current file in the zipfile, with internal only info
*/
local int unz64local_GetCurrentFileInfoInternal OF((unzFile file,
	unz_file_info64* pfile_info,
	unz_file_info64_internal
	* pfile_info_internal,
	char* szFileName,
	uLong fileNameBufferSize,
	void* extraField,
	uLong extraFieldBufferSize,
	char* szComment,
	uLong commentBufferSize));

local int unz64local_GetCurrentFileInfoInternal(unzFile file,
	unz_file_info64* pfile_info,
	unz_file_info64_internal
	* pfile_info_internal,
	char* szFileName,
	uLong fileNameBufferSize,
	void* extraField,
	uLong extraFieldBufferSize,
	char* szComment,
	uLong commentBufferSize)
{
	unz64_s* s;
	unz_file_info64 file_info;
	unz_file_info64_internal file_info_internal;
	int err = UNZ_OK;
	uLong uMagic;
	long lSeek = 0;
	uLong uL;

	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	if (ZSEEK64(s->z_filefunc, s->filestream,
		s->pos_in_central_dir + s->byte_before_the_zipfile,
		ZLIB_FILEFUNC_SEEK_SET) != 0)
		err = UNZ_ERRNO;


	/* we check the magic */
	if (err == UNZ_OK)
	{
		if (unz64local_getLong(&s->z_filefunc, s->filestream, &uMagic) != UNZ_OK)
			err = UNZ_ERRNO;
		else if (uMagic != 0x02014b50)
			err = UNZ_BADZIPFILE;
	}

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.version) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.version_needed) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.flag) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.compression_method) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &file_info.dosDate) != UNZ_OK)
		err = UNZ_ERRNO;

	unz64local_DosDateToTmuDate(file_info.dosDate, &file_info.tmu_date);

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &file_info.crc) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK)
		err = UNZ_ERRNO;
	file_info.compressed_size = uL;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK)
		err = UNZ_ERRNO;
	file_info.uncompressed_size = uL;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.size_filename) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.size_file_extra) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.size_file_comment) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.disk_num_start) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.internal_fa) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &file_info.external_fa) != UNZ_OK)
		err = UNZ_ERRNO;

	// relative offset of local header
	if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK)
		err = UNZ_ERRNO;
	file_info_internal.offset_curfile = uL;

	lSeek += file_info.size_filename;
	if ((err == UNZ_OK) && (szFileName != NULL))
	{
		uLong uSizeRead;
		if (file_info.size_filename < fileNameBufferSize)
		{
			*(szFileName + file_info.size_filename) = '\0';
			uSizeRead = file_info.size_filename;
		}
		else
			uSizeRead = fileNameBufferSize;

		if ((file_info.size_filename > 0) && (fileNameBufferSize > 0))
			if (ZREAD64(s->z_filefunc, s->filestream, szFileName, uSizeRead) != uSizeRead)
				err = UNZ_ERRNO;
		lSeek -= uSizeRead;
	}

	// Read extrafield
	if ((err == UNZ_OK) && (extraField != NULL))
	{
		ZPOS64_T uSizeRead;
		if (file_info.size_file_extra < extraFieldBufferSize)
			uSizeRead = file_info.size_file_extra;
		else
			uSizeRead = extraFieldBufferSize;

		if (lSeek != 0)
		{
			if (ZSEEK64(s->z_filefunc, s->filestream, lSeek, ZLIB_FILEFUNC_SEEK_CUR) == 0)
				lSeek = 0;
			else
				err = UNZ_ERRNO;
		}

		if ((file_info.size_file_extra > 0) && (extraFieldBufferSize > 0))
			if (ZREAD64(s->z_filefunc, s->filestream, extraField, (uLong)uSizeRead) != uSizeRead)
				err = UNZ_ERRNO;

		lSeek += file_info.size_file_extra - (uLong)uSizeRead;
	}
	else
		lSeek += file_info.size_file_extra;


	if ((err == UNZ_OK) && (file_info.size_file_extra != 0))
	{
		uLong acc = 0;

		// since lSeek now points to after the extra field we need to move back
		lSeek -= file_info.size_file_extra;

		if (lSeek != 0)
		{
			if (ZSEEK64(s->z_filefunc, s->filestream, lSeek, ZLIB_FILEFUNC_SEEK_CUR) == 0)
				lSeek = 0;
			else
				err = UNZ_ERRNO;
		}

		while (acc < file_info.size_file_extra)
		{
			uLong headerId;
			uLong dataSize;

			if (unz64local_getShort(&s->z_filefunc, s->filestream, &headerId) != UNZ_OK)
				err = UNZ_ERRNO;

			if (unz64local_getShort(&s->z_filefunc, s->filestream, &dataSize) != UNZ_OK)
				err = UNZ_ERRNO;

			/* ZIP64 extra fields */
			if (headerId == 0x0001)
			{
				uLong uL;

				if (file_info.uncompressed_size == MAXU32)
				{
					if (unz64local_getLong64(&s->z_filefunc, s->filestream, &file_info.uncompressed_size) != UNZ_OK)
						err = UNZ_ERRNO;
				}

				if (file_info.compressed_size == MAXU32)
				{
					if (unz64local_getLong64(&s->z_filefunc, s->filestream, &file_info.compressed_size) != UNZ_OK)
						err = UNZ_ERRNO;
				}

				if (file_info_internal.offset_curfile == MAXU32)
				{
					/* Relative Header offset */
					if (unz64local_getLong64(&s->z_filefunc, s->filestream, &file_info_internal.offset_curfile) != UNZ_OK)
						err = UNZ_ERRNO;
				}

				if (file_info.disk_num_start == MAXU32)
				{
					/* Disk Start Number */
					if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK)
						err = UNZ_ERRNO;
				}

			}
			else
			{
				if (ZSEEK64(s->z_filefunc, s->filestream, dataSize, ZLIB_FILEFUNC_SEEK_CUR) != 0)
					err = UNZ_ERRNO;
			}

			acc += 2 + 2 + dataSize;
		}
	}

	if ((err == UNZ_OK) && (szComment != NULL))
	{
		uLong uSizeRead;
		if (file_info.size_file_comment < commentBufferSize)
		{
			*(szComment + file_info.size_file_comment) = '\0';
			uSizeRead = file_info.size_file_comment;
		}
		else
			uSizeRead = commentBufferSize;

		if (lSeek != 0)
		{
			if (ZSEEK64(s->z_filefunc, s->filestream, lSeek, ZLIB_FILEFUNC_SEEK_CUR) == 0)
				lSeek = 0;
			else
				err = UNZ_ERRNO;
		}

		if ((file_info.size_file_comment > 0) && (commentBufferSize > 0))
			if (ZREAD64(s->z_filefunc, s->filestream, szComment, uSizeRead) != uSizeRead)
				err = UNZ_ERRNO;
		lSeek += file_info.size_file_comment - uSizeRead;
	}
	else
		lSeek += file_info.size_file_comment;


	if ((err == UNZ_OK) && (pfile_info != NULL))
		*pfile_info = file_info;

	if ((err == UNZ_OK) && (pfile_info_internal != NULL))
		*pfile_info_internal = file_info_internal;

	return err;
}



/*
  Write info about the ZipFile in the *pglobal_info structure.
  No preparation of the structure is needed
  return UNZ_OK if there is no problem.
*/
extern int ZEXPORT unzGetCurrentFileInfo64(unzFile file,
	unz_file_info64* pfile_info,
	char* szFileName, uLong fileNameBufferSize,
	void* extraField, uLong extraFieldBufferSize,
	char* szComment, uLong commentBufferSize)
{
	return unz64local_GetCurrentFileInfoInternal(file, pfile_info, NULL,
		szFileName, fileNameBufferSize,
		extraField, extraFieldBufferSize,
		szComment, commentBufferSize);
}

extern int ZEXPORT unzGetCurrentFileInfo(unzFile file,
	unz_file_info* pfile_info,
	char* szFileName, uLong fileNameBufferSize,
	void* extraField, uLong extraFieldBufferSize,
	char* szComment, uLong commentBufferSize)
{
	int err;
	unz_file_info64 file_info64;
	err = unz64local_GetCurrentFileInfoInternal(file, &file_info64, NULL,
		szFileName, fileNameBufferSize,
		extraField, extraFieldBufferSize,
		szComment, commentBufferSize);
	if ((err == UNZ_OK) && (pfile_info != NULL))
	{
		pfile_info->version = file_info64.version;
		pfile_info->version_needed = file_info64.version_needed;
		pfile_info->flag = file_info64.flag;
		pfile_info->compression_method = file_info64.compression_method;
		pfile_info->dosDate = file_info64.dosDate;
		pfile_info->crc = file_info64.crc;

		pfile_info->size_filename = file_info64.size_filename;
		pfile_info->size_file_extra = file_info64.size_file_extra;
		pfile_info->size_file_comment = file_info64.size_file_comment;

		pfile_info->disk_num_start = file_info64.disk_num_start;
		pfile_info->internal_fa = file_info64.internal_fa;
		pfile_info->external_fa = file_info64.external_fa;

		pfile_info->tmu_date = file_info64.tmu_date,


			pfile_info->compressed_size = (uLong)file_info64.compressed_size;
		pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;

	}
	return err;
}
/*
  Set the current file of the zipfile to the first file.
  return UNZ_OK if there is no problem
*/
extern int ZEXPORT unzGoToFirstFile(unzFile file)
{
	int err = UNZ_OK;
	unz64_s* s;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	s->pos_in_central_dir = s->offset_central_dir;
	s->num_file = 0;
	err = unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info,
		&s->cur_file_info_internal,
		NULL, 0, NULL, 0, NULL, 0);
	s->current_file_ok = (err == UNZ_OK);
	return err;
}

/*
  Set the current file of the zipfile to the next file.
  return UNZ_OK if there is no problem
  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
*/
extern int ZEXPORT unzGoToNextFile(unzFile  file)
{
	unz64_s* s;
	int err;

	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	if (!s->current_file_ok)
		return UNZ_END_OF_LIST_OF_FILE;
	if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
		if (s->num_file + 1 == s->gi.number_entry)
			return UNZ_END_OF_LIST_OF_FILE;

	s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
		s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment;
	s->num_file++;
	err = unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info,
		&s->cur_file_info_internal,
		NULL, 0, NULL, 0, NULL, 0);
	s->current_file_ok = (err == UNZ_OK);
	return err;
}


/*
  Try locate the file szFileName in the zipfile.
  For the iCaseSensitivity signification, see unzStringFileNameCompare

  return value :
  UNZ_OK if the file is found. It becomes the current file.
  UNZ_END_OF_LIST_OF_FILE if the file is not found
*/
extern int ZEXPORT unzLocateFile(unzFile file, const char* szFileName, int iCaseSensitivity)
{
	unz64_s* s;
	int err;

	/* We remember the 'current' position in the file so that we can jump
	 * back there if we fail.
	 */
	unz_file_info64 cur_file_infoSaved;
	unz_file_info64_internal cur_file_info_internalSaved;
	ZPOS64_T num_fileSaved;
	ZPOS64_T pos_in_central_dirSaved;


	if (file == NULL)
		return UNZ_PARAMERROR;

	if (strlen(szFileName) >= UNZ_MAXFILENAMEINZIP)
		return UNZ_PARAMERROR;

	s = (unz64_s*)file;
	if (!s->current_file_ok)
		return UNZ_END_OF_LIST_OF_FILE;

	/* Save the current state */
	num_fileSaved = s->num_file;
	pos_in_central_dirSaved = s->pos_in_central_dir;
	cur_file_infoSaved = s->cur_file_info;
	cur_file_info_internalSaved = s->cur_file_info_internal;

	err = unzGoToFirstFile(file);

	while (err == UNZ_OK)
	{
		char szCurrentFileName[UNZ_MAXFILENAMEINZIP + 1];
		err = unzGetCurrentFileInfo64(file, NULL,
			szCurrentFileName, sizeof(szCurrentFileName) - 1,
			NULL, 0, NULL, 0);
		if (err == UNZ_OK)
		{
			if (unzStringFileNameCompare(szCurrentFileName,
				szFileName, iCaseSensitivity) == 0)
				return UNZ_OK;
			err = unzGoToNextFile(file);
		}
	}

	/* We failed, so restore the state of the 'current file' to where we
	 * were.
	 */
	s->num_file = num_fileSaved;
	s->pos_in_central_dir = pos_in_central_dirSaved;
	s->cur_file_info = cur_file_infoSaved;
	s->cur_file_info_internal = cur_file_info_internalSaved;
	return err;
}


/*
///////////////////////////////////////////
// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
// I need random access
//
// Further optimization could be realized by adding an ability
// to cache the directory in memory. The goal being a single
// comprehensive file read to put the file I need in a memory.
*/

/*
typedef struct unz_file_pos_s
{
	ZPOS64_T pos_in_zip_directory;   // offset in file
	ZPOS64_T num_of_file;            // # of file
} unz_file_pos;
*/

extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos* file_pos)
{
	unz64_s* s;

	if (file == NULL || file_pos == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	if (!s->current_file_ok)
		return UNZ_END_OF_LIST_OF_FILE;

	file_pos->pos_in_zip_directory = s->pos_in_central_dir;
	file_pos->num_of_file = s->num_file;

	return UNZ_OK;
}

extern int ZEXPORT unzGetFilePos(
	unzFile file,
	unz_file_pos* file_pos)
{
	unz64_file_pos file_pos64;
	int err = unzGetFilePos64(file, &file_pos64);
	if (err == UNZ_OK)
	{
		file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;
		file_pos->num_of_file = (uLong)file_pos64.num_of_file;
	}
	return err;
}

extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos)
{
	unz64_s* s;
	int err;

	if (file == NULL || file_pos == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;

	/* jump to the right spot */
	s->pos_in_central_dir = file_pos->pos_in_zip_directory;
	s->num_file = file_pos->num_of_file;

	/* set the current file */
	err = unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info,
		&s->cur_file_info_internal,
		NULL, 0, NULL, 0, NULL, 0);
	/* return results */
	s->current_file_ok = (err == UNZ_OK);
	return err;
}

extern int ZEXPORT unzGoToFilePos(
	unzFile file,
	unz_file_pos* file_pos)
{
	unz64_file_pos file_pos64;
	if (file_pos == NULL)
		return UNZ_PARAMERROR;

	file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
	file_pos64.num_of_file = file_pos->num_of_file;
	return unzGoToFilePos64(file, &file_pos64);
}

/*
// Unzip Helper Functions - should be here?
///////////////////////////////////////////
*/

/*
  Read the local header of the current zipfile
  Check the coherency of the local header and info in the end of central
		directory about this file
  store in *piSizeVar the size of extra info in local header
		(filename and size of extra field data)
*/
local int unz64local_CheckCurrentFileCoherencyHeader(unz64_s* s, uInt* piSizeVar,
	ZPOS64_T* poffset_local_extrafield,
	uInt* psize_local_extrafield)
{
	uLong uMagic, uData, uzl_FLAGS;
	uLong size_filename;
	uLong size_extra_field;
	int err = UNZ_OK;

	*piSizeVar = 0;
	*poffset_local_extrafield = 0;
	*psize_local_extrafield = 0;

	if (ZSEEK64(s->z_filefunc, s->filestream, s->cur_file_info_internal.offset_curfile +
		s->byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
		return UNZ_ERRNO;


	if (err == UNZ_OK)
	{
		if (unz64local_getLong(&s->z_filefunc, s->filestream, &uMagic) != UNZ_OK)
			err = UNZ_ERRNO;
		else if (uMagic != 0x04034b50)
			err = UNZ_BADZIPFILE;
	}

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &uData) != UNZ_OK)
		err = UNZ_ERRNO;
	/*
		else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
			err=UNZ_BADZIPFILE;
	*/
	if (unz64local_getShort(&s->z_filefunc, s->filestream, &uzl_FLAGS) != UNZ_OK)
		err = UNZ_ERRNO;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &uData) != UNZ_OK)
		err = UNZ_ERRNO;
	else if ((err == UNZ_OK) && (uData != s->cur_file_info.compression_method))
		err = UNZ_BADZIPFILE;

	if ((err == UNZ_OK) && (s->cur_file_info.compression_method != 0) &&
		/* #ifdef HAVE_BZIP2 */
		(s->cur_file_info.compression_method != Z_BZIP2ED) &&
		/* #endif */
		(s->cur_file_info.compression_method != Z_DEFLATED))
		err = UNZ_BADZIPFILE;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &uData) != UNZ_OK) /* date/zl_TIME */
		err = UNZ_ERRNO;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &uData) != UNZ_OK) /* crc */
		err = UNZ_ERRNO;
	else if ((err == UNZ_OK) && (uData != s->cur_file_info.crc) && ((uzl_FLAGS & 8) == 0))
		err = UNZ_BADZIPFILE;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &uData) != UNZ_OK) /* size compr */
		err = UNZ_ERRNO;
	else if (uData != 0xFFFFFFFF && (err == UNZ_OK) && (uData != s->cur_file_info.compressed_size) && ((uzl_FLAGS & 8) == 0))
		err = UNZ_BADZIPFILE;

	if (unz64local_getLong(&s->z_filefunc, s->filestream, &uData) != UNZ_OK) /* size uncompr */
		err = UNZ_ERRNO;
	else if (uData != 0xFFFFFFFF && (err == UNZ_OK) && (uData != s->cur_file_info.uncompressed_size) && ((uzl_FLAGS & 8) == 0))
		err = UNZ_BADZIPFILE;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &size_filename) != UNZ_OK)
		err = UNZ_ERRNO;
	else if ((err == UNZ_OK) && (size_filename != s->cur_file_info.size_filename))
		err = UNZ_BADZIPFILE;

	*piSizeVar += (uInt)size_filename;

	if (unz64local_getShort(&s->z_filefunc, s->filestream, &size_extra_field) != UNZ_OK)
		err = UNZ_ERRNO;
	*poffset_local_extrafield = s->cur_file_info_internal.offset_curfile +
		SIZEZIPLOCALHEADER + size_filename;
	*psize_local_extrafield = (uInt)size_extra_field;

	*piSizeVar += (uInt)size_extra_field;

	return err;
}

/*
  Open for reading data the current file in the zipfile.
  If there is no error and the file is opened, the return value is UNZ_OK.
*/
extern int ZEXPORT unzOpenCurrentFile3(unzFile file, int* method,
	int* level, int raw, const char* password)
{
	int err = UNZ_OK;
	uInt iSizeVar;
	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */
	uInt  size_local_extrafield;    /* size of the local extra field */
#    ifndef NOUNCRYPT
	char source[12];
#    else
	if (password != NULL)
		return UNZ_PARAMERROR;
#    endif

	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	if (!s->current_file_ok)
		return UNZ_PARAMERROR;

	if (s->pfile_in_zip_read != NULL)
		unzCloseCurrentFile(file);

	if (unz64local_CheckCurrentFileCoherencyHeader(s, &iSizeVar, &offset_local_extrafield, &size_local_extrafield) != UNZ_OK)
		return UNZ_BADZIPFILE;

	pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));
	if (pfile_in_zip_read_info == NULL)
		return UNZ_INTERNALERROR;

	pfile_in_zip_read_info->read_buffer = (char*)ALLOC(UNZ_BUFSIZE);
	pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
	pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
	pfile_in_zip_read_info->pos_local_extrafield = 0;
	pfile_in_zip_read_info->raw = raw;

	if (pfile_in_zip_read_info->read_buffer == NULL)
	{
		TRYFREE(pfile_in_zip_read_info);
		return UNZ_INTERNALERROR;
	}

	pfile_in_zip_read_info->stream_initialised = 0;

	if (method != NULL)
		*method = (int)s->cur_file_info.compression_method;

	if (level != NULL)
	{
		*level = 6;
		switch (s->cur_file_info.flag & 0x06)
		{
		case 6: *level = 1; break;
		case 4: *level = 2; break;
		case 2: *level = 9; break;
		}
	}

	if ((s->cur_file_info.compression_method != 0) &&
		/* #ifdef HAVE_BZIP2 */
		(s->cur_file_info.compression_method != Z_BZIP2ED) &&
		/* #endif */
		(s->cur_file_info.compression_method != Z_DEFLATED))

		err = UNZ_BADZIPFILE;

	pfile_in_zip_read_info->crc32_wait = s->cur_file_info.crc;
	pfile_in_zip_read_info->crc32 = 0;
	pfile_in_zip_read_info->total_out_64 = 0;
	pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;
	pfile_in_zip_read_info->filestream = s->filestream;
	pfile_in_zip_read_info->z_filefunc = s->z_filefunc;
	pfile_in_zip_read_info->byte_before_the_zipfile = s->byte_before_the_zipfile;

	pfile_in_zip_read_info->stream.total_out = 0;

	if ((s->cur_file_info.compression_method == Z_BZIP2ED) && (!raw))
	{
#ifdef HAVE_BZIP2
		pfile_in_zip_read_info->bstream.bzalloc = (void* (*) (void*, int, int))0;
		pfile_in_zip_read_info->bstream.bzfree = (free_func)0;
		pfile_in_zip_read_info->bstream.opaque = (voidpf)0;
		pfile_in_zip_read_info->bstream.state = (voidpf)0;

		pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
		pfile_in_zip_read_info->stream.zfree = (free_func)0;
		pfile_in_zip_read_info->stream.opaque = (voidpf)0;
		pfile_in_zip_read_info->stream.next_in = (voidpf)0;
		pfile_in_zip_read_info->stream.avail_in = 0;

		err = BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);
		if (err == Z_OK)
			pfile_in_zip_read_info->stream_initialised = Z_BZIP2ED;
		else
		{
			TRYFREE(pfile_in_zip_read_info);
			return err;
		}
#else
		pfile_in_zip_read_info->raw = 1;
#endif
	}
	else if ((s->cur_file_info.compression_method == Z_DEFLATED) && (!raw))
	{
		pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
		pfile_in_zip_read_info->stream.zfree = (free_func)0;
		pfile_in_zip_read_info->stream.opaque = (voidpf)0;
		pfile_in_zip_read_info->stream.next_in = 0;
		pfile_in_zip_read_info->stream.avail_in = 0;

		err = inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
		if (err == Z_OK)
			pfile_in_zip_read_info->stream_initialised = Z_DEFLATED;
		else
		{
			TRYFREE(pfile_in_zip_read_info);
			return err;
		}
		/* windowBits is passed < 0 to tell that there is no zlib header.
		 * Note that in this case inflate *requires* an extra "dummy" byte
		 * after the compressed stream in order to complete decompression and
		 * return Z_STREAM_END.
		 * In unzip, i don't wait absolutely Z_STREAM_END because I known the
		 * size of both compressed and uncompressed data
		 */
	}
	pfile_in_zip_read_info->rest_read_compressed =
		s->cur_file_info.compressed_size;
	pfile_in_zip_read_info->rest_read_uncompressed =
		s->cur_file_info.uncompressed_size;


	pfile_in_zip_read_info->pos_in_zipfile =
		s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
		iSizeVar;

	pfile_in_zip_read_info->stream.avail_in = (uInt)0;

	s->pfile_in_zip_read = pfile_in_zip_read_info;
	s->encrypted = 0;

#    ifndef NOUNCRYPT
	if (password != NULL)
	{
		int i;
		s->pcrc_32_tab = get_crc_table();
		init_keys(password, s->keys, s->pcrc_32_tab);
		if (ZSEEK64(s->z_filefunc, s->filestream,
			s->pfile_in_zip_read->pos_in_zipfile +
			s->pfile_in_zip_read->byte_before_the_zipfile,
			SEEK_SET) != 0)
			return UNZ_INTERNALERROR;
		if (ZREAD64(s->z_filefunc, s->filestream, source, 12) < 12)
			return UNZ_INTERNALERROR;

		for (i = 0; i < 12; i++)
			zdecode(s->keys, s->pcrc_32_tab, source[i]);

		s->pfile_in_zip_read->pos_in_zipfile += 12;
		s->encrypted = 1;
	}
#    endif


	return UNZ_OK;
}

extern int ZEXPORT unzOpenCurrentFile(unzFile file)
{
	return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
}

extern int ZEXPORT unzOpenCurrentFilePassword(unzFile file, const char* password)
{
	return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
}

extern int ZEXPORT unzOpenCurrentFile2(unzFile file, int* method, int* level, int raw)
{
	return unzOpenCurrentFile3(file, method, level, raw, NULL);
}

/** Addition for GDAL : START */

extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64(unzFile file)
{
	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	s = (unz64_s*)file;
	if (file == NULL)
		return 0; //UNZ_PARAMERROR;
	pfile_in_zip_read_info = s->pfile_in_zip_read;
	if (pfile_in_zip_read_info == NULL)
		return 0; //UNZ_PARAMERROR;
	return pfile_in_zip_read_info->pos_in_zipfile +
		pfile_in_zip_read_info->byte_before_the_zipfile;
}

/** Addition for GDAL : END */

/*
  Read bytes from the current file.
  buf contain buffer where data must be copied
  len the size of buf.

  return the number of byte copied if somes bytes are copied
  return 0 if the end of file was reached
  return <0 with error code if there is an error
	(UNZ_ERRNO for IO error, or zLib error for uncompress error)
*/
extern int ZEXPORT unzReadCurrentFile(unzFile file, voidp buf, unsigned len)
{
	int err = UNZ_OK;
	uInt iRead = 0;
	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	pfile_in_zip_read_info = s->pfile_in_zip_read;

	if (pfile_in_zip_read_info == NULL)
		return UNZ_PARAMERROR;


	if (pfile_in_zip_read_info->read_buffer == NULL)
		return UNZ_END_OF_LIST_OF_FILE;
	if (len == 0)
		return 0;

	pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;

	pfile_in_zip_read_info->stream.avail_out = (uInt)len;

	if ((len > pfile_in_zip_read_info->rest_read_uncompressed) &&
		(!(pfile_in_zip_read_info->raw)))
		pfile_in_zip_read_info->stream.avail_out =
		(uInt)pfile_in_zip_read_info->rest_read_uncompressed;

	if ((len > pfile_in_zip_read_info->rest_read_compressed +
		pfile_in_zip_read_info->stream.avail_in) &&
		(pfile_in_zip_read_info->raw))
		pfile_in_zip_read_info->stream.avail_out =
		(uInt)pfile_in_zip_read_info->rest_read_compressed +
		pfile_in_zip_read_info->stream.avail_in;

	while (pfile_in_zip_read_info->stream.avail_out > 0)
	{
		if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
			(pfile_in_zip_read_info->rest_read_compressed > 0))
		{
			uInt uReadThis = UNZ_BUFSIZE;
			if (pfile_in_zip_read_info->rest_read_compressed < uReadThis)
				uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
			if (uReadThis == 0)
				return UNZ_EOF;
			if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
				pfile_in_zip_read_info->filestream,
				pfile_in_zip_read_info->pos_in_zipfile +
				pfile_in_zip_read_info->byte_before_the_zipfile,
				ZLIB_FILEFUNC_SEEK_SET) != 0)
				return UNZ_ERRNO;
			if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
				pfile_in_zip_read_info->filestream,
				pfile_in_zip_read_info->read_buffer,
				uReadThis) != uReadThis)
				return UNZ_ERRNO;


#            ifndef NOUNCRYPT
			if (s->encrypted)
			{
				uInt i;
				for (i = 0; i < uReadThis; i++)
					pfile_in_zip_read_info->read_buffer[i] =
					zdecode(s->keys, s->pcrc_32_tab,
						pfile_in_zip_read_info->read_buffer[i]);
			}
#            endif


			pfile_in_zip_read_info->pos_in_zipfile += uReadThis;

			pfile_in_zip_read_info->rest_read_compressed -= uReadThis;

			pfile_in_zip_read_info->stream.next_in =
				(Bytef*)pfile_in_zip_read_info->read_buffer;
			pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
		}

		if ((pfile_in_zip_read_info->compression_method == 0) || (pfile_in_zip_read_info->raw))
		{
			uInt uDoCopy, i;

			if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
				(pfile_in_zip_read_info->rest_read_compressed == 0))
				return (iRead == 0) ? UNZ_EOF : iRead;

			if (pfile_in_zip_read_info->stream.avail_out <
				pfile_in_zip_read_info->stream.avail_in)
				uDoCopy = pfile_in_zip_read_info->stream.avail_out;
			else
				uDoCopy = pfile_in_zip_read_info->stream.avail_in;

			for (i = 0; i < uDoCopy; i++)
				*(pfile_in_zip_read_info->stream.next_out + i) =
				*(pfile_in_zip_read_info->stream.next_in + i);

			pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;

			pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
				pfile_in_zip_read_info->stream.next_out,
				uDoCopy);
			pfile_in_zip_read_info->rest_read_uncompressed -= uDoCopy;
			pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
			pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
			pfile_in_zip_read_info->stream.next_out += uDoCopy;
			pfile_in_zip_read_info->stream.next_in += uDoCopy;
			pfile_in_zip_read_info->stream.total_out += uDoCopy;
			iRead += uDoCopy;
		}
		else if (pfile_in_zip_read_info->compression_method == Z_BZIP2ED)
		{
#ifdef HAVE_BZIP2
			uLong uTotalOutBefore, uTotalOutAfter;
			const Bytef* bufBefore;
			uLong uOutThis;

			pfile_in_zip_read_info->bstream.next_in = (char*)pfile_in_zip_read_info->stream.next_in;
			pfile_in_zip_read_info->bstream.avail_in = pfile_in_zip_read_info->stream.avail_in;
			pfile_in_zip_read_info->bstream.total_in_lo32 = pfile_in_zip_read_info->stream.total_in;
			pfile_in_zip_read_info->bstream.total_in_hi32 = 0;
			pfile_in_zip_read_info->bstream.next_out = (char*)pfile_in_zip_read_info->stream.next_out;
			pfile_in_zip_read_info->bstream.avail_out = pfile_in_zip_read_info->stream.avail_out;
			pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;
			pfile_in_zip_read_info->bstream.total_out_hi32 = 0;

			uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;
			bufBefore = (const Bytef*)pfile_in_zip_read_info->bstream.next_out;

			err = BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);

			uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;
			uOutThis = uTotalOutAfter - uTotalOutBefore;

			pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;

			pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32, bufBefore, (uInt)(uOutThis));
			pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;
			iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);

			pfile_in_zip_read_info->stream.next_in = (Bytef*)pfile_in_zip_read_info->bstream.next_in;
			pfile_in_zip_read_info->stream.avail_in = pfile_in_zip_read_info->bstream.avail_in;
			pfile_in_zip_read_info->stream.total_in = pfile_in_zip_read_info->bstream.total_in_lo32;
			pfile_in_zip_read_info->stream.next_out = (Bytef*)pfile_in_zip_read_info->bstream.next_out;
			pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;
			pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;

			if (err == BZ_STREAM_END)
				return (iRead == 0) ? UNZ_EOF : iRead;
			if (err != BZ_OK)
				break;
#endif
		} // end Z_BZIP2ED
		else
		{
			ZPOS64_T uTotalOutBefore, uTotalOutAfter;
			const Bytef* bufBefore;
			ZPOS64_T uOutThis;
			int flush = Z_SYNC_FLUSH;

			uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
			bufBefore = pfile_in_zip_read_info->stream.next_out;

			/*
			if ((pfile_in_zip_read_info->rest_read_uncompressed ==
					 pfile_in_zip_read_info->stream.avail_out) &&
				(pfile_in_zip_read_info->rest_read_compressed == 0))
				flush = Z_FINISH;
			*/
			err = inflate(&pfile_in_zip_read_info->stream, flush);

			if ((err >= 0) && (pfile_in_zip_read_info->stream.msg != NULL))
				err = Z_DATA_ERROR;

			uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
			uOutThis = uTotalOutAfter - uTotalOutBefore;

			pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;

			pfile_in_zip_read_info->crc32 =
				crc32(pfile_in_zip_read_info->crc32, bufBefore,
					(uInt)(uOutThis));

			pfile_in_zip_read_info->rest_read_uncompressed -=
				uOutThis;

			iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);

			if (err == Z_STREAM_END)
				return (iRead == 0) ? UNZ_EOF : iRead;
			if (err != Z_OK)
				break;
		}
	}

	if (err == Z_OK)
		return iRead;
	return err;
}


/*
  Give the current position in uncompressed data
*/
extern z_off_t ZEXPORT unztell(unzFile file)
{
	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	pfile_in_zip_read_info = s->pfile_in_zip_read;

	if (pfile_in_zip_read_info == NULL)
		return UNZ_PARAMERROR;

	return (z_off_t)pfile_in_zip_read_info->stream.total_out;
}

extern ZPOS64_T ZEXPORT unztell64(unzFile file)
{

	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	if (file == NULL)
		return (ZPOS64_T)-1;
	s = (unz64_s*)file;
	pfile_in_zip_read_info = s->pfile_in_zip_read;

	if (pfile_in_zip_read_info == NULL)
		return (ZPOS64_T)-1;

	return pfile_in_zip_read_info->total_out_64;
}


/*
  return 1 if the end of file was reached, 0 elsewhere
*/
extern int ZEXPORT unzeof(unzFile file)
{
	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	pfile_in_zip_read_info = s->pfile_in_zip_read;

	if (pfile_in_zip_read_info == NULL)
		return UNZ_PARAMERROR;

	if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
		return 1;
	else
		return 0;
}



/*
Read extra field from the current file (opened by unzOpenCurrentFile)
This is the local-header version of the extra field (somezl_TIMEs, there is
more info in the local-header version than in the central-header)

  if buf==NULL, it return the size of the local extra field that can be read

  if buf!=NULL, len is the size of the buffer, the extra header is copied in
	buf.
  the return value is the number of bytes copied in buf, or (if <0)
	the error code
*/
extern int ZEXPORT unzGetLocalExtrafield(unzFile file, voidp buf, unsigned len)
{
	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	uInt read_now;
	ZPOS64_T size_to_read;

	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	pfile_in_zip_read_info = s->pfile_in_zip_read;

	if (pfile_in_zip_read_info == NULL)
		return UNZ_PARAMERROR;

	size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
		pfile_in_zip_read_info->pos_local_extrafield);

	if (buf == NULL)
		return (int)size_to_read;

	if (len > size_to_read)
		read_now = (uInt)size_to_read;
	else
		read_now = (uInt)len;

	if (read_now == 0)
		return 0;

	if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
		pfile_in_zip_read_info->filestream,
		pfile_in_zip_read_info->offset_local_extrafield +
		pfile_in_zip_read_info->pos_local_extrafield,
		ZLIB_FILEFUNC_SEEK_SET) != 0)
		return UNZ_ERRNO;

	if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
		pfile_in_zip_read_info->filestream,
		buf, read_now) != read_now)
		return UNZ_ERRNO;

	return (int)read_now;
}

/*
  Close the file in zip opened with unzOpenCurrentFile
  Return UNZ_CRCERROR if all the file was read but the CRC is not good
*/
extern int ZEXPORT unzCloseCurrentFile(unzFile file)
{
	int err = UNZ_OK;

	unz64_s* s;
	file_in_zip64_read_info_s* pfile_in_zip_read_info;
	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;
	pfile_in_zip_read_info = s->pfile_in_zip_read;

	if (pfile_in_zip_read_info == NULL)
		return UNZ_PARAMERROR;


	if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
		(!pfile_in_zip_read_info->raw))
	{
		if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
			err = UNZ_CRCERROR;
	}


	TRYFREE(pfile_in_zip_read_info->read_buffer);
	pfile_in_zip_read_info->read_buffer = NULL;
	if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)
		inflateEnd(&pfile_in_zip_read_info->stream);
#ifdef HAVE_BZIP2
	else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)
		BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);
#endif


	pfile_in_zip_read_info->stream_initialised = 0;
	TRYFREE(pfile_in_zip_read_info);

	s->pfile_in_zip_read = NULL;

	return err;
}


/*
  Get the global comment string of the ZipFile, in the szComment buffer.
  uSizeBuf is the size of the szComment buffer.
  return the number of byte copied or an error code <0
*/
extern int ZEXPORT unzGetGlobalComment(unzFile file, char* szComment, uLong uSizeBuf)
{
	unz64_s* s;
	uLong uReadThis;
	if (file == NULL)
		return (int)UNZ_PARAMERROR;
	s = (unz64_s*)file;

	uReadThis = uSizeBuf;
	if (uReadThis > s->gi.size_comment)
		uReadThis = s->gi.size_comment;

	if (ZSEEK64(s->z_filefunc, s->filestream, s->central_pos + 22, ZLIB_FILEFUNC_SEEK_SET) != 0)
		return UNZ_ERRNO;

	if (uReadThis > 0)
	{
		*szComment = '\0';
		if (ZREAD64(s->z_filefunc, s->filestream, szComment, uReadThis) != uReadThis)
			return UNZ_ERRNO;
	}

	if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
		*(szComment + s->gi.size_comment) = '\0';
	return (int)uReadThis;
}

/* Additions by RX '2004 */
extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)
{
	unz64_s* s;

	if (file == NULL)
		return 0; //UNZ_PARAMERROR;
	s = (unz64_s*)file;
	if (!s->current_file_ok)
		return 0;
	if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
		if (s->num_file == s->gi.number_entry)
			return 0;
	return s->pos_in_central_dir;
}

extern uLong ZEXPORT unzGetOffset(unzFile file)
{
	ZPOS64_T offset64;

	if (file == NULL)
		return 0; //UNZ_PARAMERROR;
	offset64 = unzGetOffset64(file);
	return (uLong)offset64;
}

extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos)
{
	unz64_s* s;
	int err;

	if (file == NULL)
		return UNZ_PARAMERROR;
	s = (unz64_s*)file;

	s->pos_in_central_dir = pos;
	s->num_file = s->gi.number_entry;      /* hack */
	err = unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info,
		&s->cur_file_info_internal,
		NULL, 0, NULL, 0, NULL, 0);
	s->current_file_ok = (err == UNZ_OK);
	return err;
}

extern int ZEXPORT unzSetOffset(unzFile file, uLong pos)
{
	return unzSetOffset64(file, pos);
}
































/* zip.c -- IO on .zip files using zlib
   Version 1.1, February 14h, 2010
   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )

		 Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )

		 Modifications for Zip64 support
		 Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )

		 For more info read MiniZip_info.txt

		 Changes
   Oct-2009 - Mathias Svensson - Remove old C style function prototypes
   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives
   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.
   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data
								 It is used when recreting zip archive with RAW when deleting items from a zip.
								 ZIP64 data is automatically added to items that needs it, and existing ZIP64 data need to be removed.
   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)
   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer

*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <TIME.h>
//#include "zlib.h"
//#include "zip.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
extern int errno;
#else
#   include <errno.h>
#endif


#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

#ifndef VERSIONMADEBY
# define VERSIONMADEBY   (0x0) /* platform depedent */
#endif

#ifndef Z_BUFSIZE
#define Z_BUFSIZE (64*1024) //(16384)
#endif

#ifndef Z_MAXFILENAMEINZIP
#define Z_MAXFILENAMEINZIP (256)
#endif

#ifndef ALLOC
# define ALLOC(size) (malloc(size))
#endif
#ifndef TRYFREE
# define TRYFREE(p) {if (p) free(p);}
#endif

/*
#define SIZECENTRALDIRITEM (0x2e)
#define SIZEZIPLOCALHEADER (0x1e)
*/

/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */


// NOT sure that this work on ALL platform
#define MAKEULONG64(a, b) ((ZPOS64_T)(((unsigned long)(a)) | ((ZPOS64_T)((unsigned long)(b))) << 32))

#ifndef SEEK_CUR
#define SEEK_CUR    1
#endif

#ifndef SEEK_END
#define SEEK_END    2
#endif

#ifndef SEEK_SET
#define SEEK_SET    0
#endif

#ifndef DEF_MEM_LEVEL
#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
#endif
const char zip_copyright[] = " zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";


#define SIZEDATA_INDATABLOCK (4096-(4*4))

#define LOCALHEADERMAGIC    (0x04034b50)
#define CENTRALHEADERMAGIC  (0x02014b50)
#define ENDHEADERMAGIC      (0x06054b50)
#define ZIP64ENDHEADERMAGIC      (0x6064b50)
#define ZIP64ENDLOCHEADERMAGIC   (0x7064b50)

#define FLAG_LOCALHEADER_OFFSET (0x06)
#define CRC_LOCALHEADER_OFFSET  (0x0e)

#define SIZECENTRALHEADER (0x2e) /* 46 */

typedef struct linkedlist_datablock_internal_s
{
	struct linkedlist_datablock_internal_s* next_datablock;
	uLong  avail_in_this_block;
	uLong  filled_in_this_block;
	uLong  unused; /* for future use and alignment */
	unsigned char data[SIZEDATA_INDATABLOCK];
} linkedlist_datablock_internal;

typedef struct linkedlist_data_s
{
	linkedlist_datablock_internal* first_block;
	linkedlist_datablock_internal* last_block;
} linkedlist_data;


typedef struct
{
	z_stream stream;            /* zLib stream structure for inflate */
#ifdef HAVE_BZIP2
	bz_stream bstream;          /* bzLib stream structure for bziped */
#endif

	int  stream_initialised;    /* 1 is stream is initialised */
	uInt pos_in_buffered_data;  /* last written byte in buffered_data */

	ZPOS64_T pos_local_header;     /* offset of the local header of the file
									 currenty writing */
	char* central_header;       /* central header data for the current file */
	uLong size_centralExtra;
	uLong size_centralheader;   /* size of the central header for cur file */
	uLong size_centralExtraFree; /* Extra bytes allocated to the centralheader but that are not used */
	uLong flag;                 /* flag of the file currently writing */

	int  method;                /* compression method of file currenty wr.*/
	int  raw;                   /* 1 for directly writing raw data */
	Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
	uLong dosDate;
	uLong crc32;
	int  encrypt;
	int  zip64;               /* Add ZIP64 extened information in the extra field */
	ZPOS64_T pos_zip64extrainfo;
	ZPOS64_T totalCompressedData;
	ZPOS64_T totalUncompressedData;
#ifndef NOCRYPT
	unsigned long keys[3];     /* keys defining the pseudo-random sequence */
	const z_crc_t* pcrc_32_tab;
	int crypt_header_size;
#endif
} curfile64_info;

typedef struct
{
	zlib_filefunc64_32_def z_filefunc;
	voidpf filestream;        /* io structore of the zipfile */
	linkedlist_data central_dir;/* datablock with central dir in construction*/
	int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
	curfile64_info ci;            /* info on the file curretly writing */

	ZPOS64_T begin_pos;            /* position of the beginning of the zipfile */
	ZPOS64_T add_position_when_writing_offset;
	ZPOS64_T number_entry;

#ifndef NO_ADDFILEINEXISTINGZIP
	char* globalcomment;
#endif

} zip64_internal;


#ifndef NOCRYPT
#define INCLUDECRYPTINGCODE_IFCRYPTALLOWED





















/* crypt.h -- base code for crypt/uncrypt ZIPfile


   Version 1.01e, February 12th, 2005

   Copyright (C) 1998-2005 Gilles Vollant

   This code is a modified version of crypting code in Infozip distribution

   The encryption/decryption parts of this source code (as opposed to the
   non-echoing password parts) were originally written in Europe.  The
   whole source package can be freely distributed, including from the USA.
   (Prior to January 2000, re-export from the US was a violation of US law.)

   This encryption code is a direct transcription of the algorithm from
   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
   file (appnote.txt) is distributed with the PKZIP program (even in the
   version without encryption capabilities).

   If you don't need crypting in your application, just define symbols
   NOCRYPT and NOUNCRYPT.

   This code support the "Traditional PKWARE Encryption".

   The new AES encryption added on Zip format by Winzip (see the page
   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
   Encryption is not supported.
*/

#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))

/***********************************************************************
 * Return the next byte in the pseudo-random sequence
 */
static int decrypt_byte(unsigned long* pkeys, const z_crc_t* pcrc_32_tab)
{
	unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
					 * unpredictable manner on 16-bit systems; not a problem
					 * with any known compiler so far, though */

	temp = ((unsigned)(*(pkeys + 2)) & 0xffff) | 2;
	return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
}

/***********************************************************************
 * Update the encryption keys with the next byte of plain text
 */
static int update_keys(unsigned long* pkeys, const z_crc_t* pcrc_32_tab, int c)
{
	(*(pkeys + 0)) = CRC32((*(pkeys + 0)), c);
	(*(pkeys + 1)) += (*(pkeys + 0)) & 0xff;
	(*(pkeys + 1)) = (*(pkeys + 1)) * 134775813L + 1;
	{
		// register int keyshift = (int)((*(pkeys + 1)) >> 24);
		int keyshift = (int)((*(pkeys + 1)) >> 24);
		(*(pkeys + 2)) = CRC32((*(pkeys + 2)), keyshift);
	}
	return c;
}


/***********************************************************************
 * Initialize the encryption keys and the random header according to
 * the given password.
 */
static void init_keys(const char* passwd, unsigned long* pkeys, const z_crc_t* pcrc_32_tab)
{
	*(pkeys + 0) = 305419896L;
	*(pkeys + 1) = 591751049L;
	*(pkeys + 2) = 878082192L;
	while (*passwd != '\0') {
		update_keys(pkeys, pcrc_32_tab, (int)*passwd);
		passwd++;
	}
}

#define zdecode(pkeys,pcrc_32_tab,c) \
    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))

#define zencode(pkeys,pcrc_32_tab,c,t) \
    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))

#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED

#define RAND_HEAD_LEN  12
/* "last resort" source for second part of crypt seed pattern */
#  ifndef ZCR_SEED2
#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
#  endif

static int crypthead(const char* passwd,      /* password string */
	unsigned char* buf,      /* where to write header */
	int bufSize,
	unsigned long* pkeys,
	const z_crc_t* pcrc_32_tab,
	unsigned long crcForCrypting)
{
	int n;                       /* index in random header */
	int t;                       /* temporary */
	int c;                       /* random byte */
	unsigned char header[RAND_HEAD_LEN - 2]; /* random header */
	static unsigned calls = 0;   /* ensure different random header each zl_TIME */

	if (bufSize < RAND_HEAD_LEN)
		return 0;

	/* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
	 * output of rand() to get less predictability, since rand() is
	 * often poorly implemented.
	 */
	if (++calls == 1)
	{
		srand((unsigned)(time(NULL) ^ ZCR_SEED2));
	}
	init_keys(passwd, pkeys, pcrc_32_tab);
	for (n = 0; n < RAND_HEAD_LEN - 2; n++)
	{
		c = (rand() >> 7) & 0xff;
		header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
	}
	/* Encrypt random header (last two bytes is high word of crc) */
	init_keys(passwd, pkeys, pcrc_32_tab);
	for (n = 0; n < RAND_HEAD_LEN - 2; n++)
	{
		buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
	}
	buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
	buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
	return n;
}

#endif









#endif

local linkedlist_datablock_internal* allocate_new_datablock()
{
	linkedlist_datablock_internal* ldi;
	ldi = (linkedlist_datablock_internal*)
		ALLOC(sizeof(linkedlist_datablock_internal));
	if (ldi != NULL)
	{
		ldi->next_datablock = NULL;
		ldi->filled_in_this_block = 0;
		ldi->avail_in_this_block = SIZEDATA_INDATABLOCK;
	}
	return ldi;
}

local void free_datablock(linkedlist_datablock_internal* ldi)
{
	while (ldi != NULL)
	{
		linkedlist_datablock_internal* ldinext = ldi->next_datablock;
		TRYFREE(ldi);
		ldi = ldinext;
	}
}

local void init_linkedlist(linkedlist_data* ll)
{
	ll->first_block = ll->last_block = NULL;
}

local void free_linkedlist(linkedlist_data* ll)
{
	free_datablock(ll->first_block);
	ll->first_block = ll->last_block = NULL;
}


local int add_data_in_datablock(linkedlist_data* ll, const void* buf, uLong len)
{
	linkedlist_datablock_internal* ldi;
	const unsigned char* from_copy;

	if (ll == NULL)
		return ZIP_INTERNALERROR;

	if (ll->last_block == NULL)
	{
		ll->first_block = ll->last_block = allocate_new_datablock();
		if (ll->first_block == NULL)
			return ZIP_INTERNALERROR;
	}

	ldi = ll->last_block;
	from_copy = (unsigned char*)buf;

	while (len > 0)
	{
		uInt copy_this;
		uInt i;
		unsigned char* to_copy;

		if (ldi->avail_in_this_block == 0)
		{
			ldi->next_datablock = allocate_new_datablock();
			if (ldi->next_datablock == NULL)
				return ZIP_INTERNALERROR;
			ldi = ldi->next_datablock;
			ll->last_block = ldi;
		}

		if (ldi->avail_in_this_block < len)
			copy_this = (uInt)ldi->avail_in_this_block;
		else
			copy_this = (uInt)len;

		to_copy = &(ldi->data[ldi->filled_in_this_block]);

		for (i = 0; i < copy_this; i++)
			*(to_copy + i) = *(from_copy + i);

		ldi->filled_in_this_block += copy_this;
		ldi->avail_in_this_block -= copy_this;
		from_copy += copy_this;
		len -= copy_this;
	}
	return ZIP_OK;
}



/****************************************************************************/

#ifndef NO_ADDFILEINEXISTINGZIP
/* ===========================================================================
   Inputs a long in LSB order to the given file
   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)
*/

local int zip64local_putValue OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte));
local int zip64local_putValue(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte)
{
	unsigned char buf[8];
	int n;
	for (n = 0; n < nbByte; n++)
	{
		buf[n] = (unsigned char)(x & 0xff);
		x >>= 8;
	}
	if (x != 0)
	{     /* data overflow - hack for ZIP64 (X Roche) */
		for (n = 0; n < nbByte; n++)
		{
			buf[n] = 0xff;
		}
	}

	if (ZWRITE64(*pzlib_filefunc_def, filestream, buf, nbByte) != (uLong)nbByte)
		return ZIP_ERRNO;
	else
		return ZIP_OK;
}

local void zip64local_putValue_inmemory OF((void* dest, ZPOS64_T x, int nbByte));
local void zip64local_putValue_inmemory(void* dest, ZPOS64_T x, int nbByte)
{
	unsigned char* buf = (unsigned char*)dest;
	int n;
	for (n = 0; n < nbByte; n++) {
		buf[n] = (unsigned char)(x & 0xff);
		x >>= 8;
	}

	if (x != 0)
	{     /* data overflow - hack for ZIP64 */
		for (n = 0; n < nbByte; n++)
		{
			buf[n] = 0xff;
		}
	}
}

/****************************************************************************/


local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm)
{
	uLong year = (uLong)ptm->tm_year;
	if (year >= 1980)
		year -= 1980;
	else if (year >= 80)
		year -= 80;
	return
		(uLong)(((ptm->tm_mday) + (32 * (ptm->tm_mon + 1)) + (512 * year)) << 16) |
		((ptm->tm_sec / 2) + (32 * ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
}


/****************************************************************************/

local int zip64local_getByte OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int* pi));

local int zip64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int* pi)
{
	unsigned char c;
	int err = (int)ZREAD64(*pzlib_filefunc_def, filestream, &c, 1);
	if (err == 1)
	{
		*pi = (int)c;
		return ZIP_OK;
	}
	else
	{
		if (ZERROR64(*pzlib_filefunc_def, filestream))
			return ZIP_ERRNO;
		else
			return ZIP_EOF;
	}
}


/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets
*/
local int zip64local_getShort OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX));

local int zip64local_getShort(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
{
	uLong x;
	int i = 0;
	int err;

	err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x = (uLong)i;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((uLong)i) << 8;

	if (err == ZIP_OK)
		*pX = x;
	else
		*pX = 0;
	return err;
}

local int zip64local_getLong OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX));

local int zip64local_getLong(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
{
	uLong x;
	int i = 0;
	int err;

	err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x = (uLong)i;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((uLong)i) << 8;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((uLong)i) << 16;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((uLong)i) << 24;

	if (err == ZIP_OK)
		*pX = x;
	else
		*pX = 0;
	return err;
}

local int zip64local_getLong64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T* pX));


local int zip64local_getLong64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T* pX)
{
	ZPOS64_T x;
	int i = 0;
	int err;

	err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x = (ZPOS64_T)i;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((ZPOS64_T)i) << 8;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((ZPOS64_T)i) << 16;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((ZPOS64_T)i) << 24;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((ZPOS64_T)i) << 32;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((ZPOS64_T)i) << 40;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((ZPOS64_T)i) << 48;

	if (err == ZIP_OK)
		err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
	x += ((ZPOS64_T)i) << 56;

	if (err == ZIP_OK)
		*pX = x;
	else
		*pX = 0;

	return err;
}

#ifndef BUFREADCOMMENT
#define BUFREADCOMMENT (0x400)
#endif
/*
  Locate the Central directory of a zipfile (at the end, just before
	the global comment)
*/
local ZPOS64_T zip64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));

local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
{
	unsigned char* buf;
	ZPOS64_T uSizeFile;
	ZPOS64_T uBackRead;
	ZPOS64_T uMaxBack = 0xffff; /* maximum size of global comment */
	ZPOS64_T uPosFound = 0;

	if (ZSEEK64(*pzlib_filefunc_def, filestream, 0, ZLIB_FILEFUNC_SEEK_END) != 0)
		return 0;


	uSizeFile = ZTELL64(*pzlib_filefunc_def, filestream);

	if (uMaxBack > uSizeFile)
		uMaxBack = uSizeFile;

	buf = (unsigned char*)ALLOC(BUFREADCOMMENT + 4);
	if (buf == NULL)
		return 0;

	uBackRead = 4;
	while (uBackRead < uMaxBack)
	{
		uLong uReadSize;
		ZPOS64_T uReadPos;
		int i;
		if (uBackRead + BUFREADCOMMENT > uMaxBack)
			uBackRead = uMaxBack;
		else
			uBackRead += BUFREADCOMMENT;
		uReadPos = uSizeFile - uBackRead;

		uReadSize = ((BUFREADCOMMENT + 4) < (uSizeFile - uReadPos)) ?
			(BUFREADCOMMENT + 4) : (uLong)(uSizeFile - uReadPos);
		if (ZSEEK64(*pzlib_filefunc_def, filestream, uReadPos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			break;

		if (ZREAD64(*pzlib_filefunc_def, filestream, buf, uReadSize) != uReadSize)
			break;

		for (i = (int)uReadSize - 3; (i--) > 0;)
			if (((*(buf + i)) == 0x50) && ((*(buf + i + 1)) == 0x4b) &&
				((*(buf + i + 2)) == 0x05) && ((*(buf + i + 3)) == 0x06))
			{
				uPosFound = uReadPos + i;
				break;
			}

		if (uPosFound != 0)
			break;
	}
	TRYFREE(buf);
	return uPosFound;
}

/*
Locate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just before
the global comment)
*/
local ZPOS64_T zip64local_SearchCentralDir64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));

local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
{
	unsigned char* buf;
	ZPOS64_T uSizeFile;
	ZPOS64_T uBackRead;
	ZPOS64_T uMaxBack = 0xffff; /* maximum size of global comment */
	ZPOS64_T uPosFound = 0;
	uLong uL;
	ZPOS64_T relativeOffset;

	if (ZSEEK64(*pzlib_filefunc_def, filestream, 0, ZLIB_FILEFUNC_SEEK_END) != 0)
		return 0;

	uSizeFile = ZTELL64(*pzlib_filefunc_def, filestream);

	if (uMaxBack > uSizeFile)
		uMaxBack = uSizeFile;

	buf = (unsigned char*)ALLOC(BUFREADCOMMENT + 4);
	if (buf == NULL)
		return 0;

	uBackRead = 4;
	while (uBackRead < uMaxBack)
	{
		uLong uReadSize;
		ZPOS64_T uReadPos;
		int i;
		if (uBackRead + BUFREADCOMMENT > uMaxBack)
			uBackRead = uMaxBack;
		else
			uBackRead += BUFREADCOMMENT;
		uReadPos = uSizeFile - uBackRead;

		uReadSize = ((BUFREADCOMMENT + 4) < (uSizeFile - uReadPos)) ?
			(BUFREADCOMMENT + 4) : (uLong)(uSizeFile - uReadPos);
		if (ZSEEK64(*pzlib_filefunc_def, filestream, uReadPos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			break;

		if (ZREAD64(*pzlib_filefunc_def, filestream, buf, uReadSize) != uReadSize)
			break;

		for (i = (int)uReadSize - 3; (i--) > 0;)
		{
			// Signature "0x07064b50" Zip64 end of central directory locater
			if (((*(buf + i)) == 0x50) && ((*(buf + i + 1)) == 0x4b) && ((*(buf + i + 2)) == 0x06) && ((*(buf + i + 3)) == 0x07))
			{
				uPosFound = uReadPos + i;
				break;
			}
		}

		if (uPosFound != 0)
			break;
	}

	TRYFREE(buf);
	if (uPosFound == 0)
		return 0;

	/* Zip64 end of central directory locator */
	if (ZSEEK64(*pzlib_filefunc_def, filestream, uPosFound, ZLIB_FILEFUNC_SEEK_SET) != 0)
		return 0;

	/* the signature, already checked */
	if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
		return 0;

	/* number of the disk with the start of the zip64 end of  central directory */
	if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
		return 0;
	if (uL != 0)
		return 0;

	/* relative offset of the zip64 end of central directory record */
	if (zip64local_getLong64(pzlib_filefunc_def, filestream, &relativeOffset) != ZIP_OK)
		return 0;

	/* total number of disks */
	if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
		return 0;
	if (uL != 1)
		return 0;

	/* Goto Zip64 end of central directory record */
	if (ZSEEK64(*pzlib_filefunc_def, filestream, relativeOffset, ZLIB_FILEFUNC_SEEK_SET) != 0)
		return 0;

	/* the signature */
	if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
		return 0;

	if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'
		return 0;

	return relativeOffset;
}

int LoadCentralDirectoryRecord(zip64_internal* pziinit)
{
	int err = ZIP_OK;
	ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/

	ZPOS64_T size_central_dir;     /* size of the central directory  */
	ZPOS64_T offset_central_dir;   /* offset of start of central directory */
	ZPOS64_T central_pos;
	uLong uL;

	uLong number_disk;          /* number of the current dist, used for
								spaning ZIP, unsupported, always 0*/
	uLong number_disk_with_CD;  /* number the the disk with central dir, used
								for spaning ZIP, unsupported, always 0*/
	ZPOS64_T number_entry;
	ZPOS64_T number_entry_CD;      /* total number of entries in
								  the central dir
								  (same than number_entry on nospan) */
	uLong VersionMadeBy;
	uLong VersionNeeded;
	uLong size_comment;

	int hasZIP64Record = 0;

	// check first if we find a ZIP64 record
	central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc, pziinit->filestream);
	if (central_pos > 0)
	{
		hasZIP64Record = 1;
	}
	else if (central_pos == 0)
	{
		central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc, pziinit->filestream);
	}

	/* disable to allow appending to empty ZIP archive
			if (central_pos==0)
				err=ZIP_ERRNO;
	*/

	if (hasZIP64Record)
	{
		ZPOS64_T sizeEndOfCentralDirectory;
		if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			err = ZIP_ERRNO;

		/* the signature, already checked */
		if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL) != ZIP_OK)
			err = ZIP_ERRNO;

		/* size of zip64 end of central directory record */
		if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory) != ZIP_OK)
			err = ZIP_ERRNO;

		/* version made by */
		if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy) != ZIP_OK)
			err = ZIP_ERRNO;

		/* version needed to extract */
		if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded) != ZIP_OK)
			err = ZIP_ERRNO;

		/* number of this disk */
		if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &number_disk) != ZIP_OK)
			err = ZIP_ERRNO;

		/* number of the disk with the start of the central directory */
		if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &number_disk_with_CD) != ZIP_OK)
			err = ZIP_ERRNO;

		/* total number of entries in the central directory on this disk */
		if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry) != ZIP_OK)
			err = ZIP_ERRNO;

		/* total number of entries in the central directory */
		if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry_CD) != ZIP_OK)
			err = ZIP_ERRNO;

		if ((number_entry_CD != number_entry) || (number_disk_with_CD != 0) || (number_disk != 0))
			err = ZIP_BADZIPFILE;

		/* size of the central directory */
		if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &size_central_dir) != ZIP_OK)
			err = ZIP_ERRNO;

		/* offset of start of central directory with respect to the
		starting disk number */
		if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &offset_central_dir) != ZIP_OK)
			err = ZIP_ERRNO;

		// TODO..
		// read the comment from the standard central header.
		size_comment = 0;
	}
	else
	{
		// Read End of central Directory info
		if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
			err = ZIP_ERRNO;

		/* the signature, already checked */
		if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL) != ZIP_OK)
			err = ZIP_ERRNO;

		/* number of this disk */
		if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &number_disk) != ZIP_OK)
			err = ZIP_ERRNO;

		/* number of the disk with the start of the central directory */
		if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &number_disk_with_CD) != ZIP_OK)
			err = ZIP_ERRNO;

		/* total number of entries in the central dir on this disk */
		number_entry = 0;
		if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL) != ZIP_OK)
			err = ZIP_ERRNO;
		else
			number_entry = uL;

		/* total number of entries in the central dir */
		number_entry_CD = 0;
		if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL) != ZIP_OK)
			err = ZIP_ERRNO;
		else
			number_entry_CD = uL;

		if ((number_entry_CD != number_entry) || (number_disk_with_CD != 0) || (number_disk != 0))
			err = ZIP_BADZIPFILE;

		/* size of the central directory */
		size_central_dir = 0;
		if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL) != ZIP_OK)
			err = ZIP_ERRNO;
		else
			size_central_dir = uL;

		/* offset of start of central directory with respect to the starting disk number */
		offset_central_dir = 0;
		if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL) != ZIP_OK)
			err = ZIP_ERRNO;
		else
			offset_central_dir = uL;


		/* zipfile global comment length */
		if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment) != ZIP_OK)
			err = ZIP_ERRNO;
	}

	if ((central_pos < offset_central_dir + size_central_dir) &&
		(err == ZIP_OK))
		err = ZIP_BADZIPFILE;

	if (err != ZIP_OK)
	{
		ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);
		return ZIP_ERRNO;
	}

	if (size_comment > 0)
	{
		pziinit->globalcomment = (char*)ALLOC(size_comment + 1);
		if (pziinit->globalcomment)
		{
			size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment, size_comment);
			pziinit->globalcomment[size_comment] = 0;
		}
	}

	byte_before_the_zipfile = central_pos - (offset_central_dir + size_central_dir);
	pziinit->add_position_when_writing_offset = byte_before_the_zipfile;

	{
		ZPOS64_T size_central_dir_to_read = size_central_dir;
		size_t buf_size = SIZEDATA_INDATABLOCK;
		void* buf_read = (void*)ALLOC(buf_size);
		if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
			err = ZIP_ERRNO;

		while ((size_central_dir_to_read > 0) && (err == ZIP_OK))
		{
			ZPOS64_T read_this = SIZEDATA_INDATABLOCK;
			if (read_this > size_central_dir_to_read)
				read_this = size_central_dir_to_read;

			if (ZREAD64(pziinit->z_filefunc, pziinit->filestream, buf_read, (uLong)read_this) != read_this)
				err = ZIP_ERRNO;

			if (err == ZIP_OK)
				err = add_data_in_datablock(&pziinit->central_dir, buf_read, (uLong)read_this);

			size_central_dir_to_read -= read_this;
		}
		TRYFREE(buf_read);
	}
	pziinit->begin_pos = byte_before_the_zipfile;
	pziinit->number_entry = number_entry_CD;

	if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
		err = ZIP_ERRNO;

	return err;
}


#endif /* !NO_ADDFILEINEXISTINGZIP*/


/************************************************************/
extern zipFile ZEXPORT zipOpen3(const void* pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def)
{
	zip64_internal ziinit;
	zip64_internal* zi;
	int err = ZIP_OK;

	ziinit.z_filefunc.zseek32_file = NULL;
	ziinit.z_filefunc.ztell32_file = NULL;
	if (pzlib_filefunc64_32_def == NULL)
		fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);
	else
		ziinit.z_filefunc = *pzlib_filefunc64_32_def;

	ziinit.filestream = ZOPEN64(ziinit.z_filefunc,
		pathname,
		(append == APPEND_STATUS_CREATE) ?
		(ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
		(ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));

	if (ziinit.filestream == NULL)
		return NULL;

	if (append == APPEND_STATUS_CREATEAFTER)
		ZSEEK64(ziinit.z_filefunc, ziinit.filestream, 0, SEEK_END);

	ziinit.begin_pos = ZTELL64(ziinit.z_filefunc, ziinit.filestream);
	ziinit.in_opened_file_inzip = 0;
	ziinit.ci.stream_initialised = 0;
	ziinit.number_entry = 0;
	ziinit.add_position_when_writing_offset = 0;
	init_linkedlist(&(ziinit.central_dir));



	zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));
	if (zi == NULL)
	{
		ZCLOSE64(ziinit.z_filefunc, ziinit.filestream);
		return NULL;
	}

	/* now we add file in a zipfile */
#    ifndef NO_ADDFILEINEXISTINGZIP
	ziinit.globalcomment = NULL;
	if (append == APPEND_STATUS_ADDINZIP)
	{
		// Read and Cache Central Directory Records
		err = LoadCentralDirectoryRecord(&ziinit);
	}

	if (globalcomment)
	{
		*globalcomment = ziinit.globalcomment;
	}
#    endif /* !NO_ADDFILEINEXISTINGZIP*/

	if (err != ZIP_OK)
	{
#    ifndef NO_ADDFILEINEXISTINGZIP
		TRYFREE(ziinit.globalcomment);
#    endif /* !NO_ADDFILEINEXISTINGZIP*/
		TRYFREE(zi);
		return NULL;
	}
	else
	{
		*zi = ziinit;
		return (zipFile)zi;
	}
}

extern zipFile ZEXPORT zipOpen2(const char* pathname, int append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc32_def)
{
	if (pzlib_filefunc32_def != NULL)
	{
		zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
		fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill, pzlib_filefunc32_def);
		return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
	}
	else
		return zipOpen3(pathname, append, globalcomment, NULL);
}

extern zipFile ZEXPORT zipOpen2_64(const void* pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def)
{
	if (pzlib_filefunc_def != NULL)
	{
		zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
		zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
		zlib_filefunc64_32_def_fill.ztell32_file = NULL;
		zlib_filefunc64_32_def_fill.zseek32_file = NULL;
		return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
	}
	else
		return zipOpen3(pathname, append, globalcomment, NULL);
}



extern zipFile ZEXPORT zipOpen(const char* pathname, int append)
{
	return zipOpen3((const void*)pathname, append, NULL, NULL);
}

extern zipFile ZEXPORT zipOpen64(const void* pathname, int append)
{
	return zipOpen3(pathname, append, NULL, NULL);
}

int Write_LocalFileHeader(zip64_internal* zi, const char* filename, uInt size_extrafield_local, const void* extrafield_local)
{
	/* write the local header */
	int err;
	uInt size_filename = (uInt)strlen(filename);
	uInt size_extrafield = size_extrafield_local;

	err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)LOCALHEADERMAGIC, 4);

	if (err == ZIP_OK)
	{
		if (zi->ci.zip64)
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)45, 2);/* version needed to extract */
		else
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)20, 2);/* version needed to extract */
	}

	if (err == ZIP_OK)
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->ci.flag, 2);

	if (err == ZIP_OK)
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->ci.method, 2);

	if (err == ZIP_OK)
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->ci.dosDate, 4);

	// CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
	if (err == ZIP_OK)
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4); /* crc 32, unknown */
	if (err == ZIP_OK)
	{
		if (zi->ci.zip64)
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xFFFFFFFF, 4); /* compressed size, unknown */
		else
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4); /* compressed size, unknown */
	}
	if (err == ZIP_OK)
	{
		if (zi->ci.zip64)
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xFFFFFFFF, 4); /* uncompressed size, unknown */
		else
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4); /* uncompressed size, unknown */
	}

	if (err == ZIP_OK)
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_filename, 2);

	if (zi->ci.zip64)
	{
		size_extrafield += 20;
	}

	if (err == ZIP_OK)
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_extrafield, 2);

	if ((err == ZIP_OK) && (size_filename > 0))
	{
		if (ZWRITE64(zi->z_filefunc, zi->filestream, filename, size_filename) != size_filename)
			err = ZIP_ERRNO;
	}

	if ((err == ZIP_OK) && (size_extrafield_local > 0))
	{
		if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)
			err = ZIP_ERRNO;
	}


	if ((err == ZIP_OK) && (zi->ci.zip64))
	{
		// write the Zip64 extended info
		short HeaderID = 1;
		short DataSize = 16;
		ZPOS64_T CompressedSize = 0;
		ZPOS64_T UncompressedSize = 0;

		// Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
		zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc, zi->filestream);

		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)HeaderID, 2);
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)DataSize, 2);

		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize, 8);
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize, 8);
	}

	return err;
}

/*
 NOTE.
 When writing RAW the ZIP64 extended information in extrafield_local and extrafield_global needs to be stripped
 before calling this function it can be done with zipRemoveExtraInfoBlock

 It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want to minimize
 unnecessary allocations.
 */
extern int ZEXPORT zipOpenNewFileInZip4_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level, int raw,
	int windowBits, int memLevel, int strategy,
	const char* password, uLong crcForCrypting,
	uLong versionMadeBy, uLong flagBase, int zip64)
{
	zip64_internal* zi;
	uInt size_filename;
	uInt size_comment;
	uInt i;
	int err = ZIP_OK;

#    ifdef NOCRYPT
	(crcForCrypting);
	if (password != NULL)
		return ZIP_PARAMERROR;
#    endif

	if (file == NULL)
		return ZIP_PARAMERROR;

#ifdef HAVE_BZIP2
	if ((method != 0) && (method != Z_DEFLATED) && (method != Z_BZIP2ED))
		return ZIP_PARAMERROR;
#else
	if ((method != 0) && (method != Z_DEFLATED))
		return ZIP_PARAMERROR;
#endif

	zi = (zip64_internal*)file;

	if (zi->in_opened_file_inzip == 1)
	{
		err = zipCloseFileInZip(file);
		if (err != ZIP_OK)
			return err;
	}

	if (filename == NULL)
		filename = "-";

	if (comment == NULL)
		size_comment = 0;
	else
		size_comment = (uInt)strlen(comment);

	size_filename = (uInt)strlen(filename);

	if (zipfi == NULL)
		zi->ci.dosDate = 0;
	else
	{
		if (zipfi->dosDate != 0)
			zi->ci.dosDate = zipfi->dosDate;
		else
			zi->ci.dosDate = zip64local_TmzDateToDosDate(&zipfi->tmz_date);
	}

	zi->ci.flag = flagBase;
	if ((level == 8) || (level == 9))
		zi->ci.flag |= 2;
	if (level == 2)
		zi->ci.flag |= 4;
	if (level == 1)
		zi->ci.flag |= 6;
	if (password != NULL)
		zi->ci.flag |= 1;

	zi->ci.crc32 = 0;
	zi->ci.method = method;
	zi->ci.encrypt = 0;
	zi->ci.stream_initialised = 0;
	zi->ci.pos_in_buffered_data = 0;
	zi->ci.raw = raw;
	zi->ci.pos_local_header = ZTELL64(zi->z_filefunc, zi->filestream);

	zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global + size_comment;
	zi->ci.size_centralExtraFree = 32; // Extra space we have reserved in case we need to add ZIP64 extra info data

	zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader + zi->ci.size_centralExtraFree);

	zi->ci.size_centralExtra = size_extrafield_global;
	zip64local_putValue_inmemory(zi->ci.central_header, (uLong)CENTRALHEADERMAGIC, 4);
	/* version info */
	zip64local_putValue_inmemory(zi->ci.central_header + 4, (uLong)versionMadeBy, 2);
	zip64local_putValue_inmemory(zi->ci.central_header + 6, (uLong)20, 2);
	zip64local_putValue_inmemory(zi->ci.central_header + 8, (uLong)zi->ci.flag, 2);
	zip64local_putValue_inmemory(zi->ci.central_header + 10, (uLong)zi->ci.method, 2);
	zip64local_putValue_inmemory(zi->ci.central_header + 12, (uLong)zi->ci.dosDate, 4);
	zip64local_putValue_inmemory(zi->ci.central_header + 16, (uLong)0, 4); /*crc*/
	zip64local_putValue_inmemory(zi->ci.central_header + 20, (uLong)0, 4); /*compr size*/
	zip64local_putValue_inmemory(zi->ci.central_header + 24, (uLong)0, 4); /*uncompr size*/
	zip64local_putValue_inmemory(zi->ci.central_header + 28, (uLong)size_filename, 2);
	zip64local_putValue_inmemory(zi->ci.central_header + 30, (uLong)size_extrafield_global, 2);
	zip64local_putValue_inmemory(zi->ci.central_header + 32, (uLong)size_comment, 2);
	zip64local_putValue_inmemory(zi->ci.central_header + 34, (uLong)0, 2); /*disk nm start*/

	if (zipfi == NULL)
		zip64local_putValue_inmemory(zi->ci.central_header + 36, (uLong)0, 2);
	else
		zip64local_putValue_inmemory(zi->ci.central_header + 36, (uLong)zipfi->internal_fa, 2);

	if (zipfi == NULL)
		zip64local_putValue_inmemory(zi->ci.central_header + 38, (uLong)0, 4);
	else
		zip64local_putValue_inmemory(zi->ci.central_header + 38, (uLong)zipfi->external_fa, 4);

	if (zi->ci.pos_local_header >= 0xffffffff)
		zip64local_putValue_inmemory(zi->ci.central_header + 42, (uLong)0xffffffff, 4);
	else
		zip64local_putValue_inmemory(zi->ci.central_header + 42, (uLong)zi->ci.pos_local_header - zi->add_position_when_writing_offset, 4);

	for (i = 0; i < size_filename; i++)
		*(zi->ci.central_header + SIZECENTRALHEADER + i) = *(filename + i);

	for (i = 0; i < size_extrafield_global; i++)
		*(zi->ci.central_header + SIZECENTRALHEADER + size_filename + i) =
		*(((const char*)extrafield_global) + i);

	for (i = 0; i < size_comment; i++)
		*(zi->ci.central_header + SIZECENTRALHEADER + size_filename +
			size_extrafield_global + i) = *(comment + i);
	if (zi->ci.central_header == NULL)
		return ZIP_INTERNALERROR;

	zi->ci.zip64 = zip64;
	zi->ci.totalCompressedData = 0;
	zi->ci.totalUncompressedData = 0;
	zi->ci.pos_zip64extrainfo = 0;

	err = Write_LocalFileHeader(zi, filename, size_extrafield_local, extrafield_local);

#ifdef HAVE_BZIP2
	zi->ci.bstream.avail_in = (uInt)0;
	zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
	zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
	zi->ci.bstream.total_in_hi32 = 0;
	zi->ci.bstream.total_in_lo32 = 0;
	zi->ci.bstream.total_out_hi32 = 0;
	zi->ci.bstream.total_out_lo32 = 0;
#endif

	zi->ci.stream.avail_in = (uInt)0;
	zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
	zi->ci.stream.next_out = zi->ci.buffered_data;
	zi->ci.stream.total_in = 0;
	zi->ci.stream.total_out = 0;
	zi->ci.stream.data_type = Z_BINARY;

#ifdef HAVE_BZIP2
	if ((err == ZIP_OK) && (zi->ci.method == Z_DEFLATED || zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
#else
	if ((err == ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
#endif
	{
		if (zi->ci.method == Z_DEFLATED)
		{
			zi->ci.stream.zalloc = (alloc_func)0;
			zi->ci.stream.zfree = (free_func)0;
			zi->ci.stream.opaque = (voidpf)0;

			if (windowBits > 0)
				windowBits = -windowBits;

			err = deflateInit2(&zi->ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);

			if (err == Z_OK)
				zi->ci.stream_initialised = Z_DEFLATED;
		}
		else if (zi->ci.method == Z_BZIP2ED)
		{
#ifdef HAVE_BZIP2
			// Init BZip stuff here
			zi->ci.bstream.bzalloc = 0;
			zi->ci.bstream.bzfree = 0;
			zi->ci.bstream.opaque = (voidpf)0;

			err = BZ2_bzCompressInit(&zi->ci.bstream, level, 0, 35);
			if (err == BZ_OK)
				zi->ci.stream_initialised = Z_BZIP2ED;
#endif
		}

	}

#    ifndef NOCRYPT
	zi->ci.crypt_header_size = 0;
	if ((err == Z_OK) && (password != NULL))
	{
		unsigned char bufHead[RAND_HEAD_LEN];
		unsigned int sizeHead;
		zi->ci.encrypt = 1;
		zi->ci.pcrc_32_tab = get_crc_table();
		/*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/

		sizeHead = crypthead(password, bufHead, RAND_HEAD_LEN, zi->ci.keys, zi->ci.pcrc_32_tab, crcForCrypting);
		zi->ci.crypt_header_size = sizeHead;

		if (ZWRITE64(zi->z_filefunc, zi->filestream, bufHead, sizeHead) != sizeHead)
			err = ZIP_ERRNO;
	}
#    endif

	if (err == Z_OK)
		zi->in_opened_file_inzip = 1;
	return err;
}


extern int ZEXPORT zipOpenNewFileInZip4(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level, int raw,
	int windowBits, int memLevel, int strategy,
	const char* password, uLong crcForCrypting,
	uLong versionMadeBy, uLong flagBase)
{
	return zipOpenNewFileInZip4_64(file, filename, zipfi,
		extrafield_local, size_extrafield_local,
		extrafield_global, size_extrafield_global,
		comment, method, level, raw,
		windowBits, memLevel, strategy,
		password, crcForCrypting, versionMadeBy, flagBase, 0);
}

extern int ZEXPORT zipOpenNewFileInZip3(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level, int raw,
	int windowBits, int memLevel, int strategy,
	const char* password, uLong crcForCrypting)
{
	return zipOpenNewFileInZip4_64(file, filename, zipfi,
		extrafield_local, size_extrafield_local,
		extrafield_global, size_extrafield_global,
		comment, method, level, raw,
		windowBits, memLevel, strategy,
		password, crcForCrypting, VERSIONMADEBY, 0, 0);
}

extern int ZEXPORT zipOpenNewFileInZip3_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level, int raw,
	int windowBits, int memLevel, int strategy,
	const char* password, uLong crcForCrypting, int zip64)
{
	return zipOpenNewFileInZip4_64(file, filename, zipfi,
		extrafield_local, size_extrafield_local,
		extrafield_global, size_extrafield_global,
		comment, method, level, raw,
		windowBits, memLevel, strategy,
		password, crcForCrypting, VERSIONMADEBY, 0, zip64);
}

extern int ZEXPORT zipOpenNewFileInZip2(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level, int raw)
{
	return zipOpenNewFileInZip4_64(file, filename, zipfi,
		extrafield_local, size_extrafield_local,
		extrafield_global, size_extrafield_global,
		comment, method, level, raw,
		-MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
		NULL, 0, VERSIONMADEBY, 0, 0);
}

extern int ZEXPORT zipOpenNewFileInZip2_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level, int raw, int zip64)
{
	return zipOpenNewFileInZip4_64(file, filename, zipfi,
		extrafield_local, size_extrafield_local,
		extrafield_global, size_extrafield_global,
		comment, method, level, raw,
		-MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
		NULL, 0, VERSIONMADEBY, 0, zip64);
}

extern int ZEXPORT zipOpenNewFileInZip64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level, int zip64)
{
	return zipOpenNewFileInZip4_64(file, filename, zipfi,
		extrafield_local, size_extrafield_local,
		extrafield_global, size_extrafield_global,
		comment, method, level, 0,
		-MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
		NULL, 0, VERSIONMADEBY, 0, zip64);
}

extern int ZEXPORT zipOpenNewFileInZip(zipFile file, const char* filename, const zip_fileinfo* zipfi,
	const void* extrafield_local, uInt size_extrafield_local,
	const void* extrafield_global, uInt size_extrafield_global,
	const char* comment, int method, int level)
{
	return zipOpenNewFileInZip4_64(file, filename, zipfi,
		extrafield_local, size_extrafield_local,
		extrafield_global, size_extrafield_global,
		comment, method, level, 0,
		-MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
		NULL, 0, VERSIONMADEBY, 0, 0);
}

local int zip64FlushWriteBuffer(zip64_internal* zi)
{
	int err = ZIP_OK;

	if (zi->ci.encrypt != 0)
	{
#ifndef NOCRYPT
		uInt i;
		int t;
		for (i = 0; i < zi->ci.pos_in_buffered_data; i++)
			zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i], t);
#endif
	}

	if (ZWRITE64(zi->z_filefunc, zi->filestream, zi->ci.buffered_data, zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)
		err = ZIP_ERRNO;

	zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;

#ifdef HAVE_BZIP2
	if (zi->ci.method == Z_BZIP2ED)
	{
		zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;
		zi->ci.bstream.total_in_lo32 = 0;
		zi->ci.bstream.total_in_hi32 = 0;
	}
	else
#endif
	{
		zi->ci.totalUncompressedData += zi->ci.stream.total_in;
		zi->ci.stream.total_in = 0;
	}


	zi->ci.pos_in_buffered_data = 0;

	return err;
}

extern int ZEXPORT zipWriteInFileInZip(zipFile file, const void* buf, unsigned int len)
{
	zip64_internal* zi;
	int err = ZIP_OK;

	if (file == NULL)
		return ZIP_PARAMERROR;
	zi = (zip64_internal*)file;

	if (zi->in_opened_file_inzip == 0)
		return ZIP_PARAMERROR;

	zi->ci.crc32 = crc32(zi->ci.crc32, (const Bytef*)buf, (uInt)len);

#ifdef HAVE_BZIP2
	if (zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))
	{
		zi->ci.bstream.next_in = (void*)buf;
		zi->ci.bstream.avail_in = len;
		err = BZ_RUN_OK;

		while ((err == BZ_RUN_OK) && (zi->ci.bstream.avail_in > 0))
		{
			if (zi->ci.bstream.avail_out == 0)
			{
				if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
					err = ZIP_ERRNO;
				zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
				zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
			}


			if (err != BZ_RUN_OK)
				break;

			if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
			{
				uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;
				//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
				err = BZ2_bzCompress(&zi->ci.bstream, BZ_RUN);

				zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo);
			}
		}

		if (err == BZ_RUN_OK)
			err = ZIP_OK;
	}
	else
#endif
	{
		zi->ci.stream.next_in = (Bytef*)buf;
		zi->ci.stream.avail_in = len;

		while ((err == ZIP_OK) && (zi->ci.stream.avail_in > 0))
		{
			if (zi->ci.stream.avail_out == 0)
			{
				if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
					err = ZIP_ERRNO;
				zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
				zi->ci.stream.next_out = zi->ci.buffered_data;
			}


			if (err != ZIP_OK)
				break;

			if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
			{
				uLong uTotalOutBefore = zi->ci.stream.total_out;
				err = deflate(&zi->ci.stream, Z_NO_FLUSH);
				if (uTotalOutBefore > zi->ci.stream.total_out)
				{
					int bBreak = 0;
					bBreak++;
				}

				zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore);
			}
			else
			{
				uInt copy_this, i;
				if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
					copy_this = zi->ci.stream.avail_in;
				else
					copy_this = zi->ci.stream.avail_out;

				for (i = 0; i < copy_this; i++)
					*(((char*)zi->ci.stream.next_out) + i) =
					*(((const char*)zi->ci.stream.next_in) + i);
				{
					zi->ci.stream.avail_in -= copy_this;
					zi->ci.stream.avail_out -= copy_this;
					zi->ci.stream.next_in += copy_this;
					zi->ci.stream.next_out += copy_this;
					zi->ci.stream.total_in += copy_this;
					zi->ci.stream.total_out += copy_this;
					zi->ci.pos_in_buffered_data += copy_this;
				}
			}
		}// while(...)
	}

	return err;
}

extern int ZEXPORT zipCloseFileInZipRaw(zipFile file, uLong uncompressed_size, uLong crc32)
{
	return zipCloseFileInZipRaw64(file, uncompressed_size, crc32);
}

extern int ZEXPORT zipCloseFileInZipRaw64(zipFile file, ZPOS64_T uncompressed_size, uLong crc32)
{
	zip64_internal* zi;
	ZPOS64_T compressed_size;
	uLong invalidValue = 0xffffffff;
	short datasize = 0;
	int err = ZIP_OK;

	if (file == NULL)
		return ZIP_PARAMERROR;
	zi = (zip64_internal*)file;

	if (zi->in_opened_file_inzip == 0)
		return ZIP_PARAMERROR;
	zi->ci.stream.avail_in = 0;

	if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
	{
		while (err == ZIP_OK)
		{
			uLong uTotalOutBefore;
			if (zi->ci.stream.avail_out == 0)
			{
				if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
					err = ZIP_ERRNO;
				zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
				zi->ci.stream.next_out = zi->ci.buffered_data;
			}
			uTotalOutBefore = zi->ci.stream.total_out;
			err = deflate(&zi->ci.stream, Z_FINISH);
			zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore);
		}
	}
	else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
	{
#ifdef HAVE_BZIP2
		err = BZ_FINISH_OK;
		while (err == BZ_FINISH_OK)
		{
			uLong uTotalOutBefore;
			if (zi->ci.bstream.avail_out == 0)
			{
				if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
					err = ZIP_ERRNO;
				zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
				zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
			}
			uTotalOutBefore = zi->ci.bstream.total_out_lo32;
			err = BZ2_bzCompress(&zi->ci.bstream, BZ_FINISH);
			if (err == BZ_STREAM_END)
				err = Z_STREAM_END;

			zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);
		}

		if (err == BZ_FINISH_OK)
			err = ZIP_OK;
#endif
	}

	if (err == Z_STREAM_END)
		err = ZIP_OK; /* this is normal */

	if ((zi->ci.pos_in_buffered_data > 0) && (err == ZIP_OK))
	{
		if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
			err = ZIP_ERRNO;
	}

	if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
	{
		int tmp_err = deflateEnd(&zi->ci.stream);
		if (err == ZIP_OK)
			err = tmp_err;
		zi->ci.stream_initialised = 0;
	}
#ifdef HAVE_BZIP2
	else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
	{
		int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);
		if (err == ZIP_OK)
			err = tmperr;
		zi->ci.stream_initialised = 0;
	}
#endif

	if (!zi->ci.raw)
	{
		crc32 = (uLong)zi->ci.crc32;
		uncompressed_size = zi->ci.totalUncompressedData;
	}
	compressed_size = zi->ci.totalCompressedData;

#    ifndef NOCRYPT
	compressed_size += zi->ci.crypt_header_size;
#    endif

	// update Current Item crc and sizes,
	if (compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)
	{
		/*version Made by*/
		zip64local_putValue_inmemory(zi->ci.central_header + 4, (uLong)45, 2);
		/*version needed*/
		zip64local_putValue_inmemory(zi->ci.central_header + 6, (uLong)45, 2);

	}

	zip64local_putValue_inmemory(zi->ci.central_header + 16, crc32, 4); /*crc*/


	if (compressed_size >= 0xffffffff)
		zip64local_putValue_inmemory(zi->ci.central_header + 20, invalidValue, 4); /*compr size*/
	else
		zip64local_putValue_inmemory(zi->ci.central_header + 20, compressed_size, 4); /*compr size*/

	  /// set internal file attributes field
	if (zi->ci.stream.data_type == Z_ASCII)
		zip64local_putValue_inmemory(zi->ci.central_header + 36, (uLong)Z_ASCII, 2);

	if (uncompressed_size >= 0xffffffff)
		zip64local_putValue_inmemory(zi->ci.central_header + 24, invalidValue, 4); /*uncompr size*/
	else
		zip64local_putValue_inmemory(zi->ci.central_header + 24, uncompressed_size, 4); /*uncompr size*/

	  // Add ZIP64 extra info field for uncompressed size
	if (uncompressed_size >= 0xffffffff)
		datasize += 8;

	// Add ZIP64 extra info field for compressed size
	if (compressed_size >= 0xffffffff)
		datasize += 8;

	// Add ZIP64 extra info field for relative offset to local file header of current file
	if (zi->ci.pos_local_header >= 0xffffffff)
		datasize += 8;

	if (datasize > 0)
	{
		char* p = NULL;

		if ((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)
		{
			// we can not write more data to the buffer that we have room for.
			return ZIP_BADZIPFILE;
		}

		p = zi->ci.central_header + zi->ci.size_centralheader;

		// Add Extra Information Header for 'ZIP64 information'
		zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID
		p += 2;
		zip64local_putValue_inmemory(p, datasize, 2); // DataSize
		p += 2;

		if (uncompressed_size >= 0xffffffff)
		{
			zip64local_putValue_inmemory(p, uncompressed_size, 8);
			p += 8;
		}

		if (compressed_size >= 0xffffffff)
		{
			zip64local_putValue_inmemory(p, compressed_size, 8);
			p += 8;
		}

		if (zi->ci.pos_local_header >= 0xffffffff)
		{
			zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);
			p += 8;
		}

		// Update how much extra free space we got in the memory buffer
		// and increase the centralheader size so the new ZIP64 fields are included
		// ( 4 below is the size of HeaderID and DataSize field )
		zi->ci.size_centralExtraFree -= datasize + 4;
		zi->ci.size_centralheader += datasize + 4;

		// Update the extra info size field
		zi->ci.size_centralExtra += datasize + 4;
		zip64local_putValue_inmemory(zi->ci.central_header + 30, (uLong)zi->ci.size_centralExtra, 2);
	}

	if (err == ZIP_OK)
		err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);

	free(zi->ci.central_header);

	if (err == ZIP_OK)
	{
		// Update the LocalFileHeader with the new values.

		ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc, zi->filestream);

		if (ZSEEK64(zi->z_filefunc, zi->filestream, zi->ci.pos_local_header + 14, ZLIB_FILEFUNC_SEEK_SET) != 0)
			err = ZIP_ERRNO;

		if (err == ZIP_OK)
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, crc32, 4); /* crc 32, unknown */

		if (uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff)
		{
			if (zi->ci.pos_zip64extrainfo > 0)
			{
				// Update the size in the ZIP64 extended field.
				if (ZSEEK64(zi->z_filefunc, zi->filestream, zi->ci.pos_zip64extrainfo + 4, ZLIB_FILEFUNC_SEEK_SET) != 0)
					err = ZIP_ERRNO;

				if (err == ZIP_OK) /* compressed size, unknown */
					err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);

				if (err == ZIP_OK) /* uncompressed size, unknown */
					err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);
			}
			else
				err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal
		}
		else
		{
			if (err == ZIP_OK) /* compressed size, unknown */
				err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 4);

			if (err == ZIP_OK) /* uncompressed size, unknown */
				err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 4);
		}

		if (ZSEEK64(zi->z_filefunc, zi->filestream, cur_pos_inzip, ZLIB_FILEFUNC_SEEK_SET) != 0)
			err = ZIP_ERRNO;
	}

	zi->number_entry++;
	zi->in_opened_file_inzip = 0;

	return err;
}

extern int ZEXPORT zipCloseFileInZip(zipFile file)
{
	return zipCloseFileInZipRaw(file, 0, 0);
}

int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)
{
	int err = ZIP_OK;
	ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writing_offset;

	err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)ZIP64ENDLOCHEADERMAGIC, 4);

	/*num disks*/
	if (err == ZIP_OK) /* number of the disk with the start of the central directory */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4);

	/*relative offset*/
	if (err == ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, pos, 8);

	/*total disks*/ /* Do not support spawning of disk so always say 1 here*/
	if (err == ZIP_OK) /* number of the disk with the start of the central directory */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)1, 4);

	return err;
}

int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
{
	int err = ZIP_OK;

	uLong Zip64DataSize = 44;

	err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)ZIP64ENDHEADERMAGIC, 4);

	if (err == ZIP_OK) /* size of this 'zip64 end of central directory' */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)Zip64DataSize, 8); // why ZPOS64_T of this ?

	if (err == ZIP_OK) /* version made by */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)45, 2);

	if (err == ZIP_OK) /* version needed */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)45, 2);

	if (err == ZIP_OK) /* number of this disk */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4);

	if (err == ZIP_OK) /* number of the disk with the start of the central directory */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4);

	if (err == ZIP_OK) /* total number of entries in the central dir on this disk */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

	if (err == ZIP_OK) /* total number of entries in the central dir */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

	if (err == ZIP_OK) /* size of the central directory */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)size_centraldir, 8);

	if (err == ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
	{
		ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)pos, 8);
	}
	return err;
}
int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
{
	int err = ZIP_OK;

	/*signature*/
	err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)ENDHEADERMAGIC, 4);

	if (err == ZIP_OK) /* number of this disk */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 2);

	if (err == ZIP_OK) /* number of the disk with the start of the central directory */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 2);

	if (err == ZIP_OK) /* total number of entries in the central dir on this disk */
	{
		{
			if (zi->number_entry >= 0xFFFF)
				err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xffff, 2); // use value in ZIP64 record
			else
				err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_entry, 2);
		}
	}

	if (err == ZIP_OK) /* total number of entries in the central dir */
	{
		if (zi->number_entry >= 0xFFFF)
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xffff, 2); // use value in ZIP64 record
		else
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_entry, 2);
	}

	if (err == ZIP_OK) /* size of the central directory */
		err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_centraldir, 4);

	if (err == ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
	{
		ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
		if (pos >= 0xffffffff)
		{
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xffffffff, 4);
		}
		else
			err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writing_offset), 4);
	}

	return err;
}

int Write_GlobalComment(zip64_internal* zi, const char* global_comment)
{
	int err = ZIP_OK;
	uInt size_global_comment = 0;

	if (global_comment != NULL)
		size_global_comment = (uInt)strlen(global_comment);

	err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_global_comment, 2);

	if (err == ZIP_OK && size_global_comment > 0)
	{
		if (ZWRITE64(zi->z_filefunc, zi->filestream, global_comment, size_global_comment) != size_global_comment)
			err = ZIP_ERRNO;
	}
	return err;
}

extern int ZEXPORT zipClose(zipFile file, const char* global_comment)
{
	zip64_internal* zi;
	int err = 0;
	uLong size_centraldir = 0;
	ZPOS64_T centraldir_pos_inzip;
	ZPOS64_T pos;

	if (file == NULL)
		return ZIP_PARAMERROR;

	zi = (zip64_internal*)file;

	if (zi->in_opened_file_inzip == 1)
	{
		err = zipCloseFileInZip(file);
	}

#ifndef NO_ADDFILEINEXISTINGZIP
	if (global_comment == NULL)
		global_comment = zi->globalcomment;
#endif

	centraldir_pos_inzip = ZTELL64(zi->z_filefunc, zi->filestream);

	if (err == ZIP_OK)
	{
		linkedlist_datablock_internal* ldi = zi->central_dir.first_block;
		while (ldi != NULL)
		{
			if ((err == ZIP_OK) && (ldi->filled_in_this_block > 0))
			{
				if (ZWRITE64(zi->z_filefunc, zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)
					err = ZIP_ERRNO;
			}

			size_centraldir += ldi->filled_in_this_block;
			ldi = ldi->next_datablock;
		}
	}
	free_linkedlist(&(zi->central_dir));

	pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
	if (pos >= 0xffffffff || zi->number_entry > 0xFFFF)
	{
		ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc, zi->filestream);
		Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

		Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);
	}

	if (err == ZIP_OK)
		err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

	if (err == ZIP_OK)
		err = Write_GlobalComment(zi, global_comment);

	if (ZCLOSE64(zi->z_filefunc, zi->filestream) != 0)
		if (err == ZIP_OK)
			err = ZIP_ERRNO;

#ifndef NO_ADDFILEINEXISTINGZIP
	TRYFREE(zi->globalcomment);
#endif
	TRYFREE(zi);

	return err;
}

extern int ZEXPORT zipRemoveExtraInfoBlock(char* pData, int* dataLen, short sHeader)
{
	char* p = pData;
	int size = 0;
	char* pNewHeader;
	char* pTmp;
	short header;
	short dataSize;

	int retVal = ZIP_OK;

	if (pData == NULL || *dataLen < 4)
		return ZIP_PARAMERROR;

	pNewHeader = (char*)ALLOC(*dataLen);
	pTmp = pNewHeader;

	while (p < (pData + *dataLen))
	{
		header = *(short*)p;
		dataSize = *(((short*)p) + 1);

		if (header == sHeader) // Header found.
		{
			p += dataSize + 4; // skip it. do not copy to temp buffer
		}
		else
		{
			// Extra Info block should not be removed, So copy it to the temp buffer.
			memcpy(pTmp, p, dataSize + 4);
			p += dataSize + 4;
			size += dataSize + 4;
		}

	}

	if (size < *dataLen)
	{
		// clean old extra info block.
		memset(pData, 0, *dataLen);

		// copy the new extra info block over the old
		if (size > 0)
			memcpy(pData, pNewHeader, size);

		// set the new extra info size
		*dataLen = size;

		retVal = ZIP_OK;
	}
	else
		retVal = ZIP_ERRNO;

	TRYFREE(pNewHeader);

	return retVal;
}















































/* ioapi.h -- IO base function header for compress/uncompress .zip
   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )

		 Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )

		 Modifications for Zip64 support
		 Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )

		 For more info read MiniZip_info.txt

*/

#if defined(_WIN32) && (!(defined(_CRT_SECURE_NO_WARNINGS)))
#define _CRT_SECURE_NO_WARNINGS
#endif

#if defined(__APPLE__) || defined(IOAPI_NO_64)
// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
#define FTELLO_FUNC(stream) ftello(stream)
#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
#else
#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
#define FTELLO_FUNC(stream) ftello64(stream)
#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
#endif


//#include "ioapi.h"

voidpf call_zopen64(const zlib_filefunc64_32_def* pfilefunc, const void* filename, int mode)
{
	if (pfilefunc->zfile_func64.zopen64_file != NULL)
		return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque, filename, mode);
	else
	{
		return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque, (const char*)filename, mode);
	}
}

long call_zseek64(const zlib_filefunc64_32_def* pfilefunc, voidpf filestream, ZPOS64_T offset, int origin)
{
	if (pfilefunc->zfile_func64.zseek64_file != NULL)
		return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque, filestream, offset, origin);
	else
	{
		uLong offsetTruncated = (uLong)offset;
		if (offsetTruncated != offset)
			return -1;
		else
			return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque, filestream, offsetTruncated, origin);
	}
}

ZPOS64_T call_ztell64(const zlib_filefunc64_32_def* pfilefunc, voidpf filestream)
{
	if (pfilefunc->zfile_func64.zseek64_file != NULL)
		return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque, filestream);
	else
	{
		uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque, filestream);
		if ((tell_uLong) == MAXU32)
			return (ZPOS64_T)-1;
		else
			return tell_uLong;
	}
}

void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32, const zlib_filefunc_def* p_filefunc32)
{
	p_filefunc64_32->zfile_func64.zopen64_file = NULL;
	p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
	p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
	p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;
	p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;
	p_filefunc64_32->zfile_func64.ztell64_file = NULL;
	p_filefunc64_32->zfile_func64.zseek64_file = NULL;
	p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;
	p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
	p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;
	p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
	p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
}



static voidpf  ZCALLBACK fopen_file_func OF((voidpf opaque, const char* filename, int mode));
static uLong   ZCALLBACK fread_file_func OF((voidpf opaque, voidpf stream, void* buf, uLong size));
static uLong   ZCALLBACK fwrite_file_func OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
static ZPOS64_T ZCALLBACK ftell64_file_func OF((voidpf opaque, voidpf stream));
static long    ZCALLBACK fseek64_file_func OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
static int     ZCALLBACK fclose_file_func OF((voidpf opaque, voidpf stream));
static int     ZCALLBACK ferror_file_func OF((voidpf opaque, voidpf stream));

static voidpf ZCALLBACK fopen_file_func(voidpf opaque, const char* filename, int mode)
{
	FILE* file = NULL;
	const char* mode_fopen = NULL;
	if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER) == ZLIB_FILEFUNC_MODE_READ)
		mode_fopen = "rb";
	else
		if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
			mode_fopen = "r+b";
		else
			if (mode & ZLIB_FILEFUNC_MODE_CREATE)
				mode_fopen = "wb";

	if ((filename != NULL) && (mode_fopen != NULL))
		file = fopen(filename, mode_fopen);
	return file;
}

static voidpf ZCALLBACK fopen64_file_func(voidpf opaque, const void* filename, int mode)
{
	FILE* file = NULL;
	const char* mode_fopen = NULL;
	if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER) == ZLIB_FILEFUNC_MODE_READ)
		mode_fopen = "rb";
	else
		if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
			mode_fopen = "r+b";
		else
			if (mode & ZLIB_FILEFUNC_MODE_CREATE)
				mode_fopen = "wb";

	if ((filename != NULL) && (mode_fopen != NULL))
		file = FOPEN_FUNC((const char*)filename, mode_fopen);
	return file;
}


static uLong ZCALLBACK fread_file_func(voidpf opaque, voidpf stream, void* buf, uLong size)
{
	uLong ret;
	ret = (uLong)fread(buf, 1, (size_t)size, (FILE*)stream);
	return ret;
}

static uLong ZCALLBACK fwrite_file_func(voidpf opaque, voidpf stream, const void* buf, uLong size)
{
	uLong ret;
	ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE*)stream);
	return ret;
}

static long ZCALLBACK ftell_file_func(voidpf opaque, voidpf stream)
{
	long ret;
	ret = ftell((FILE*)stream);
	return ret;
}


static ZPOS64_T ZCALLBACK ftell64_file_func(voidpf opaque, voidpf stream)
{
	ZPOS64_T ret;
	ret = FTELLO_FUNC((FILE*)stream);
	return ret;
}

static long ZCALLBACK fseek_file_func(voidpf  opaque, voidpf stream, uLong offset, int origin)
{
	int fseek_origin = 0;
	long ret;
	switch (origin)
	{
	case ZLIB_FILEFUNC_SEEK_CUR:
		fseek_origin = SEEK_CUR;
		break;
	case ZLIB_FILEFUNC_SEEK_END:
		fseek_origin = SEEK_END;
		break;
	case ZLIB_FILEFUNC_SEEK_SET:
		fseek_origin = SEEK_SET;
		break;
	default: return -1;
	}
	ret = 0;
	if (fseek((FILE*)stream, offset, fseek_origin) != 0)
		ret = -1;
	return ret;
}

static long ZCALLBACK fseek64_file_func(voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)
{
	int fseek_origin = 0;
	long ret;
	switch (origin)
	{
	case ZLIB_FILEFUNC_SEEK_CUR:
		fseek_origin = SEEK_CUR;
		break;
	case ZLIB_FILEFUNC_SEEK_END:
		fseek_origin = SEEK_END;
		break;
	case ZLIB_FILEFUNC_SEEK_SET:
		fseek_origin = SEEK_SET;
		break;
	default: return -1;
	}
	ret = 0;

	if (FSEEKO_FUNC((FILE*)stream, offset, fseek_origin) != 0)
		ret = -1;

	return ret;
}


static int ZCALLBACK fclose_file_func(voidpf opaque, voidpf stream)
{
	int ret;
	ret = fclose((FILE*)stream);
	return ret;
}

static int ZCALLBACK ferror_file_func(voidpf opaque, voidpf stream)
{
	int ret;
	ret = ferror((FILE*)stream);
	return ret;
}

void fill_fopen_filefunc(zlib_filefunc_def* pzlib_filefunc_def)
{
	pzlib_filefunc_def->zopen_file = fopen_file_func;
	pzlib_filefunc_def->zread_file = fread_file_func;
	pzlib_filefunc_def->zwrite_file = fwrite_file_func;
	pzlib_filefunc_def->ztell_file = ftell_file_func;
	pzlib_filefunc_def->zseek_file = fseek_file_func;
	pzlib_filefunc_def->zclose_file = fclose_file_func;
	pzlib_filefunc_def->zerror_file = ferror_file_func;
	pzlib_filefunc_def->opaque = NULL;
}

void fill_fopen64_filefunc(zlib_filefunc64_def* pzlib_filefunc_def)
{
	pzlib_filefunc_def->zopen64_file = fopen64_file_func;
	pzlib_filefunc_def->zread_file = fread_file_func;
	pzlib_filefunc_def->zwrite_file = fwrite_file_func;
	pzlib_filefunc_def->ztell64_file = ftell64_file_func;
	pzlib_filefunc_def->zseek64_file = fseek64_file_func;
	pzlib_filefunc_def->zclose_file = fclose_file_func;
	pzlib_filefunc_def->zerror_file = ferror_file_func;
	pzlib_filefunc_def->opaque = NULL;
}










/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

 /* WARNING: this file should *not* be used by applications. It is
	part of the implementation of the compression library and is
	subject to change. Applications should only use zlib.h.
  */

  /* @(#) $Id$ */

#ifndef ZUTIL_H
#define ZUTIL_H

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#if defined(STDC) && !defined(Z_SOLO)
#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
#    include <stddef.h>
#  endif
#  include <string.h>
#  include <stdlib.h>
#endif

#ifdef Z_SOLO
typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
#endif

#ifndef local
#  define local static
#endif
/* since "static" is used to mean two completely different things in C, we
   define "local" for the non-static meaning of "static", for readability
   (compile with -Dlocal if your debugger can't find static symbols) */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern z_const char* const z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

		/* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

		/* target dependencies */

#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
#  define OS_CODE  0x00
#  ifndef Z_SOLO
#    if defined(__TURBOC__) || defined(__BORLANDC__)
#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
		 /* Allow compilation with ANSI keywords only enabled */
void _Cdecl farfree(void* block);
void* _Cdecl farmalloc(unsigned long nbytes);
#      else
#        include <alloc.h>
#      endif
#    else /* MSC or DJGPP */
#      include <malloc.h>
#    endif
#  endif
#endif

#ifdef AMIGA
#  define OS_CODE  1
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  2
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef __370__
#  if __TARGET_LIB__ < 0x20000000
#    define OS_CODE 4
#  elif __TARGET_LIB__ < 0x40000000
#    define OS_CODE 11
#  else
#    define OS_CODE 8
#  endif
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  5
#endif

#ifdef OS2
#  define OS_CODE  6
#  if defined(M_I86) && !defined(Z_SOLO)
#    include <malloc.h>
#  endif
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  7
#  ifndef Z_SOLO
#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#      include <unix.h> /* for fdopen */
#    else
#      ifndef fdopen
#        define fdopen(fd,mode) NULL /* No fdopen() */
#      endif
#    endif
#  endif
#endif

#ifdef __acorn
#  define OS_CODE 13
#endif

#if defined(WIN32) && !defined(__CYGWIN__)
#  define OS_CODE  10
#endif

#ifdef _BEOS_
#  define OS_CODE  16
#endif

#ifdef __TOS_OS400__
#  define OS_CODE 18
#endif

#ifdef __APPLE__
#  define OS_CODE 19
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
#  if defined(_WIN32_WCE)
#    define fdopen(fd,mode) NULL /* No fdopen() */
#    ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#      define _PTRDIFF_T_DEFINED
#    endif
#  else
#    define fdopen(fd,type)  _fdopen(fd,type)
#  endif
#endif

#if defined(__BORLANDC__) && !defined(MSDOS)
#pragma warn -8004
#pragma warn -8008
#pragma warn -8066
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_WIN32) && \
    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#endif

/* common defaults */

#ifndef OS_CODE
#  define OS_CODE  3     /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

		 /* functions */

#if defined(pyr) || defined(Z_SOLO)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef ZLIB_DEBUG
#  include <stdio.h>
extern int ZLIB_INTERNAL z_verbose;
extern void ZLIB_INTERNAL z_error OF((char* m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif

#ifndef Z_SOLO
voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
	unsigned size));
void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
#endif

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

/* Reverse the bytes in a 32-bit value */
#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))

#endif /* ZUTIL_H */


/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2017 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

 /* @(#) $Id$ */

//#include "zutil.h"
#ifndef Z_SOLO
/* gzguts.h -- zlib internal header definitions for gz* operations
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#ifdef _LARGEFILE64_SOURCE
#  ifndef _LARGEFILE_SOURCE
#    define _LARGEFILE_SOURCE 1
#  endif
#  ifdef _FILE_OFFSET_BITS
#    undef _FILE_OFFSET_BITS
#  endif
#endif

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include <stdio.h>
#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#  include <limits.h>
#endif

#ifndef _POSIX_SOURCE
#  define _POSIX_SOURCE
#endif
#include <fcntl.h>

#ifdef _WIN32
#  include <stddef.h>
#endif

#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
#  include <io.h>
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#  define WIDECHAR
#endif

#ifdef WINAPI_FAMILY
#  define open _open
#  define read _read
#  define write _write
#  define close _close
#endif

#ifdef NO_DEFLATE       /* for compatibility with old definition */
#  define NO_GZCOMPRESS
#endif

#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(__CYGWIN__)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#ifndef HAVE_VSNPRINTF
#  ifdef MSDOS
 /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
	but for now we just assume it doesn't. */
#    define NO_vsnprintf
#  endif
#  ifdef __TURBOC__
#    define NO_vsnprintf
#  endif
#  ifdef WIN32
	/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
#         define vsnprintf _vsnprintf
#      endif
#    endif
#  endif
#  ifdef __SASC
#    define NO_vsnprintf
#  endif
#  ifdef VMS
#    define NO_vsnprintf
#  endif
#  ifdef __OS400__
#    define NO_vsnprintf
#  endif
#  ifdef __MVS__
#    define NO_vsnprintf
#  endif
#endif

/* unlike snprintf (which is required in C99), _snprintf does not guarantee
   null termination of the result -- however this is only used in gzlib.c where
   the result is assured to fit in the space provided */
#if defined(_MSC_VER) && _MSC_VER < 1900
#  define snprintf _snprintf
#endif

#ifndef local
#  define local static
#endif
   /* since "static" is used to mean two completely different things in C, we
	  define "local" for the non-static meaning of "static", for readability
	  (compile with -Dlocal if your debugger can't find static symbols) */

	  /* gz* functions always use library allocation functions */
#ifndef STDC
extern voidp  malloc OF((uInt size));
extern void   free   OF((voidpf ptr));
#endif

/* get errno and strerror definition */
#if defined UNDER_CE
#  include <windows.h>
#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
#else
#  ifndef NO_STRERROR
#    include <errno.h>
#    define zstrerror() strerror(errno)
#  else
#    define zstrerror() "stdio error (consult errno)"
#  endif
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
ZEXTERN gzFile ZEXPORT gzopen64 OF((const char*, const char*));
ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
#endif

/* default memLevel */
#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif

/* default i/o buffer size -- double this for output when reading (this and
   twice this must be able to fit in an unsigned type) */
#define GZBUFSIZE 8192

   /* gzip modes, also provide a little integrity check on the passed structure */
#define GZ_NONE 0
#define GZ_READ 7247
#define GZ_WRITE 31153
#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */

/* values for gz_state how */
#define LOOK 0      /* look for a gzip header */
#define COPY 1      /* copy input directly */
#define GZIP 2      /* decompress a gzip stream */

/* internal gzip file state data structure */
typedef struct {
	/* exposed contents for gzgetc() macro */
	struct gzFile_s x;      /* "x" for exposed */
							/* x.have: number of bytes available at x.next */
							/* x.next: next output data to deliver or write */
							/* x.pos: current position in uncompressed data */
		/* used for both reading and writing */
	int mode;               /* see gzip modes above */
	int fd;                 /* file descriptor */
	char* path;             /* path or fd for error messages */
	unsigned size;          /* buffer size, zero if not allocated yet */
	unsigned want;          /* requested buffer size, default is GZBUFSIZE */
	unsigned char* in;      /* input buffer (double-sized when writing) */
	unsigned char* out;     /* output buffer (double-sized when reading) */
	int direct;             /* 0 if processing gzip, 1 if transparent */
		/* just for reading */
	int how;                /* 0: get header, 1: copy, 2: decompress */
	z_off64_t start;        /* where the gzip data started, for rewinding */
	int eof;                /* true if end of input file reached */
	int past;               /* true if read requested past end */
		/* just for writing */
	int level;              /* compression level */
	int strategy;           /* compression strategy */
		/* seek request */
	z_off64_t skip;         /* amount to skip (already rewound if backwards) */
	int seek;               /* true if seek request pending */
		/* error information */
	int err;                /* error code */
	char* msg;              /* error message */
		/* zlib inflate or deflate stream */
	z_stream strm;          /* stream structure in-place (not a pointer) */
} gz_state;
typedef gz_state FAR* gz_statep;

/* shared functions */
void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char*));
#if defined UNDER_CE
char ZLIB_INTERNAL* gz_strwinerror OF((DWORD error));
#endif

/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
   value -- needed when comparing unsigned to z_off64_t, which is signed
   (possible z_off64_t types off_t, off64_t, and long are all signed) */
#ifdef INT_MAX
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
#else
unsigned ZLIB_INTERNAL gz_intmax OF((void));
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
#endif











/* gzlib.c -- zlib functions common to reading and writing gzip files
 * Copyright (C) 2004-2017 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#if defined(_WIN32) && !defined(__BORLANDC__) && !defined(__MINGW32__)
#  define LSEEK _lseeki64
#else
#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
#  define LSEEK lseek64
#else
#  define LSEEK lseek
#endif
#endif

 /* Local functions */
local void gz_reset OF((gz_statep));
local gzFile gz_open OF((const void*, int, const char*));

#if defined UNDER_CE

/* Map the Windows error number in ERROR to a locale-dependent error message
   string and return a pointer to it.  Typically, the values for ERROR come
   from GetLastError.

   The string pointed to shall not be modified by the application, but may be
   overwritten by a subsequent call to gz_strwinerror

   The gz_strwinerror function does not change the current setting of
   GetLastError. */
char ZLIB_INTERNAL* gz_strwinerror(error)
DWORD error;
{
	static char buf[1024];

	wchar_t* msgbuf;
	DWORD lasterr = GetLastError();
	DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
		| FORMAT_MESSAGE_ALLOCATE_BUFFER,
		NULL,
		error,
		0, /* Default language */
		(LPVOID)&msgbuf,
		0,
		NULL);
	if (chars != 0) {
		/* If there is an \r\n appended, zap it.  */
		if (chars >= 2
			&& msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
			chars -= 2;
			msgbuf[chars] = 0;
		}

		if (chars > sizeof(buf) - 1) {
			chars = sizeof(buf) - 1;
			msgbuf[chars] = 0;
		}

		wcstombs(buf, msgbuf, chars + 1);
		LocalFree(msgbuf);
	}
	else {
		sprintf(buf, "unknown win32 error (%ld)", error);
	}

	SetLastError(lasterr);
	return buf;
}

#endif /* UNDER_CE */

/* Reset gzip file state */
local void gz_reset(gz_statep state)
{
	state->x.have = 0;              /* no output data available */
	if (state->mode == GZ_READ) {   /* for reading ... */
		state->eof = 0;             /* not at end of file */
		state->past = 0;            /* have not read past end yet */
		state->how = LOOK;          /* look for gzip header */
	}
	state->seek = 0;                /* no seek request pending */
	gz_error(state, Z_OK, NULL);    /* clear error */
	state->x.pos = 0;               /* no uncompressed data yet */
	state->strm.avail_in = 0;       /* no input data yet */
}

/* Open a gzip file either by name or file descriptor. */
local gzFile gz_open(const void* path, int fd, const char* mode)
{
	gz_statep state;
	z_size_t len;
	int oflag;
#ifdef O_CLOEXEC
	int cloexec = 0;
#endif
#ifdef O_EXCL
	int exclusive = 0;
#endif

	/* check input */
	if (path == NULL)
		return NULL;

	/* allocate gzFile structure to return */
	state = (gz_statep)malloc(sizeof(gz_state));
	if (state == NULL)
		return NULL;
	state->size = 0;            /* no buffers allocated yet */
	state->want = GZBUFSIZE;    /* requested buffer size */
	state->msg = NULL;          /* no error message yet */

	/* interpret mode */
	state->mode = GZ_NONE;
	state->level = Z_DEFAULT_COMPRESSION;
	state->strategy = Z_DEFAULT_STRATEGY;
	state->direct = 0;
	while (*mode) {
		if (*mode >= '0' && *mode <= '9')
			state->level = *mode - '0';
		else
			switch (*mode) {
			case 'r':
				state->mode = GZ_READ;
				break;
#ifndef NO_GZCOMPRESS
			case 'w':
				state->mode = GZ_WRITE;
				break;
			case 'a':
				state->mode = GZ_APPEND;
				break;
#endif
			case '+':       /* can't read and write at the same zl_TIME */
				free(state);
				return NULL;
			case 'b':       /* ignore -- will request binary anyway */
				break;
#ifdef O_CLOEXEC
			case 'e':
				cloexec = 1;
				break;
#endif
#ifdef O_EXCL
			case 'x':
				exclusive = 1;
				break;
#endif
			case 'f':
				state->strategy = Z_FILTERED;
				break;
			case 'h':
				state->strategy = Z_HUFFMAN_ONLY;
				break;
			case 'R':
				state->strategy = Z_RLE;
				break;
			case 'F':
				state->strategy = Z_FIXED;
				break;
			case 'T':
				state->direct = 1;
				break;
			default:        /* could consider as an error, but just ignore */
				;
			}
		mode++;
	}

	/* must provide an "r", "w", or "a" */
	if (state->mode == GZ_NONE) {
		free(state);
		return NULL;
	}

	/* can't force transparent read */
	if (state->mode == GZ_READ) {
		if (state->direct) {
			free(state);
			return NULL;
		}
		state->direct = 1;      /* for empty file */
	}

	/* save the path name for error messages */
#ifdef WIDECHAR
	if (fd == -2) {
		len = wcstombs(NULL, (const wchar_t*)path, 0);
		if (len == (z_size_t)-1)
			len = 0;
	}
	else
#endif
		len = strlen((const char*)path);
	state->path = (char*)malloc(len + 1);
	if (state->path == NULL) {
		free(state);
		return NULL;
	}
#ifdef WIDECHAR
	if (fd == -2)
		if (len)
			wcstombs(state->path, (const wchar_t*)path, len + 1);
		else
			*(state->path) = 0;
	else
#endif
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
		(void)snprintf(state->path, len + 1, "%s", (const char*)path);
#else
		strcpy(state->path, path);
#endif

	/* compute the zl_FLAGS for open() */
	oflag =
#ifdef O_LARGEFILE
		O_LARGEFILE |
#endif
#ifdef O_BINARY
		O_BINARY |
#endif
#ifdef O_CLOEXEC
		(cloexec ? O_CLOEXEC : 0) |
#endif
		(state->mode == GZ_READ ?
			O_RDONLY :
			(O_WRONLY | O_CREAT |
#ifdef O_EXCL
			(exclusive ? O_EXCL : 0) |
#endif
				(state->mode == GZ_WRITE ?
					O_TRUNC :
					O_APPEND)));

	/* open the file with the appropriate zl_FLAGS (or just use fd) */
	state->fd = fd > -1 ? fd : (
#ifdef WIDECHAR
		fd == -2 ? _wopen((const wchar_t*)path, oflag, 0666) :
#endif
		_open((const char*)path, oflag, 0666)); // was: open(
	if (state->fd == -1) {
		free(state->path);
		free(state);
		return NULL;
	}
	if (state->mode == GZ_APPEND) {
		LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */
		state->mode = GZ_WRITE;         /* simplify later checks */
	}

	/* save the current position for rewinding (only if reading) */
	if (state->mode == GZ_READ) {
		state->start = LSEEK(state->fd, 0, SEEK_CUR);
		if (state->start == -1) state->start = 0;
	}

	/* initialize stream */
	gz_reset(state);

	/* return stream */
	return (gzFile)state;
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen(const char* path, const char* mode)
{
	return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen64(const char* path, const char* mode)
{
	return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzdopen(int fd, const char* mode)
{
	char* path;         /* identifier for error messages */
	gzFile gz;

	if (fd == -1 || (path = (char*)malloc(7 + 3 * sizeof(int))) == NULL)
		return NULL;
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
	(void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);
#else
	sprintf(path, "<fd:%d>", fd);   /* for debugging */
#endif
	gz = gz_open(path, fd, mode);
	free(path);
	return gz;
}

/* -- see zlib.h -- */
#ifdef WIDECHAR
gzFile ZEXPORT gzopen_w(const wchar_t* path, const char* mode)
{
	return gz_open(path, -2, mode);
}
#endif

/* -- see zlib.h -- */
int ZEXPORT gzbuffer(gzFile file, unsigned size)
{
	gz_statep state;

	/* get internal structure and check integrity */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;
	if (state->mode != GZ_READ && state->mode != GZ_WRITE)
		return -1;

	/* make sure we haven't already allocated memory */
	if (state->size != 0)
		return -1;

	/* check and set requested size */
	if ((size << 1) < size)
		return -1;              /* need to be able to double it */
	if (size < 2)
		size = 2;               /* need two bytes to check magic header */
	state->want = size;
	return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzrewind(gzFile file)
{
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;

	/* check that we're reading and that there's no error */
	if (state->mode != GZ_READ ||
		(state->err != Z_OK && state->err != Z_BUF_ERROR))
		return -1;

	/* back up and start over */
	if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
		return -1;
	gz_reset(state);
	return 0;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzseek64(gzFile file, z_off64_t offset, int whence)
{
	unsigned n;
	z_off64_t ret;
	gz_statep state;

	/* get internal structure and check integrity */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;
	if (state->mode != GZ_READ && state->mode != GZ_WRITE)
		return -1;

	/* check that there's no error */
	if (state->err != Z_OK && state->err != Z_BUF_ERROR)
		return -1;

	/* can only seek from start or relative to current position */
	if (whence != SEEK_SET && whence != SEEK_CUR)
		return -1;

	/* normalize offset to a SEEK_CUR specification */
	if (whence == SEEK_SET)
		offset -= state->x.pos;
	else if (state->seek)
		offset += state->skip;
	state->seek = 0;

	/* if within raw area while reading, just go there */
	if (state->mode == GZ_READ && state->how == COPY &&
		state->x.pos + offset >= 0) {
		ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
		if (ret == -1)
			return -1;
		state->x.have = 0;
		state->eof = 0;
		state->past = 0;
		state->seek = 0;
		gz_error(state, Z_OK, NULL);
		state->strm.avail_in = 0;
		state->x.pos += offset;
		return state->x.pos;
	}

	/* calculate skip amount, rewinding if needed for back seek when reading */
	if (offset < 0) {
		if (state->mode != GZ_READ)         /* writing -- can't go backwards */
			return -1;
		offset += state->x.pos;
		if (offset < 0)                     /* before start of file! */
			return -1;
		if (gzrewind(file) == -1)           /* rewind, then skip to offset */
			return -1;
	}

	/* if reading, skip what's in output buffer (one less gzgetc() check) */
	if (state->mode == GZ_READ) {
		n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
			(unsigned)offset : state->x.have;
		state->x.have -= n;
		state->x.next += n;
		state->x.pos += n;
		offset -= n;
	}

	/* request skip (if not zero) */
	if (offset) {
		state->seek = 1;
		state->skip = offset;
	}
	return state->x.pos + offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzseek(gzFile file, z_off_t offset, int whence)
{
	z_off64_t ret;

	ret = gzseek64(file, (z_off64_t)offset, whence);
	return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gztell64(gzFile file)
{
	gz_statep state;

	/* get internal structure and check integrity */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;
	if (state->mode != GZ_READ && state->mode != GZ_WRITE)
		return -1;

	/* return position */
	return state->x.pos + (state->seek ? state->skip : 0);
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gztell(gzFile file)
{
	z_off64_t ret;

	ret = gztell64(file);
	return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzoffset64(gzFile file)
{
	z_off64_t offset;
	gz_statep state;

	/* get internal structure and check integrity */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;
	if (state->mode != GZ_READ && state->mode != GZ_WRITE)
		return -1;

	/* compute and return effective offset in file */
	offset = LSEEK(state->fd, 0, SEEK_CUR);
	if (offset == -1)
		return -1;
	if (state->mode == GZ_READ)             /* reading */
		offset -= state->strm.avail_in;     /* don't count buffered input */
	return offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzoffset(gzFile file)
{
	z_off64_t ret;

	ret = gzoffset64(file);
	return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
int ZEXPORT gzeof(gzFile file)
{
	gz_statep state;

	/* get internal structure and check integrity */
	if (file == NULL)
		return 0;
	state = (gz_statep)file;
	if (state->mode != GZ_READ && state->mode != GZ_WRITE)
		return 0;

	/* return end-of-file state */
	return state->mode == GZ_READ ? state->past : 0;
}

/* -- see zlib.h -- */
const char* ZEXPORT gzerror(
	gzFile file,
	int* errnum)
{
	gz_statep state;

	/* get internal structure and check integrity */
	if (file == NULL)
		return NULL;
	state = (gz_statep)file;
	if (state->mode != GZ_READ && state->mode != GZ_WRITE)
		return NULL;

	/* return error information */
	if (errnum != NULL)
		*errnum = state->err;
	return state->err == Z_MEM_ERROR ? "out of memory" :
		(state->msg == NULL ? "" : state->msg);
}

/* -- see zlib.h -- */
void ZEXPORT gzclearerr(
	gzFile file)
{
	gz_statep state;

	/* get internal structure and check integrity */
	if (file == NULL)
		return;
	state = (gz_statep)file;
	if (state->mode != GZ_READ && state->mode != GZ_WRITE)
		return;

	/* clear error and end-of-file */
	if (state->mode == GZ_READ) {
		state->eof = 0;
		state->past = 0;
	}
	gz_error(state, Z_OK, NULL);
}

/* Create an error message in allocated memory and set state->err and
   state->msg accordingly.  Free any previous error message already there.  Do
   not try to free or allocate space if the error is Z_MEM_ERROR (out of
   memory).  Simply save the error message as a static string.  If there is an
   allocation failure constructing the error message, then convert the error to
   out of memory. */
void ZLIB_INTERNAL gz_error(
	gz_statep state,
	int err,
	const char* msg)
{
	/* free previously allocated message and clear */
	if (state->msg != NULL) {
		if (state->err != Z_MEM_ERROR)
			free(state->msg);
		state->msg = NULL;
	}

	/* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
	if (err != Z_OK && err != Z_BUF_ERROR)
		state->x.have = 0;

	/* set error code, and if no message, then done */
	state->err = err;
	if (msg == NULL)
		return;

	/* for an out of memory error, return literal string when requested */
	if (err == Z_MEM_ERROR)
		return;

	/* construct error message with path */
	if ((state->msg = (char*)malloc(strlen(state->path) + strlen(msg) + 3)) ==
		NULL) {
		state->err = Z_MEM_ERROR;
		return;
	}
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
	(void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
		"%s%s%s", state->path, ": ", msg);
#else
	strcpy(state->msg, state->path);
	strcat(state->msg, ": ");
	strcat(state->msg, msg);
#endif
}

#ifndef INT_MAX
/* portably return maximum value for an int (when limits.h presumed not
   available) -- we need to do this to cover cases where 2's complement not
   used, since C standard permits 1's complement and sign-bit representations,
   otherwise we could just use ((unsigned)-1) >> 1 */
unsigned ZLIB_INTERNAL gz_intmax()
{
	unsigned p, q;

	p = 1;
	do {
		q = p;
		p <<= 1;
		p++;
	} while (p > q);
	return q >> 1;
}
#endif

















/* gzread.c -- zlib functions for reading gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

 /* Local functions */
local int gz_load OF((gz_statep, unsigned char*, unsigned, unsigned*));
local int gz_avail OF((gz_statep));
local int gz_look OF((gz_statep));
local int gz_decomp OF((gz_statep));
local int gz_fetch OF((gz_statep));
local int gz_skip OF((gz_statep, z_off64_t));
local z_size_t gz_read OF((gz_statep, voidp, z_size_t));

/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
   state->fd, and update state->eof, state->err, and state->msg as appropriate.
   This function needs to loop on read(), since read() is not guaranteed to
   read the number of bytes requested, depending on the type of descriptor. */
local int gz_load(
	gz_statep state,
	unsigned char* buf,
	unsigned len,
	unsigned* have)
{
	int ret;
	unsigned get, max = ((unsigned)-1 >> 2) + 1;

	*have = 0;
	do {
		get = len - *have;
		if (get > max)
			get = max;
		ret = _read(state->fd, buf + *have, get); // was read(
		if (ret <= 0)
			break;
		*have += (unsigned)ret;
	} while (*have < len);
	if (ret < 0) {
		gz_error(state, Z_ERRNO, zstrerror());
		return -1;
	}
	if (ret == 0)
		state->eof = 1;
	return 0;
}

/* Load up input buffer and set eof flag if last data loaded -- return -1 on
   error, 0 otherwise.  Note that the eof flag is set when the end of the input
   file is reached, even though there may be unused data in the buffer.  Once
   that data has been used, no more attempts will be made to read the file.
   If strm->avail_in != 0, then the current data is moved to the beginning of
   the input buffer, and then the remainder of the buffer is loaded with the
   available data from the input file. */
local int gz_avail(
	gz_statep state)
{
	unsigned got;
	z_streamp strm = &(state->strm);

	if (state->err != Z_OK && state->err != Z_BUF_ERROR)
		return -1;
	if (state->eof == 0) {
		if (strm->avail_in) {       /* copy what's there to the start */
			unsigned char* p = state->in;
			unsigned const char* q = strm->next_in;
			unsigned n = strm->avail_in;
			do {
				*p++ = *q++;
			} while (--n);
		}
		if (gz_load(state, state->in + strm->avail_in,
			state->size - strm->avail_in, &got) == -1)
			return -1;
		strm->avail_in += got;
		strm->next_in = state->in;
	}
	return 0;
}

/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
   If this is the first zl_TIME in, allocate required memory.  state->how will be
   left unchanged if there is no more input data available, will be set to COPY
   if there is no gzip header and direct copying will be performed, or it will
   be set to GZIP for decompression.  If direct copying, then leftover input
   data from the input buffer will be copied to the output buffer.  In that
   case, all further file reads will be directly to either the output buffer or
   a user buffer.  If decompressing, the inflate state will be initialized.
   gz_look() will return 0 on success or -1 on failure. */
local int gz_look(
	gz_statep state)
{
	z_streamp strm = &(state->strm);

	/* allocate read buffers and inflate memory */
	if (state->size == 0) {
		/* allocate buffers */
		state->in = (unsigned char*)malloc(state->want);
		state->out = (unsigned char*)malloc(state->want << 1);
		if (state->in == NULL || state->out == NULL) {
			free(state->out);
			free(state->in);
			gz_error(state, Z_MEM_ERROR, "out of memory");
			return -1;
		}
		state->size = state->want;

		/* allocate inflate memory */
		state->strm.zalloc = Z_NULL;
		state->strm.zfree = Z_NULL;
		state->strm.opaque = Z_NULL;
		state->strm.avail_in = 0;
		state->strm.next_in = Z_NULL;
		if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
			free(state->out);
			free(state->in);
			state->size = 0;
			gz_error(state, Z_MEM_ERROR, "out of memory");
			return -1;
		}
	}

	/* get at least the magic bytes in the input buffer */
	if (strm->avail_in < 2) {
		if (gz_avail(state) == -1)
			return -1;
		if (strm->avail_in == 0)
			return 0;
	}

	/* look for gzip magic bytes -- if there, do gzip decoding (note: there is
	   a logical dilemma here when considering the case of a partially written
	   gzip file, to wit, if a single 31 byte is written, then we cannot tell
	   whether this is a single-byte file, or just a partially written gzip
	   file -- for here we assume that if a gzip file is being written, then
	   the header will be written in a single operation, so that reading a
	   single byte is sufficient indication that it is not a gzip file) */
	if (strm->avail_in > 1 &&
		strm->next_in[0] == 31 && strm->next_in[1] == 139) {
		inflateReset(strm);
		state->how = GZIP;
		state->direct = 0;
		return 0;
	}

	/* no gzip header -- if we were decoding gzip before, then this is trailing
	   garbage.  Ignore the trailing garbage and finish. */
	if (state->direct == 0) {
		strm->avail_in = 0;
		state->eof = 1;
		state->x.have = 0;
		return 0;
	}

	/* doing raw i/o, copy any leftover input to output -- this assumes that
	   the output buffer is larger than the input buffer, which also assures
	   space for gzungetc() */
	state->x.next = state->out;
	if (strm->avail_in) {
		memcpy(state->x.next, strm->next_in, strm->avail_in);
		state->x.have = strm->avail_in;
		strm->avail_in = 0;
	}
	state->how = COPY;
	state->direct = 1;
	return 0;
}

/* Decompress from input to the provided next_out and avail_out in the state.
   On return, state->x.have and state->x.next point to the just decompressed
   data.  If the gzip stream completes, state->how is reset to LOOK to look for
   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
   on success, -1 on failure. */
local int gz_decomp(gz_statep state)
{
	int ret = Z_OK;
	unsigned had;
	z_streamp strm = &(state->strm);

	/* fill output buffer up to end of deflate stream */
	had = strm->avail_out;
	do {
		/* get more input for inflate() */
		if (strm->avail_in == 0 && gz_avail(state) == -1)
			return -1;
		if (strm->avail_in == 0) {
			gz_error(state, Z_BUF_ERROR, "unexpected end of file");
			break;
		}

		/* decompress and handle errors */
		ret = inflate(strm, Z_NO_FLUSH);
		if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
			gz_error(state, Z_STREAM_ERROR,
				"internal error: inflate stream corrupt");
			return -1;
		}
		if (ret == Z_MEM_ERROR) {
			gz_error(state, Z_MEM_ERROR, "out of memory");
			return -1;
		}
		if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
			gz_error(state, Z_DATA_ERROR,
				strm->msg == NULL ? "compressed data error" : strm->msg);
			return -1;
		}
	} while (strm->avail_out && ret != Z_STREAM_END);

	/* update available output */
	state->x.have = had - strm->avail_out;
	state->x.next = strm->next_out - state->x.have;

	/* if the gzip stream completed successfully, look for another */
	if (ret == Z_STREAM_END)
		state->how = LOOK;

	/* good decompression */
	return 0;
}

/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
   Data is either copied from the input file or decompressed from the input
   file depending on state->how.  If state->how is LOOK, then a gzip header is
   looked for to determine whether to copy or decompress.  Returns -1 on error,
   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
   end of the input file has been reached and all data has been processed.  */
local int gz_fetch(gz_statep state)
{
	z_streamp strm = &(state->strm);

	do {
		switch (state->how) {
		case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
			if (gz_look(state) == -1)
				return -1;
			if (state->how == LOOK)
				return 0;
			break;
		case COPY:      /* -> COPY */
			if (gz_load(state, state->out, state->size << 1, &(state->x.have))
				== -1)
				return -1;
			state->x.next = state->out;
			return 0;
		case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
			strm->avail_out = state->size << 1;
			strm->next_out = state->out;
			if (gz_decomp(state) == -1)
				return -1;
		}
	} while (state->x.have == 0 && (!state->eof || strm->avail_in));
	return 0;
}

/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
local int gz_skip(
	gz_statep state,
	z_off64_t len)
{
	unsigned n;

	/* skip over len bytes or reach end-of-file, whichever comes first */
	while (len)
		/* skip over whatever is in output buffer */
		if (state->x.have) {
			n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
				(unsigned)len : state->x.have;
			state->x.have -= n;
			state->x.next += n;
			state->x.pos += n;
			len -= n;
		}

	/* output buffer empty -- return if we're at the end of the input */
		else if (state->eof && state->strm.avail_in == 0)
			break;

	/* need more data to skip -- load up output buffer */
		else {
			/* get more output, looking for header if required */
			if (gz_fetch(state) == -1)
				return -1;
		}
	return 0;
}

/* Read len bytes into buf from file, or less than len up to the end of the
   input.  Return the number of bytes read.  If zero is returned, either the
   end of file was reached, or there was an error.  state->err must be
   consulted in that case to determine which. */
local z_size_t gz_read(gz_statep state, voidp buf, z_size_t len)
{
	z_size_t got;
	unsigned n;

	/* if len is zero, avoid unnecessary operations */
	if (len == 0)
		return 0;

	/* process a skip request */
	if (state->seek) {
		state->seek = 0;
		if (gz_skip(state, state->skip) == -1)
			return 0;
	}

	/* get len bytes to buf, or less than len if at the end */
	got = 0;
	do {
		/* set n to the maximum amount of len that fits in an unsigned int */
		n = -1;
		if (n > len)
			n = len;

		/* first just try copying data from the output buffer */
		if (state->x.have) {
			if (state->x.have < n)
				n = state->x.have;
			memcpy(buf, state->x.next, n);
			state->x.next += n;
			state->x.have -= n;
		}

		/* output buffer empty -- return if we're at the end of the input */
		else if (state->eof && state->strm.avail_in == 0) {
			state->past = 1;        /* tried to read past end */
			break;
		}

		/* need output data -- for small len or new stream load up our output
		   buffer */
		else if (state->how == LOOK || n < (state->size << 1)) {
			/* get more output, looking for header if required */
			if (gz_fetch(state) == -1)
				return 0;
			continue;       /* no progress yet -- go back to copy above */
			/* the copy above assures that we will leave with space in the
			   output buffer, allowing at least one gzungetc() to succeed */
		}

		/* large len -- read directly into user buffer */
		else if (state->how == COPY) {      /* read directly */
			if (gz_load(state, (unsigned char*)buf, n, &n) == -1)
				return 0;
		}

		/* large len -- decompress directly into user buffer */
		else {  /* state->how == GZIP */
			state->strm.avail_out = n;
			state->strm.next_out = (unsigned char*)buf;
			if (gz_decomp(state) == -1)
				return 0;
			n = state->x.have;
			state->x.have = 0;
		}

		/* update progress */
		len -= n;
		buf = (char*)buf + n;
		got += n;
		state->x.pos += n;
	} while (len);

	/* return number of bytes read into user buffer */
	return got;
}

/* -- see zlib.h -- */
int ZEXPORT gzread(
	gzFile file,
	voidp buf,
	unsigned len)
{
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;

	/* check that we're reading and that there's no (serious) error */
	if (state->mode != GZ_READ ||
		(state->err != Z_OK && state->err != Z_BUF_ERROR))
		return -1;

	/* since an int is returned, make sure len fits in one, otherwise return
	   with an error (this avoids a flaw in the interface) */
	if ((int)len < 0) {
		gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");
		return -1;
	}

	/* read len or fewer bytes to buf */
	len = gz_read(state, buf, len);

	/* check for an error */
	if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)
		return -1;

	/* return the number of bytes read (this is assured to fit in an int) */
	return (int)len;
}

/* -- see zlib.h -- */
z_size_t ZEXPORT gzfread(
	voidp buf,
	z_size_t size,
	z_size_t nitems,
	gzFile file)
{
	z_size_t len;
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return 0;
	state = (gz_statep)file;

	/* check that we're reading and that there's no (serious) error */
	if (state->mode != GZ_READ ||
		(state->err != Z_OK && state->err != Z_BUF_ERROR))
		return 0;

	/* compute bytes to read -- error on overflow */
	len = nitems * size;
	if (size && len / size != nitems) {
		gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
		return 0;
	}

	/* read len or fewer bytes to buf, return the number of full items read */
	return len ? gz_read(state, buf, len) / size : 0;
}

/* -- see zlib.h -- */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#else
#  undef gzgetc
#endif
int ZEXPORT gzgetc(gzFile file)
{
	int ret;
	unsigned char buf[1];
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;

	/* check that we're reading and that there's no (serious) error */
	if (state->mode != GZ_READ ||
		(state->err != Z_OK && state->err != Z_BUF_ERROR))
		return -1;

	/* try output buffer (no need to check for skip request) */
	if (state->x.have) {
		state->x.have--;
		state->x.pos++;
		return *(state->x.next)++;
	}

	/* nothing there -- try gz_read() */
	ret = gz_read(state, buf, 1);
	return ret < 1 ? -1 : buf[0];
}

int ZEXPORT gzgetc_(gzFile file)
{
	return gzgetc(file);
}

/* -- see zlib.h -- */
int ZEXPORT gzungetc(
	int c,
	gzFile file)
{
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;

	/* check that we're reading and that there's no (serious) error */
	if (state->mode != GZ_READ ||
		(state->err != Z_OK && state->err != Z_BUF_ERROR))
		return -1;

	/* process a skip request */
	if (state->seek) {
		state->seek = 0;
		if (gz_skip(state, state->skip) == -1)
			return -1;
	}

	/* can't push EOF */
	if (c < 0)
		return -1;

	/* if output buffer empty, put byte at end (allows more pushing) */
	if (state->x.have == 0) {
		state->x.have = 1;
		state->x.next = state->out + (state->size << 1) - 1;
		state->x.next[0] = (unsigned char)c;
		state->x.pos--;
		state->past = 0;
		return c;
	}

	/* if no room, give up (must have already done a gzungetc()) */
	if (state->x.have == (state->size << 1)) {
		gz_error(state, Z_DATA_ERROR, "out of room to push characters");
		return -1;
	}

	/* slide output data if needed and insert byte before existing data */
	if (state->x.next == state->out) {
		unsigned char* src = state->out + state->x.have;
		unsigned char* dest = state->out + (state->size << 1);
		while (src > state->out)
			*--dest = *--src;
		state->x.next = dest;
	}
	state->x.have++;
	state->x.next--;
	state->x.next[0] = (unsigned char)c;
	state->x.pos--;
	state->past = 0;
	return c;
}

/* -- see zlib.h -- */
char* ZEXPORT gzgets(
	gzFile file,
	char* buf,
	int len)
{
	unsigned left, n;
	char* str;
	unsigned char* eol;
	gz_statep state;

	/* check parameters and get internal structure */
	if (file == NULL || buf == NULL || len < 1)
		return NULL;
	state = (gz_statep)file;

	/* check that we're reading and that there's no (serious) error */
	if (state->mode != GZ_READ ||
		(state->err != Z_OK && state->err != Z_BUF_ERROR))
		return NULL;

	/* process a skip request */
	if (state->seek) {
		state->seek = 0;
		if (gz_skip(state, state->skip) == -1)
			return NULL;
	}

	/* copy output bytes up to new line or len - 1, whichever comes first --
	   append a terminating zero to the string (we don't check for a zero in
	   the contents, let the user worry about that) */
	str = buf;
	left = (unsigned)len - 1;
	if (left) do {
		/* assure that something is in the output buffer */
		if (state->x.have == 0 && gz_fetch(state) == -1)
			return NULL;                /* error */
		if (state->x.have == 0) {       /* end of file */
			state->past = 1;            /* read past end */
			break;                      /* return what we have */
		}

		/* look for end-of-line in current output buffer */
		n = state->x.have > left ? left : state->x.have;
		eol = (unsigned char*)memchr(state->x.next, '\n', n);
		if (eol != NULL)
			n = (unsigned)(eol - state->x.next) + 1;

		/* copy through end-of-line, or remainder if not found */
		memcpy(buf, state->x.next, n);
		state->x.have -= n;
		state->x.next += n;
		state->x.pos += n;
		left -= n;
		buf += n;
	} while (left && eol == NULL);

	/* return terminated string, or if nothing, end of file */
	if (buf == str)
		return NULL;
	buf[0] = 0;
	return str;
}

/* -- see zlib.h -- */
int ZEXPORT gzdirect(
	gzFile file)
{
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return 0;
	state = (gz_statep)file;

	/* if the state is not known, but we can find out, then do so (this is
	   mainly for right after a gzopen() or gzdopen()) */
	if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
		(void)gz_look(state);

	/* return 1 if transparent, 0 if processing a gzip stream */
	return state->direct;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_r(
	gzFile file)
{
	int ret, err;
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return Z_STREAM_ERROR;
	state = (gz_statep)file;

	/* check that we're reading */
	if (state->mode != GZ_READ)
		return Z_STREAM_ERROR;

	/* free memory and close file */
	if (state->size) {
		inflateEnd(&(state->strm));
		free(state->out);
		free(state->in);
	}
	err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
	gz_error(state, Z_OK, NULL);
	free(state->path);
	ret = _close(state->fd); // was close(
	free(state);
	return ret ? Z_ERRNO : err;
}



/* gzwrite.c -- zlib functions for writing gzip files
 * Copyright (C) 2004-2017 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

 /* Local functions */
local int gz_init OF((gz_statep));
local int gz_comp OF((gz_statep, int));
local int gz_zero OF((gz_statep, z_off64_t));
local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));

/* Initialize state for writing a gzip file.  Mark initialization by setting
   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
   success. */
local int gz_init(
	gz_statep state)
{
	int ret;
	z_streamp strm = &(state->strm);

	/* allocate input buffer (double size for gzprintf) */
	state->in = (unsigned char*)malloc(state->want << 1);
	if (state->in == NULL) {
		gz_error(state, Z_MEM_ERROR, "out of memory");
		return -1;
	}

	/* only need output buffer and deflate state if compressing */
	if (!state->direct) {
		/* allocate output buffer */
		state->out = (unsigned char*)malloc(state->want);
		if (state->out == NULL) {
			free(state->in);
			gz_error(state, Z_MEM_ERROR, "out of memory");
			return -1;
		}

		/* allocate deflate memory, set up for gzip compression */
		strm->zalloc = Z_NULL;
		strm->zfree = Z_NULL;
		strm->opaque = Z_NULL;
		ret = deflateInit2(strm, state->level, Z_DEFLATED,
			MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
		if (ret != Z_OK) {
			free(state->out);
			free(state->in);
			gz_error(state, Z_MEM_ERROR, "out of memory");
			return -1;
		}
		strm->next_in = NULL;
	}

	/* mark state as initialized */
	state->size = state->want;

	/* initialize write buffer if compressing */
	if (!state->direct) {
		strm->avail_out = state->size;
		strm->next_out = state->out;
		state->x.next = strm->next_out;
	}
	return 0;
}

/* Compress whatever is at avail_in and next_in and write to the output file.
   Return -1 if there is an error writing to the output file or if gz_init()
   fails to allocate memory, otherwise 0.  flush is assumed to be a valid
   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
   reset to start a new gzip stream.  If gz->direct is true, then simply write
   to the output file without compressing, and ignore flush. */
local int gz_comp(
	gz_statep state,
	int flush)
{
	int ret, writ;
	unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
	z_streamp strm = &(state->strm);

	/* allocate memory if this is the first zl_TIME through */
	if (state->size == 0 && gz_init(state) == -1)
		return -1;

	/* write directly if requested */
	if (state->direct) {
		while (strm->avail_in) {
			put = strm->avail_in > max ? max : strm->avail_in;
			writ = _write(state->fd, strm->next_in, put); // was write(
			if (writ < 0) {
				gz_error(state, Z_ERRNO, zstrerror());
				return -1;
			}
			strm->avail_in -= (unsigned)writ;
			strm->next_in += writ;
		}
		return 0;
	}

	/* run deflate() on provided input until it produces no more output */
	ret = Z_OK;
	do {
		/* write out current buffer contents if full, or if flushing, but if
		   doing Z_FINISH then don't write until we get to Z_STREAM_END */
		if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
			(flush != Z_FINISH || ret == Z_STREAM_END))) {
			while (strm->next_out > state->x.next) {
				put = strm->next_out - state->x.next > (int)max ? max :
					(unsigned)(strm->next_out - state->x.next);
				writ = _write(state->fd, state->x.next, put); // was write(
				if (writ < 0) {
					gz_error(state, Z_ERRNO, zstrerror());
					return -1;
				}
				state->x.next += writ;
			}
			if (strm->avail_out == 0) {
				strm->avail_out = state->size;
				strm->next_out = state->out;
				state->x.next = state->out;
			}
		}

		/* compress */
		have = strm->avail_out;
		ret = deflate(strm, flush);
		if (ret == Z_STREAM_ERROR) {
			gz_error(state, Z_STREAM_ERROR,
				"internal error: deflate stream corrupt");
			return -1;
		}
		have -= strm->avail_out;
	} while (have);

	/* if that completed a deflate stream, allow another to start */
	if (flush == Z_FINISH)
		deflateReset(strm);

	/* all done, no errors */
	return 0;
}

/* Compress len zeros to output.  Return -1 on a write error or memory
   allocation failure by gz_comp(), or 0 on success. */
local int gz_zero(
	gz_statep state,
	z_off64_t len)
{
	int first;
	unsigned n;
	z_streamp strm = &(state->strm);

	/* consume whatever's left in the input buffer */
	if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
		return -1;

	/* compress len zeros (len guaranteed > 0) */
	first = 1;
	while (len) {
		n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
			(unsigned)len : state->size;
		if (first) {
			memset(state->in, 0, n);
			first = 0;
		}
		strm->avail_in = n;
		strm->next_in = state->in;
		state->x.pos += n;
		if (gz_comp(state, Z_NO_FLUSH) == -1)
			return -1;
		len -= n;
	}
	return 0;
}

/* Write len bytes from buf to file.  Return the number of bytes written.  If
   the returned value is less than len, then there was an error. */
local z_size_t gz_write(
	gz_statep state,
	voidpc buf,
	z_size_t len)
{
	z_size_t put = len;

	/* if len is zero, avoid unnecessary operations */
	if (len == 0)
		return 0;

	/* allocate memory if this is the first zl_TIME through */
	if (state->size == 0 && gz_init(state) == -1)
		return 0;

	/* check for seek request */
	if (state->seek) {
		state->seek = 0;
		if (gz_zero(state, state->skip) == -1)
			return 0;
	}

	/* for small len, copy to input buffer, otherwise compress directly */
	if (len < state->size) {
		/* copy to input buffer, compress when full */
		do {
			unsigned have, copy;

			if (state->strm.avail_in == 0)
				state->strm.next_in = state->in;
			have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
				state->in);
			copy = state->size - have;
			if (copy > len)
				copy = len;
			memcpy(state->in + have, buf, copy);
			state->strm.avail_in += copy;
			state->x.pos += copy;
			buf = (const char*)buf + copy;
			len -= copy;
			if (len && gz_comp(state, Z_NO_FLUSH) == -1)
				return 0;
		} while (len);
	}
	else {
		/* consume whatever's left in the input buffer */
		if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
			return 0;

		/* directly compress user buffer to file */
		state->strm.next_in = (z_const Bytef*)buf;
		do {
			unsigned n = (unsigned)-1;
			if (n > len)
				n = len;
			state->strm.avail_in = n;
			state->x.pos += n;
			if (gz_comp(state, Z_NO_FLUSH) == -1)
				return 0;
			len -= n;
		} while (len);
	}

	/* input was all buffered or compressed */
	return put;
}

/* -- see zlib.h -- */
int ZEXPORT gzwrite(
	gzFile file,
	voidpc buf,
	unsigned len)
{
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return 0;
	state = (gz_statep)file;

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return 0;

	/* since an int is returned, make sure len fits in one, otherwise return
	   with an error (this avoids a flaw in the interface) */
	if ((int)len < 0) {
		gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
		return 0;
	}

	/* write len bytes from buf (the return value will fit in an int) */
	return (int)gz_write(state, buf, len);
}

/* -- see zlib.h -- */
z_size_t ZEXPORT gzfwrite(
	voidpc buf,
	z_size_t size,
	z_size_t nitems,
	gzFile file)
{
	z_size_t len;
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return 0;
	state = (gz_statep)file;

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return 0;

	/* compute bytes to read -- error on overflow */
	len = nitems * size;
	if (size && len / size != nitems) {
		gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
		return 0;
	}

	/* write len bytes to buf, return the number of full items written */
	return len ? gz_write(state, buf, len) / size : 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzputc(
	gzFile file,
	int c)
{
	unsigned have;
	unsigned char buf[1];
	gz_statep state;
	z_streamp strm;

	/* get internal structure */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;
	strm = &(state->strm);

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return -1;

	/* check for seek request */
	if (state->seek) {
		state->seek = 0;
		if (gz_zero(state, state->skip) == -1)
			return -1;
	}

	/* try writing to input buffer for speed (state->size == 0 if buffer not
	   initialized) */
	if (state->size) {
		if (strm->avail_in == 0)
			strm->next_in = state->in;
		have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
		if (have < state->size) {
			state->in[have] = (unsigned char)c;
			strm->avail_in++;
			state->x.pos++;
			return c & 0xff;
		}
	}

	/* no room in buffer or not initialized, use gz_write() */
	buf[0] = (unsigned char)c;
	if (gz_write(state, buf, 1) != 1)
		return -1;
	return c & 0xff;
}

/* -- see zlib.h -- */
int ZEXPORT gzputs(
	gzFile file,
	const char* str)
{
	int ret;
	z_size_t len;
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return -1;
	state = (gz_statep)file;

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return -1;

	/* write string */
	len = strlen(str);
	ret = gz_write(state, str, len);
	return ret == 0 && len != 0 ? -1 : ret;
}

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#include <stdarg.h>

/* -- see zlib.h -- */
int ZEXPORTVA gzvprintf(gzFile file, const char* format, va_list va)
{
	int len;
	unsigned left;
	char* next;
	gz_statep state;
	z_streamp strm;

	/* get internal structure */
	if (file == NULL)
		return Z_STREAM_ERROR;
	state = (gz_statep)file;
	strm = &(state->strm);

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return Z_STREAM_ERROR;

	/* make sure we have some buffer space */
	if (state->size == 0 && gz_init(state) == -1)
		return state->err;

	/* check for seek request */
	if (state->seek) {
		state->seek = 0;
		if (gz_zero(state, state->skip) == -1)
			return state->err;
	}

	/* do the printf() into the input buffer, put length in len -- the input
	   buffer is double-sized just for this function, so there is guaranteed to
	   be state->size bytes available after the current contents */
	if (strm->avail_in == 0)
		strm->next_in = state->in;
	next = (char*)(state->in + (strm->next_in - state->in) + strm->avail_in);
	next[state->size - 1] = 0;
#ifdef NO_vsnprintf
#  ifdef HAS_vsprintf_void
	(void)vsprintf(next, format, va);
	for (len = 0; len < state->size; len++)
		if (next[len] == 0) break;
#  else
	len = vsprintf(next, format, va);
#  endif
#else
#  ifdef HAS_vsnprintf_void
	(void)vsnprintf(next, state->size, format, va);
	len = strlen(next);
#  else
	len = vsnprintf(next, state->size, format, va);
#  endif
#endif

	/* check that printf() results fit in buffer */
	if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)
		return 0;

	/* update buffer and position, compress first half if past that */
	strm->avail_in += (unsigned)len;
	state->x.pos += len;
	if (strm->avail_in >= state->size) {
		left = strm->avail_in - state->size;
		strm->avail_in = state->size;
		if (gz_comp(state, Z_NO_FLUSH) == -1)
			return state->err;
		memcpy(state->in, state->in + state->size, left);
		strm->next_in = state->in;
		strm->avail_in = left;
	}
	return len;
}

int ZEXPORTVA gzprintf(gzFile file, const char* format, ...)
{
	va_list va;
	int ret;

	va_start(va, format);
	ret = gzvprintf(file, format, va);
	va_end(va);
	return ret;
}

#else /* !STDC && !Z_HAVE_STDARG_H */

/* -- see zlib.h -- */
int ZEXPORTVA gzprintf(file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
	gzFile file;
const char* format;
int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
	unsigned len, left;
	char* next;
	gz_statep state;
	z_streamp strm;

	/* get internal structure */
	if (file == NULL)
		return Z_STREAM_ERROR;
	state = (gz_statep)file;
	strm = &(state->strm);

	/* check that can really pass pointer in ints */
	if (sizeof(int) != sizeof(void*))
		return Z_STREAM_ERROR;

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return Z_STREAM_ERROR;

	/* make sure we have some buffer space */
	if (state->size == 0 && gz_init(state) == -1)
		return state->error;

	/* check for seek request */
	if (state->seek) {
		state->seek = 0;
		if (gz_zero(state, state->skip) == -1)
			return state->error;
	}

	/* do the printf() into the input buffer, put length in len -- the input
	   buffer is double-sized just for this function, so there is guaranteed to
	   be state->size bytes available after the current contents */
	if (strm->avail_in == 0)
		strm->next_in = state->in;
	next = (char*)(strm->next_in + strm->avail_in);
	next[state->size - 1] = 0;
#ifdef NO_snprintf
#  ifdef HAS_sprintf_void
	sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,
		a13, a14, a15, a16, a17, a18, a19, a20);
	for (len = 0; len < size; len++)
		if (next[len] == 0)
			break;
#  else
	len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,
		a12, a13, a14, a15, a16, a17, a18, a19, a20);
#  endif
#else
#  ifdef HAS_snprintf_void
	snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,
		a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
	len = strlen(next);
#  else
	len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,
		a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#  endif
#endif

	/* check that printf() results fit in buffer */
	if (len == 0 || len >= state->size || next[state->size - 1] != 0)
		return 0;

	/* update buffer and position, compress first half if past that */
	strm->avail_in += len;
	state->x.pos += len;
	if (strm->avail_in >= state->size) {
		left = strm->avail_in - state->size;
		strm->avail_in = state->size;
		if (gz_comp(state, Z_NO_FLUSH) == -1)
			return state->err;
		memcpy(state->in, state->in + state->size, left);
		strm->next_in = state->in;
		strm->avail_in = left;
	}
	return (int)len;
}

#endif

/* -- see zlib.h -- */
int ZEXPORT gzflush(gzFile file, int flush)
{
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return Z_STREAM_ERROR;
	state = (gz_statep)file;

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return Z_STREAM_ERROR;

	/* check flush parameter */
	if (flush < 0 || flush > Z_FINISH)
		return Z_STREAM_ERROR;

	/* check for seek request */
	if (state->seek) {
		state->seek = 0;
		if (gz_zero(state, state->skip) == -1)
			return state->err;
	}

	/* compress remaining data with requested flush */
	(void)gz_comp(state, flush);
	return state->err;
}

/* -- see zlib.h -- */
int ZEXPORT gzsetparams(gzFile file, int level, int strategy)
{
	gz_statep state;
	z_streamp strm;

	/* get internal structure */
	if (file == NULL)
		return Z_STREAM_ERROR;
	state = (gz_statep)file;
	strm = &(state->strm);

	/* check that we're writing and that there's no error */
	if (state->mode != GZ_WRITE || state->err != Z_OK)
		return Z_STREAM_ERROR;

	/* if no change is requested, then do nothing */
	if (level == state->level && strategy == state->strategy)
		return Z_OK;

	/* check for seek request */
	if (state->seek) {
		state->seek = 0;
		if (gz_zero(state, state->skip) == -1)
			return state->err;
	}

	/* change compression parameters for subsequent input */
	if (state->size) {
		/* flush previous input with previous parameters before changing */
		if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)
			return state->err;
		deflateParams(strm, level, strategy);
	}
	state->level = level;
	state->strategy = strategy;
	return Z_OK;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_w(gzFile file)
{
	int ret = Z_OK;
	gz_statep state;

	/* get internal structure */
	if (file == NULL)
		return Z_STREAM_ERROR;
	state = (gz_statep)file;

	/* check that we're writing */
	if (state->mode != GZ_WRITE)
		return Z_STREAM_ERROR;

	/* check for seek request */
	if (state->seek) {
		state->seek = 0;
		if (gz_zero(state, state->skip) == -1)
			ret = state->err;
	}

	/* flush, free memory, and close file */
	if (gz_comp(state, Z_FINISH) == -1)
		ret = state->err;
	if (state->size) {
		if (!state->direct) {
			(void)deflateEnd(&(state->strm));
			free(state->out);
		}
		free(state->in);
	}
	gz_error(state, Z_OK, NULL);
	free(state->path);
	if (_close(state->fd) == -1) // was close(
		ret = Z_ERRNO;
	free(state);
	return ret;
}


































/* gzclose.c -- zlib gzclose() function
 * Copyright (C) 2004, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

 /* gzclose() is in a separate file so that it is linked in only if it is used.
	That way the other gzclose functions can be used instead to avoid linking in
	unneeded compression or decompression routines. */
int ZEXPORT gzclose(gzFile file)
{
#ifndef NO_GZCOMPRESS
	gz_statep state;

	if (file == NULL)
		return Z_STREAM_ERROR;
	state = (gz_statep)file;

	return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
#else
	return gzclose_r(file);
#endif
}














#endif
















z_const char* const z_errmsg[10] = {
	(z_const char*)"need dictionary",     /* Z_NEED_DICT       2  */
	(z_const char*)"stream end",          /* Z_STREAM_END      1  */
	(z_const char*)"",                    /* Z_OK              0  */
	(z_const char*)"file error",          /* Z_ERRNO         (-1) */
	(z_const char*)"stream error",        /* Z_STREAM_ERROR  (-2) */
	(z_const char*)"data error",          /* Z_DATA_ERROR    (-3) */
	(z_const char*)"insufficient memory", /* Z_MEM_ERROR     (-4) */
	(z_const char*)"buffer error",        /* Z_BUF_ERROR     (-5) */
	(z_const char*)"incompatible version",/* Z_VERSION_ERROR (-6) */
	(z_const char*)""
};


const char* ZEXPORT zlibVersion()
{
	return ZLIB_VERSION;
}

uLong ZEXPORT zlibCompilezl_FLAGS()
{
	uLong zl_FLAGS;

	zl_FLAGS = 0;
	switch ((int)(sizeof(uInt))) {
	case 2:     break;
	case 4:     zl_FLAGS += 1;     break;
	case 8:     zl_FLAGS += 2;     break;
	default:    zl_FLAGS += 3;
	}
	switch ((int)(sizeof(uLong))) {
	case 2:     break;
	case 4:     zl_FLAGS += 1 << 2;        break;
	case 8:     zl_FLAGS += 2 << 2;        break;
	default:    zl_FLAGS += 3 << 2;
	}
	switch ((int)(sizeof(voidpf))) {
	case 2:     break;
	case 4:     zl_FLAGS += 1 << 4;        break;
	case 8:     zl_FLAGS += 2 << 4;        break;
	default:    zl_FLAGS += 3 << 4;
	}
	switch ((int)(sizeof(z_off_t))) {
	case 2:     break;
	case 4:     zl_FLAGS += 1 << 6;        break;
	case 8:     zl_FLAGS += 2 << 6;        break;
	default:    zl_FLAGS += 3 << 6;
	}
#ifdef ZLIB_DEBUG
	zl_FLAGS += 1 << 8;
#endif
#if defined(ASMV) || defined(ASMINF)
	zl_FLAGS += 1 << 9;
#endif
#ifdef ZLIB_WINAPI
	zl_FLAGS += 1 << 10;
#endif
#ifdef BUILDFIXED
	zl_FLAGS += 1 << 12;
#endif
#ifdef DYNAMIC_CRC_TABLE
	zl_FLAGS += 1 << 13;
#endif
#ifdef NO_GZCOMPRESS
	zl_FLAGS += 1L << 16;
#endif
#ifdef NO_GZIP
	zl_FLAGS += 1L << 17;
#endif
#ifdef PKZIP_BUG_WORKAROUND
	zl_FLAGS += 1L << 20;
#endif
#ifdef FASTEST
	zl_FLAGS += 1L << 21;
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifdef NO_vsnprintf
	zl_FLAGS += 1L << 25;
#    ifdef HAS_vsprintf_void
	zl_FLAGS += 1L << 26;
#    endif
#  else
#    ifdef HAS_vsnprintf_void
	zl_FLAGS += 1L << 26;
#    endif
#  endif
#else
	zl_FLAGS += 1L << 24;
#  ifdef NO_snprintf
	zl_FLAGS += 1L << 25;
#    ifdef HAS_sprintf_void
	zl_FLAGS += 1L << 26;
#    endif
#  else
#    ifdef HAS_snprintf_void
	zl_FLAGS += 1L << 26;
#    endif
#  endif
#endif
	return zl_FLAGS;
}

#ifdef ZLIB_DEBUG
#include <stdlib.h>
#  ifndef verbose
#    define verbose 0
#  endif
int ZLIB_INTERNAL z_verbose = verbose;

void ZLIB_INTERNAL z_error(m)
char* m;
{
	fprintf(stderr, "%s\n", m);
	exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char* ZEXPORT zError(int err)
{
	return ERR_MSG(err);
}

#if defined(_WIN32_WCE)
/* The Microsoft C Run-zl_TIME Library for Windows CE doesn't have
 * errno.  We define it as a global variable to simplify porting.
 * Its value is always 0 and should not be used.
 */
int errno = 0;
#endif

#ifndef HAVE_MEMCPY

void ZLIB_INTERNAL zmemcpy(dest, source, len)
Bytef* dest;
const Bytef* source;
uInt  len;
{
	if (len == 0) return;
	do {
		*dest++ = *source++; /* ??? to be unrolled */
	} while (--len != 0);
}

int ZLIB_INTERNAL zmemcmp(s1, s2, len)
const Bytef* s1;
const Bytef* s2;
uInt  len;
{
	uInt j;

	for (j = 0; j < len; j++) {
		if (s1[j] != s2[j]) return 2 * (s1[j] > s2[j]) - 1;
	}
	return 0;
}

void ZLIB_INTERNAL zmemzero(dest, len)
Bytef* dest;
uInt  len;
{
	if (len == 0) return;
	do {
		*dest++ = 0;  /* ??? to be unrolled */
	} while (--len != 0);
}
#endif

#ifndef Z_SOLO

#ifdef SYS16BIT

#ifdef __TURBOC__
/* Turbo C in 16-bit mode */

#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
 /* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
	voidpf org_ptr;
	voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)
{
	voidpf buf;
	ulg bsize = (ulg)items * size;

	(void)opaque;

	/* If we allocate less than 65520 bytes, we assume that farmalloc
	 * will return a usable pointer which doesn't have to be normalized.
	 */
	if (bsize < 65520L) {
		buf = farmalloc(bsize);
		if (*(ush*)&buf != 0) return buf;
	}
	else {
		buf = farmalloc(bsize + 16L);
	}
	if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
	table[next_ptr].org_ptr = buf;

	/* Normalize the pointer to seg:0 */
	*((ush*)&buf + 1) += ((ush)((uch*)buf - 0) + 15) >> 4;
	*(ush*)&buf = 0;
	table[next_ptr++].new_ptr = buf;
	return buf;
}

void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
{
	int n;

	(void)opaque;

	if (*(ush*)&ptr != 0) { /* object < 64K */
		farfree(ptr);
		return;
	}
	/* Find the original pointer */
	for (n = 0; n < next_ptr; n++) {
		if (ptr != table[n].new_ptr) continue;

		farfree(table[n].org_ptr);
		while (++n < next_ptr) {
			table[n - 1] = table[n];
		}
		next_ptr--;
		return;
	}
	Assert(0, "zcfree: ptr not found");
}

#endif /* __TURBOC__ */


#ifdef M_I86
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size)
{
	(void)opaque;
	return _halloc((long)items, size);
}

void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
{
	(void)opaque;
	_hfree(ptr);
}

#endif /* M_I86 */

#endif /* SYS16BIT */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  malloc OF((uInt size));
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)
{
	(void)opaque;
	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
		(voidpf)calloc(items, size);
}

void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
{
	(void)opaque;
	free(ptr);
}

#endif /* MY_ZCALLOC */

#endif /* !Z_SOLO */








