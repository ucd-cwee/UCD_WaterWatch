# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 C:\Users\14154\source\repos\ucd-cwee\UCD_WaterWatch\swigwin-4.1.1\swig.exe -c++ -r -o C:\Users\14154\source\repos\ucd-cwee\UCD_WaterWatch\WaterWatch_R_SWIG\SWIG_wrap.cpp C:\Users\14154\source\repos\ucd-cwee\UCD_WaterWatch\WaterWatch_Cs_SWIG\SWIG.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  delayedAssign(defName,  .values, assign.env = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_cweeDateTime', contains = 'C++Reference')
setClass('_p_Awaiter', contains = 'C++Reference')
setClass('_p_SharedMatrix', contains = 'C++Reference')
setClass('_p_SharedTimeSeriesPattern', contains = 'C++Reference')
setClass('_p_SharedString', contains = 'C++Reference')
setClass('_p_WaterWatchEnums', contains = 'C++Reference')
setClass('_p_ScriptingNode', contains = 'C++Reference')
setClass('_p_Color_Interop', contains = 'C++Reference')
setClass('_p_MapIcon_Interop', contains = 'C++Reference')
setClass('_p_MapPolyline_Interop', contains = 'C++Reference')
setClass('_p_MapBackground_Interop', contains = 'C++Reference')
setClass('_p_MapLayer_Interop', contains = 'C++Reference')
setClass('_p_ScriptObject', contains = 'C++Reference')
setClass('_p_ScriptEngine', contains = 'C++Reference')
setClass('_p_WaterWatch', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_PairT_cweeDateTime_float_t', contains = 'C++Reference')
setClass('_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t', contains = 'C++Reference')
setClass('_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', contains = 'C++Reference')
setClass('_p_PairT_double_double_t', contains = 'C++Reference')
setClass('_p_PairT_std__string_std__string_t', contains = 'C++Reference')
setClass('_p_PairT_bool_PairT_std__string_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_float_std__allocatorT_float_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', contains = 'C++Reference')
setClass('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t', contains = 'C++Reference')
setClass('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t', contains = 'C++Reference')
setClass('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of uwp_color_RED_get

`uwp_color_RED_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_uwp_color_RED_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_color");
  
  ans
  
}

attr(`uwp_color_RED_get`, 'returnType') = 'character'
class(`uwp_color_RED_get`) = c("SWIGFunction", class('uwp_color_RED_get'))

# Start of uwp_color_BLUE_get

`uwp_color_BLUE_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_uwp_color_BLUE_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_color");
  
  ans
  
}

attr(`uwp_color_BLUE_get`, 'returnType') = 'character'
class(`uwp_color_BLUE_get`) = c("SWIGFunction", class('uwp_color_BLUE_get'))

# Start of uwp_color_GREEN_get

`uwp_color_GREEN_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_uwp_color_GREEN_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_color");
  
  ans
  
}

attr(`uwp_color_GREEN_get`, 'returnType') = 'character'
class(`uwp_color_GREEN_get`) = c("SWIGFunction", class('uwp_color_GREEN_get'))

# Start of uwp_patternInterpType_LEFT_get

`uwp_patternInterpType_LEFT_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_uwp_patternInterpType_LEFT_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_patternInterpType");
  
  ans
  
}

attr(`uwp_patternInterpType_LEFT_get`, 'returnType') = 'character'
class(`uwp_patternInterpType_LEFT_get`) = c("SWIGFunction", class('uwp_patternInterpType_LEFT_get'))

# Start of uwp_patternInterpType_RIGHT_get

`uwp_patternInterpType_RIGHT_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_uwp_patternInterpType_RIGHT_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_patternInterpType");
  
  ans
  
}

attr(`uwp_patternInterpType_RIGHT_get`, 'returnType') = 'character'
class(`uwp_patternInterpType_RIGHT_get`) = c("SWIGFunction", class('uwp_patternInterpType_RIGHT_get'))

# Start of uwp_patternInterpType_LINEAR_get

`uwp_patternInterpType_LINEAR_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_uwp_patternInterpType_LINEAR_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_patternInterpType");
  
  ans
  
}

attr(`uwp_patternInterpType_LINEAR_get`, 'returnType') = 'character'
class(`uwp_patternInterpType_LINEAR_get`) = c("SWIGFunction", class('uwp_patternInterpType_LINEAR_get'))

# Start of uwp_patternInterpType_SPLINE_get

`uwp_patternInterpType_SPLINE_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_uwp_patternInterpType_SPLINE_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_patternInterpType");
  
  ans
  
}

attr(`uwp_patternInterpType_SPLINE_get`, 'returnType') = 'character'
class(`uwp_patternInterpType_SPLINE_get`) = c("SWIGFunction", class('uwp_patternInterpType_SPLINE_get'))

# Start of new_cweeDateTime

`cweeDateTime__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_cweeDateTime__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_cweeDateTime", ref=ans);
  
  reg.finalizer(ans@ref, delete_cweeDateTime);
  ans
  
}

attr(`cweeDateTime__SWIG_0`, 'returnType') = '_p_cweeDateTime'
class(`cweeDateTime__SWIG_0`) = c("SWIGFunction", class('cweeDateTime__SWIG_0'))

# Start of new_cweeDateTime

`cweeDateTime__SWIG_1` = function(x)
{
  ;ans = .Call('R_swig_new_cweeDateTime__SWIG_1', x, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_cweeDateTime", ref=ans);
  
  reg.finalizer(ans@ref, delete_cweeDateTime);
  ans
  
}

attr(`cweeDateTime__SWIG_1`, 'returnType') = '_p_cweeDateTime'
attr(`cweeDateTime__SWIG_1`, "inputTypes") = c('numeric')
class(`cweeDateTime__SWIG_1`) = c("SWIGFunction", class('cweeDateTime__SWIG_1'))

`cweeDateTime` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 0) {
    f <- cweeDateTime__SWIG_0; 
  } else if (argc == 1) {
    if ( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) {
      f <- cweeDateTime__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for cweeDateTime with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of cweeDateTime_unixTime_set

`cweeDateTime_unixTime_set` = function(self, s_unixTime)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_cweeDateTime_unixTime_set', self, s_unixTime, PACKAGE='Conv');
  
}

attr(`cweeDateTime_unixTime_set`, 'returnType') = 'void'
attr(`cweeDateTime_unixTime_set`, "inputTypes") = c('_p_cweeDateTime', 'numeric')
class(`cweeDateTime_unixTime_set`) = c("SWIGFunction", class('cweeDateTime_unixTime_set'))

# Start of cweeDateTime_unixTime_get

`cweeDateTime_unixTime_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_unixTime_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_unixTime_get`, 'returnType') = 'numeric'
attr(`cweeDateTime_unixTime_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_unixTime_get`) = c("SWIGFunction", class('cweeDateTime_unixTime_get'))

# Start of cweeDateTime_year_set

`cweeDateTime_year_set` = function(self, s_year)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_year = as.integer(s_year);
  
  if(length(s_year) > 1) {
    warning("using only the first element of s_year");
  };
  
  ;.Call('R_swig_cweeDateTime_year_set', self, s_year, PACKAGE='Conv');
  
}

attr(`cweeDateTime_year_set`, 'returnType') = 'void'
attr(`cweeDateTime_year_set`, "inputTypes") = c('_p_cweeDateTime', 'integer')
class(`cweeDateTime_year_set`) = c("SWIGFunction", class('cweeDateTime_year_set'))

# Start of cweeDateTime_year_get

`cweeDateTime_year_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_year_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_year_get`, 'returnType') = 'integer'
attr(`cweeDateTime_year_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_year_get`) = c("SWIGFunction", class('cweeDateTime_year_get'))

# Start of cweeDateTime_month_set

`cweeDateTime_month_set` = function(self, s_month)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_month = as.integer(s_month);
  
  if(length(s_month) > 1) {
    warning("using only the first element of s_month");
  };
  
  ;.Call('R_swig_cweeDateTime_month_set', self, s_month, PACKAGE='Conv');
  
}

attr(`cweeDateTime_month_set`, 'returnType') = 'void'
attr(`cweeDateTime_month_set`, "inputTypes") = c('_p_cweeDateTime', 'integer')
class(`cweeDateTime_month_set`) = c("SWIGFunction", class('cweeDateTime_month_set'))

# Start of cweeDateTime_month_get

`cweeDateTime_month_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_month_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_month_get`, 'returnType') = 'integer'
attr(`cweeDateTime_month_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_month_get`) = c("SWIGFunction", class('cweeDateTime_month_get'))

# Start of cweeDateTime_day_set

`cweeDateTime_day_set` = function(self, s_day)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_day = as.integer(s_day);
  
  if(length(s_day) > 1) {
    warning("using only the first element of s_day");
  };
  
  ;.Call('R_swig_cweeDateTime_day_set', self, s_day, PACKAGE='Conv');
  
}

attr(`cweeDateTime_day_set`, 'returnType') = 'void'
attr(`cweeDateTime_day_set`, "inputTypes") = c('_p_cweeDateTime', 'integer')
class(`cweeDateTime_day_set`) = c("SWIGFunction", class('cweeDateTime_day_set'))

# Start of cweeDateTime_day_get

`cweeDateTime_day_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_day_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_day_get`, 'returnType') = 'integer'
attr(`cweeDateTime_day_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_day_get`) = c("SWIGFunction", class('cweeDateTime_day_get'))

# Start of cweeDateTime_hour_set

`cweeDateTime_hour_set` = function(self, s_hour)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_hour = as.integer(s_hour);
  
  if(length(s_hour) > 1) {
    warning("using only the first element of s_hour");
  };
  
  ;.Call('R_swig_cweeDateTime_hour_set', self, s_hour, PACKAGE='Conv');
  
}

attr(`cweeDateTime_hour_set`, 'returnType') = 'void'
attr(`cweeDateTime_hour_set`, "inputTypes") = c('_p_cweeDateTime', 'integer')
class(`cweeDateTime_hour_set`) = c("SWIGFunction", class('cweeDateTime_hour_set'))

# Start of cweeDateTime_hour_get

`cweeDateTime_hour_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_hour_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_hour_get`, 'returnType') = 'integer'
attr(`cweeDateTime_hour_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_hour_get`) = c("SWIGFunction", class('cweeDateTime_hour_get'))

# Start of cweeDateTime_minute_set

`cweeDateTime_minute_set` = function(self, s_minute)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_minute = as.integer(s_minute);
  
  if(length(s_minute) > 1) {
    warning("using only the first element of s_minute");
  };
  
  ;.Call('R_swig_cweeDateTime_minute_set', self, s_minute, PACKAGE='Conv');
  
}

attr(`cweeDateTime_minute_set`, 'returnType') = 'void'
attr(`cweeDateTime_minute_set`, "inputTypes") = c('_p_cweeDateTime', 'integer')
class(`cweeDateTime_minute_set`) = c("SWIGFunction", class('cweeDateTime_minute_set'))

# Start of cweeDateTime_minute_get

`cweeDateTime_minute_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_minute_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_minute_get`, 'returnType') = 'integer'
attr(`cweeDateTime_minute_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_minute_get`) = c("SWIGFunction", class('cweeDateTime_minute_get'))

# Start of cweeDateTime_second_set

`cweeDateTime_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_second = as.integer(s_second);
  
  if(length(s_second) > 1) {
    warning("using only the first element of s_second");
  };
  
  ;.Call('R_swig_cweeDateTime_second_set', self, s_second, PACKAGE='Conv');
  
}

attr(`cweeDateTime_second_set`, 'returnType') = 'void'
attr(`cweeDateTime_second_set`, "inputTypes") = c('_p_cweeDateTime', 'integer')
class(`cweeDateTime_second_set`) = c("SWIGFunction", class('cweeDateTime_second_set'))

# Start of cweeDateTime_second_get

`cweeDateTime_second_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_second_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_second_get`, 'returnType') = 'integer'
attr(`cweeDateTime_second_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_second_get`) = c("SWIGFunction", class('cweeDateTime_second_get'))

# Start of cweeDateTime_milliseconds_set

`cweeDateTime_milliseconds_set` = function(self, s_milliseconds)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_milliseconds = as.integer(s_milliseconds);
  
  if(length(s_milliseconds) > 1) {
    warning("using only the first element of s_milliseconds");
  };
  
  ;.Call('R_swig_cweeDateTime_milliseconds_set', self, s_milliseconds, PACKAGE='Conv');
  
}

attr(`cweeDateTime_milliseconds_set`, 'returnType') = 'void'
attr(`cweeDateTime_milliseconds_set`, "inputTypes") = c('_p_cweeDateTime', 'integer')
class(`cweeDateTime_milliseconds_set`) = c("SWIGFunction", class('cweeDateTime_milliseconds_set'))

# Start of cweeDateTime_milliseconds_get

`cweeDateTime_milliseconds_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_cweeDateTime_milliseconds_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`cweeDateTime_milliseconds_get`, 'returnType') = 'integer'
attr(`cweeDateTime_milliseconds_get`, "inputTypes") = c('_p_cweeDateTime')
class(`cweeDateTime_milliseconds_get`) = c("SWIGFunction", class('cweeDateTime_milliseconds_get'))

# Start of delete_cweeDateTime

`delete_cweeDateTime` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_cweeDateTime', self, PACKAGE='Conv');
  
}

attr(`delete_cweeDateTime`, 'returnType') = 'void'
attr(`delete_cweeDateTime`, "inputTypes") = c('_p_cweeDateTime')
class(`delete_cweeDateTime`) = c("SWIGFunction", class('delete_cweeDateTime'))

# Start of accessor method for cweeDateTime
setMethod('$', '_p_cweeDateTime', function(x, name)

{
  accessorFuns = list('unixTime' = cweeDateTime_unixTime_get, 'year' = cweeDateTime_year_get, 'month' = cweeDateTime_month_get, 'day' = cweeDateTime_day_get, 'hour' = cweeDateTime_hour_get, 'minute' = cweeDateTime_minute_get, 'second' = cweeDateTime_second_get, 'milliseconds' = cweeDateTime_milliseconds_get);
  vaccessors = c('unixTime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'milliseconds');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cweeDateTime
# Start of accessor method for cweeDateTime
setMethod('$<-', '_p_cweeDateTime', function(x, name, value)

{
  accessorFuns = list('unixTime' = cweeDateTime_unixTime_set, 'year' = cweeDateTime_year_set, 'month' = cweeDateTime_month_set, 'day' = cweeDateTime_day_set, 'hour' = cweeDateTime_hour_set, 'minute' = cweeDateTime_minute_set, 'second' = cweeDateTime_second_set, 'milliseconds' = cweeDateTime_milliseconds_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cweeDateTime', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('unixTime' = cweeDateTime_unixTime_set, 'year' = cweeDateTime_year_set, 'month' = cweeDateTime_month_set, 'day' = cweeDateTime_day_set, 'hour' = cweeDateTime_hour_set, 'minute' = cweeDateTime_minute_set, 'second' = cweeDateTime_second_set, 'milliseconds' = cweeDateTime_milliseconds_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cweeDateTime
setMethod('delete', '_p_cweeDateTime', function(obj) {delete_cweeDateTime(obj)})
# Start of new_Awaiter

`Awaiter` = function()
{
  ;ans = .Call('R_swig_new_Awaiter', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Awaiter", ref=ans);
  
  reg.finalizer(ans@ref, delete_Awaiter);
  ans
  
}

attr(`Awaiter`, 'returnType') = '_p_Awaiter'
class(`Awaiter`) = c("SWIGFunction", class('Awaiter'))

# Start of Awaiter_IsFinished

`Awaiter_IsFinished` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Awaiter_IsFinished', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`Awaiter_IsFinished`, 'returnType') = 'logical'
attr(`Awaiter_IsFinished`, "inputTypes") = c('_p_Awaiter')
class(`Awaiter_IsFinished`) = c("SWIGFunction", class('Awaiter_IsFinished'))

# Start of Awaiter_Result

`Awaiter_Result` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Awaiter_Result', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`Awaiter_Result`, 'returnType') = 'character'
attr(`Awaiter_Result`, "inputTypes") = c('_p_Awaiter')
class(`Awaiter_Result`) = c("SWIGFunction", class('Awaiter_Result'))

# Start of Awaiter_data_m_set

`Awaiter_data_m_set` = function(self, s_data_m)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_data_m, "ExternalReference")) s_data_m = slot(s_data_m,"ref"); 
  ;.Call('R_swig_Awaiter_data_m_set', self, s_data_m, PACKAGE='Conv');
  
}

attr(`Awaiter_data_m_set`, 'returnType') = 'void'
attr(`Awaiter_data_m_set`, "inputTypes") = c('_p_Awaiter', '_p_std__shared_ptrT_std__string_t')
class(`Awaiter_data_m_set`) = c("SWIGFunction", class('Awaiter_data_m_set'))

# Start of Awaiter_data_m_get

`Awaiter_data_m_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Awaiter_data_m_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__shared_ptrT_std__string_t", ref=ans);
  
  ans
  
}

attr(`Awaiter_data_m_get`, 'returnType') = '_p_std__shared_ptrT_std__string_t'
attr(`Awaiter_data_m_get`, "inputTypes") = c('_p_Awaiter')
class(`Awaiter_data_m_get`) = c("SWIGFunction", class('Awaiter_data_m_get'))

# Start of Awaiter_isFinished_m_set

`Awaiter_isFinished_m_set` = function(self, s_isFinished_m)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_isFinished_m, "ExternalReference")) s_isFinished_m = slot(s_isFinished_m,"ref"); 
  ;.Call('R_swig_Awaiter_isFinished_m_set', self, s_isFinished_m, PACKAGE='Conv');
  
}

attr(`Awaiter_isFinished_m_set`, 'returnType') = 'void'
attr(`Awaiter_isFinished_m_set`, "inputTypes") = c('_p_Awaiter', '_p_std__shared_ptrT_bool_t')
class(`Awaiter_isFinished_m_set`) = c("SWIGFunction", class('Awaiter_isFinished_m_set'))

# Start of Awaiter_isFinished_m_get

`Awaiter_isFinished_m_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Awaiter_isFinished_m_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__shared_ptrT_bool_t", ref=ans);
  
  ans
  
}

attr(`Awaiter_isFinished_m_get`, 'returnType') = '_p_std__shared_ptrT_bool_t'
attr(`Awaiter_isFinished_m_get`, "inputTypes") = c('_p_Awaiter')
class(`Awaiter_isFinished_m_get`) = c("SWIGFunction", class('Awaiter_isFinished_m_get'))

# Start of delete_Awaiter

`delete_Awaiter` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Awaiter', self, PACKAGE='Conv');
  
}

attr(`delete_Awaiter`, 'returnType') = 'void'
attr(`delete_Awaiter`, "inputTypes") = c('_p_Awaiter')
class(`delete_Awaiter`) = c("SWIGFunction", class('delete_Awaiter'))

# Start of accessor method for Awaiter
setMethod('$', '_p_Awaiter', function(x, name)

{
  accessorFuns = list('IsFinished' = Awaiter_IsFinished, 'Result' = Awaiter_Result, 'data_m' = Awaiter_data_m_get, 'isFinished_m' = Awaiter_isFinished_m_get);
  vaccessors = c('data_m', 'isFinished_m');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Awaiter
# Start of accessor method for Awaiter
setMethod('$<-', '_p_Awaiter', function(x, name, value)

{
  accessorFuns = list('data_m' = Awaiter_data_m_set, 'isFinished_m' = Awaiter_isFinished_m_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Awaiter', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data_m' = Awaiter_data_m_set, 'isFinished_m' = Awaiter_isFinished_m_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Awaiter
setMethod('delete', '_p_Awaiter', function(obj) {delete_Awaiter(obj)})
# Start of new_SharedMatrix

`SharedMatrix__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_SharedMatrix__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedMatrix", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedMatrix);
  ans
  
}

attr(`SharedMatrix__SWIG_0`, 'returnType') = '_p_SharedMatrix'
class(`SharedMatrix__SWIG_0`) = c("SWIGFunction", class('SharedMatrix__SWIG_0'))

# Start of new_SharedMatrix

`SharedMatrix__SWIG_1` = function(index, deleteDataWhenScopeEnds)
{
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  deleteDataWhenScopeEnds = as.logical(deleteDataWhenScopeEnds);
  ;ans = .Call('R_swig_new_SharedMatrix__SWIG_1', index, deleteDataWhenScopeEnds, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedMatrix", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedMatrix);
  ans
  
}

attr(`SharedMatrix__SWIG_1`, 'returnType') = '_p_SharedMatrix'
attr(`SharedMatrix__SWIG_1`, "inputTypes") = c('integer', 'logical')
class(`SharedMatrix__SWIG_1`) = c("SWIGFunction", class('SharedMatrix__SWIG_1'))

# Start of new_SharedMatrix

`SharedMatrix__SWIG_2` = function(index)
{
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  ;ans = .Call('R_swig_new_SharedMatrix__SWIG_2', index, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedMatrix", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedMatrix);
  ans
  
}

attr(`SharedMatrix__SWIG_2`, 'returnType') = '_p_SharedMatrix'
attr(`SharedMatrix__SWIG_2`, "inputTypes") = c('integer')
class(`SharedMatrix__SWIG_2`) = c("SWIGFunction", class('SharedMatrix__SWIG_2'))

# Start of new_SharedMatrix

`SharedMatrix__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_SharedMatrix__SWIG_3', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedMatrix", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedMatrix);
  ans
  
}

attr(`SharedMatrix__SWIG_3`, 'returnType') = '_p_SharedMatrix'
attr(`SharedMatrix__SWIG_3`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix__SWIG_3`) = c("SWIGFunction", class('SharedMatrix__SWIG_3'))

`SharedMatrix` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- SharedMatrix__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_SharedMatrix') && length(argv[[1]]) == 1 ) {
      f <- SharedMatrix__SWIG_3; 
    }
    else if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- SharedMatrix__SWIG_2; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- SharedMatrix__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for SharedMatrix with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SharedMatrix

`delete_SharedMatrix` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_SharedMatrix', self, PACKAGE='Conv');
  
}

attr(`delete_SharedMatrix`, 'returnType') = 'void'
attr(`delete_SharedMatrix`, "inputTypes") = c('_p_SharedMatrix')
class(`delete_SharedMatrix`) = c("SWIGFunction", class('delete_SharedMatrix'))

# Start of SharedMatrix_Clear

`SharedMatrix_Clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_Clear', self, PACKAGE='Conv');
  
}

attr(`SharedMatrix_Clear`, 'returnType') = 'void'
attr(`SharedMatrix_Clear`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_Clear`) = c("SWIGFunction", class('SharedMatrix_Clear'))

# Start of SharedMatrix_AppendData

`SharedMatrix_AppendData` = function(self, X, Y, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  
  
  ;.Call('R_swig_SharedMatrix_AppendData', self, X, Y, value, PACKAGE='Conv');
  
}

attr(`SharedMatrix_AppendData`, 'returnType') = 'void'
attr(`SharedMatrix_AppendData`, "inputTypes") = c('_p_SharedMatrix', 'numeric', 'numeric', 'numeric')
class(`SharedMatrix_AppendData`) = c("SWIGFunction", class('SharedMatrix_AppendData'))

# Start of SharedMatrix_GetValue

`SharedMatrix_GetValue` = function(self, X, Y, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  
  ;.Call('R_swig_SharedMatrix_GetValue', self, X, Y, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetValue`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetValue`, "inputTypes") = c('_p_SharedMatrix', 'numeric', 'numeric')
class(`SharedMatrix_GetValue`) = c("SWIGFunction", class('SharedMatrix_GetValue'))

# Start of SharedMatrix_GetKnotSeries

`SharedMatrix_GetKnotSeries` = function(self, Left, Top, Right, Bottom, numColumns, numRows, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  
  
  
  numColumns = as.integer(numColumns);
  
  if(length(numColumns) > 1) {
    warning("using only the first element of numColumns");
  };
  
  numRows = as.integer(numRows);
  
  if(length(numRows) > 1) {
    warning("using only the first element of numRows");
  };
  
  ;.Call('R_swig_SharedMatrix_GetKnotSeries', self, Left, Top, Right, Bottom, numColumns, numRows, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetKnotSeries`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetKnotSeries`, "inputTypes") = c('_p_SharedMatrix', 'numeric', 'numeric', 'numeric', 'numeric', 'integer', 'integer')
class(`SharedMatrix_GetKnotSeries`) = c("SWIGFunction", class('SharedMatrix_GetKnotSeries'))

# Start of SharedMatrix_GetTimeSeries

`SharedMatrix_GetTimeSeries` = function(self, Left, Top, Right, Bottom, numColumns, numRows, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  
  
  
  numColumns = as.integer(numColumns);
  
  if(length(numColumns) > 1) {
    warning("using only the first element of numColumns");
  };
  
  numRows = as.integer(numRows);
  
  if(length(numRows) > 1) {
    warning("using only the first element of numRows");
  };
  
  ;.Call('R_swig_SharedMatrix_GetTimeSeries', self, Left, Top, Right, Bottom, numColumns, numRows, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetTimeSeries`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetTimeSeries`, "inputTypes") = c('_p_SharedMatrix', 'numeric', 'numeric', 'numeric', 'numeric', 'integer', 'integer')
class(`SharedMatrix_GetTimeSeries`) = c("SWIGFunction", class('SharedMatrix_GetTimeSeries'))

# Start of SharedMatrix_GetMinX

`SharedMatrix_GetMinX` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_GetMinX', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetMinX`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetMinX`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_GetMinX`) = c("SWIGFunction", class('SharedMatrix_GetMinX'))

# Start of SharedMatrix_GetMaxX

`SharedMatrix_GetMaxX` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_GetMaxX', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetMaxX`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetMaxX`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_GetMaxX`) = c("SWIGFunction", class('SharedMatrix_GetMaxX'))

# Start of SharedMatrix_GetMinY

`SharedMatrix_GetMinY` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_GetMinY', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetMinY`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetMinY`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_GetMinY`) = c("SWIGFunction", class('SharedMatrix_GetMinY'))

# Start of SharedMatrix_GetMaxY

`SharedMatrix_GetMaxY` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_GetMaxY', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetMaxY`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetMaxY`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_GetMaxY`) = c("SWIGFunction", class('SharedMatrix_GetMaxY'))

# Start of SharedMatrix_GetMinValue

`SharedMatrix_GetMinValue` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_GetMinValue', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetMinValue`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetMinValue`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_GetMinValue`) = c("SWIGFunction", class('SharedMatrix_GetMinValue'))

# Start of SharedMatrix_GetMaxValue

`SharedMatrix_GetMaxValue` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_GetMaxValue', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetMaxValue`, 'returnType') = 'numeric'
attr(`SharedMatrix_GetMaxValue`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_GetMaxValue`) = c("SWIGFunction", class('SharedMatrix_GetMaxValue'))

# Start of SharedMatrix_GetNumValues

`SharedMatrix_GetNumValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_GetNumValues', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_GetNumValues`, 'returnType') = 'integer'
attr(`SharedMatrix_GetNumValues`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_GetNumValues`) = c("SWIGFunction", class('SharedMatrix_GetNumValues'))

# Start of SharedMatrix_Index

`SharedMatrix_Index` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedMatrix_Index', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedMatrix_Index`, 'returnType') = 'integer'
attr(`SharedMatrix_Index`, "inputTypes") = c('_p_SharedMatrix')
class(`SharedMatrix_Index`) = c("SWIGFunction", class('SharedMatrix_Index'))

# Start of accessor method for SharedMatrix
setMethod('$', '_p_SharedMatrix', function(x, name)

{
  accessorFuns = list('Clear' = SharedMatrix_Clear, 'AppendData' = SharedMatrix_AppendData, 'GetValue' = SharedMatrix_GetValue, 'GetKnotSeries' = SharedMatrix_GetKnotSeries, 'GetTimeSeries' = SharedMatrix_GetTimeSeries, 'GetMinX' = SharedMatrix_GetMinX, 'GetMaxX' = SharedMatrix_GetMaxX, 'GetMinY' = SharedMatrix_GetMinY, 'GetMaxY' = SharedMatrix_GetMaxY, 'GetMinValue' = SharedMatrix_GetMinValue, 'GetMaxValue' = SharedMatrix_GetMaxValue, 'GetNumValues' = SharedMatrix_GetNumValues, 'Index' = SharedMatrix_Index);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for SharedMatrix
setMethod('delete', '_p_SharedMatrix', function(obj) {delete_SharedMatrix(obj)})
# Start of new_SharedTimeSeriesPattern

`SharedTimeSeriesPattern__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_SharedTimeSeriesPattern__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedTimeSeriesPattern", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedTimeSeriesPattern);
  ans
  
}

attr(`SharedTimeSeriesPattern__SWIG_0`, 'returnType') = '_p_SharedTimeSeriesPattern'
class(`SharedTimeSeriesPattern__SWIG_0`) = c("SWIGFunction", class('SharedTimeSeriesPattern__SWIG_0'))

# Start of new_SharedTimeSeriesPattern

`SharedTimeSeriesPattern__SWIG_1` = function(index, deleteDataWhenScopeEnds)
{
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  deleteDataWhenScopeEnds = as.logical(deleteDataWhenScopeEnds);
  ;ans = .Call('R_swig_new_SharedTimeSeriesPattern__SWIG_1', index, deleteDataWhenScopeEnds, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedTimeSeriesPattern", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedTimeSeriesPattern);
  ans
  
}

attr(`SharedTimeSeriesPattern__SWIG_1`, 'returnType') = '_p_SharedTimeSeriesPattern'
attr(`SharedTimeSeriesPattern__SWIG_1`, "inputTypes") = c('integer', 'logical')
class(`SharedTimeSeriesPattern__SWIG_1`) = c("SWIGFunction", class('SharedTimeSeriesPattern__SWIG_1'))

# Start of new_SharedTimeSeriesPattern

`SharedTimeSeriesPattern__SWIG_2` = function(index)
{
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  ;ans = .Call('R_swig_new_SharedTimeSeriesPattern__SWIG_2', index, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedTimeSeriesPattern", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedTimeSeriesPattern);
  ans
  
}

attr(`SharedTimeSeriesPattern__SWIG_2`, 'returnType') = '_p_SharedTimeSeriesPattern'
attr(`SharedTimeSeriesPattern__SWIG_2`, "inputTypes") = c('integer')
class(`SharedTimeSeriesPattern__SWIG_2`) = c("SWIGFunction", class('SharedTimeSeriesPattern__SWIG_2'))

`SharedTimeSeriesPattern` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 3
  if (argc == 0) {
    f <- SharedTimeSeriesPattern__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- SharedTimeSeriesPattern__SWIG_2; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- SharedTimeSeriesPattern__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for SharedTimeSeriesPattern with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SharedTimeSeriesPattern

`delete_SharedTimeSeriesPattern` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_SharedTimeSeriesPattern', self, PACKAGE='Conv');
  
}

attr(`delete_SharedTimeSeriesPattern`, 'returnType') = 'void'
attr(`delete_SharedTimeSeriesPattern`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`delete_SharedTimeSeriesPattern`) = c("SWIGFunction", class('delete_SharedTimeSeriesPattern'))

# Start of SharedTimeSeriesPattern_Clear

`SharedTimeSeriesPattern_Clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedTimeSeriesPattern_Clear', self, PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_Clear`, 'returnType') = 'void'
attr(`SharedTimeSeriesPattern_Clear`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_Clear`) = c("SWIGFunction", class('SharedTimeSeriesPattern_Clear'))

# Start of SharedTimeSeriesPattern_AppendData

`SharedTimeSeriesPattern_AppendData` = function(self, time, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  
  ;.Call('R_swig_SharedTimeSeriesPattern_AppendData', self, time, value, PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_AppendData`, 'returnType') = 'void'
attr(`SharedTimeSeriesPattern_AppendData`, "inputTypes") = c('_p_SharedTimeSeriesPattern', 'numeric', 'numeric')
class(`SharedTimeSeriesPattern_AppendData`) = c("SWIGFunction", class('SharedTimeSeriesPattern_AppendData'))

# Start of SharedTimeSeriesPattern_GetValue

`SharedTimeSeriesPattern_GetValue` = function(self, time, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_SharedTimeSeriesPattern_GetValue', self, time, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_GetValue`, 'returnType') = 'numeric'
attr(`SharedTimeSeriesPattern_GetValue`, "inputTypes") = c('_p_SharedTimeSeriesPattern', 'numeric')
class(`SharedTimeSeriesPattern_GetValue`) = c("SWIGFunction", class('SharedTimeSeriesPattern_GetValue'))

# Start of SharedTimeSeriesPattern_GetAvgValue

`SharedTimeSeriesPattern_GetAvgValue` = function(self, time1, time2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  
  ;.Call('R_swig_SharedTimeSeriesPattern_GetAvgValue', self, time1, time2, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_GetAvgValue`, 'returnType') = 'numeric'
attr(`SharedTimeSeriesPattern_GetAvgValue`, "inputTypes") = c('_p_SharedTimeSeriesPattern', 'numeric', 'numeric')
class(`SharedTimeSeriesPattern_GetAvgValue`) = c("SWIGFunction", class('SharedTimeSeriesPattern_GetAvgValue'))

# Start of SharedTimeSeriesPattern_GetTimeSeries

`SharedTimeSeriesPattern_GetTimeSeries` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_SharedTimeSeriesPattern_GetTimeSeries', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`SharedTimeSeriesPattern_GetTimeSeries`, 'returnType') = '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t'
attr(`SharedTimeSeriesPattern_GetTimeSeries`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_GetTimeSeries`) = c("SWIGFunction", class('SharedTimeSeriesPattern_GetTimeSeries'))

# Start of SharedTimeSeriesPattern_GetMinTime

`SharedTimeSeriesPattern_GetMinTime` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedTimeSeriesPattern_GetMinTime', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_GetMinTime`, 'returnType') = 'numeric'
attr(`SharedTimeSeriesPattern_GetMinTime`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_GetMinTime`) = c("SWIGFunction", class('SharedTimeSeriesPattern_GetMinTime'))

# Start of SharedTimeSeriesPattern_GetMaxTime

`SharedTimeSeriesPattern_GetMaxTime` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedTimeSeriesPattern_GetMaxTime', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_GetMaxTime`, 'returnType') = 'numeric'
attr(`SharedTimeSeriesPattern_GetMaxTime`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_GetMaxTime`) = c("SWIGFunction", class('SharedTimeSeriesPattern_GetMaxTime'))

# Start of SharedTimeSeriesPattern_GetNumValues

`SharedTimeSeriesPattern_GetNumValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedTimeSeriesPattern_GetNumValues', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_GetNumValues`, 'returnType') = 'integer'
attr(`SharedTimeSeriesPattern_GetNumValues`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_GetNumValues`) = c("SWIGFunction", class('SharedTimeSeriesPattern_GetNumValues'))

# Start of SharedTimeSeriesPattern_GetInterpolationType

`SharedTimeSeriesPattern_GetInterpolationType` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_SharedTimeSeriesPattern_GetInterpolationType', self, as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_uwp_patternInterpType");
  
  ans
  
}

attr(`SharedTimeSeriesPattern_GetInterpolationType`, 'returnType') = 'character'
attr(`SharedTimeSeriesPattern_GetInterpolationType`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_GetInterpolationType`) = c("SWIGFunction", class('SharedTimeSeriesPattern_GetInterpolationType'))

# Start of SharedTimeSeriesPattern_X_Units

`SharedTimeSeriesPattern_X_Units` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedTimeSeriesPattern_X_Units', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_X_Units`, 'returnType') = 'character'
attr(`SharedTimeSeriesPattern_X_Units`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_X_Units`) = c("SWIGFunction", class('SharedTimeSeriesPattern_X_Units'))

# Start of SharedTimeSeriesPattern_Y_Units

`SharedTimeSeriesPattern_Y_Units` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedTimeSeriesPattern_Y_Units', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_Y_Units`, 'returnType') = 'character'
attr(`SharedTimeSeriesPattern_Y_Units`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_Y_Units`) = c("SWIGFunction", class('SharedTimeSeriesPattern_Y_Units'))

# Start of SharedTimeSeriesPattern_Index

`SharedTimeSeriesPattern_Index` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedTimeSeriesPattern_Index', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedTimeSeriesPattern_Index`, 'returnType') = 'integer'
attr(`SharedTimeSeriesPattern_Index`, "inputTypes") = c('_p_SharedTimeSeriesPattern')
class(`SharedTimeSeriesPattern_Index`) = c("SWIGFunction", class('SharedTimeSeriesPattern_Index'))

# Start of accessor method for SharedTimeSeriesPattern
setMethod('$', '_p_SharedTimeSeriesPattern', function(x, name)

{
  accessorFuns = list('Clear' = SharedTimeSeriesPattern_Clear, 'AppendData' = SharedTimeSeriesPattern_AppendData, 'GetValue' = SharedTimeSeriesPattern_GetValue, 'GetAvgValue' = SharedTimeSeriesPattern_GetAvgValue, 'GetTimeSeries' = SharedTimeSeriesPattern_GetTimeSeries, 'GetMinTime' = SharedTimeSeriesPattern_GetMinTime, 'GetMaxTime' = SharedTimeSeriesPattern_GetMaxTime, 'GetNumValues' = SharedTimeSeriesPattern_GetNumValues, 'GetInterpolationType' = SharedTimeSeriesPattern_GetInterpolationType, 'X_Units' = SharedTimeSeriesPattern_X_Units, 'Y_Units' = SharedTimeSeriesPattern_Y_Units, 'Index' = SharedTimeSeriesPattern_Index);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for SharedTimeSeriesPattern
setMethod('delete', '_p_SharedTimeSeriesPattern', function(obj) {delete_SharedTimeSeriesPattern(obj)})
# Start of new_SharedString

`SharedString__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_SharedString__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedString", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedString);
  ans
  
}

attr(`SharedString__SWIG_0`, 'returnType') = '_p_SharedString'
class(`SharedString__SWIG_0`) = c("SWIGFunction", class('SharedString__SWIG_0'))

# Start of new_SharedString

`SharedString__SWIG_1` = function(index, deleteDataWhenScopeEnds)
{
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  deleteDataWhenScopeEnds = as.logical(deleteDataWhenScopeEnds);
  ;ans = .Call('R_swig_new_SharedString__SWIG_1', index, deleteDataWhenScopeEnds, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedString", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedString);
  ans
  
}

attr(`SharedString__SWIG_1`, 'returnType') = '_p_SharedString'
attr(`SharedString__SWIG_1`, "inputTypes") = c('integer', 'logical')
class(`SharedString__SWIG_1`) = c("SWIGFunction", class('SharedString__SWIG_1'))

# Start of new_SharedString

`SharedString__SWIG_2` = function(index)
{
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  ;ans = .Call('R_swig_new_SharedString__SWIG_2', index, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_SharedString", ref=ans);
  
  reg.finalizer(ans@ref, delete_SharedString);
  ans
  
}

attr(`SharedString__SWIG_2`, 'returnType') = '_p_SharedString'
attr(`SharedString__SWIG_2`, "inputTypes") = c('integer')
class(`SharedString__SWIG_2`) = c("SWIGFunction", class('SharedString__SWIG_2'))

`SharedString` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 3
  if (argc == 0) {
    f <- SharedString__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- SharedString__SWIG_2; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- SharedString__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for SharedString with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SharedString

`delete_SharedString` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_SharedString', self, PACKAGE='Conv');
  
}

attr(`delete_SharedString`, 'returnType') = 'void'
attr(`delete_SharedString`, "inputTypes") = c('_p_SharedString')
class(`delete_SharedString`) = c("SWIGFunction", class('delete_SharedString'))

# Start of SharedString_Set

`SharedString_Set` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  v = as(v, "character"); 
  ;.Call('R_swig_SharedString_Set', self, v, PACKAGE='Conv');
  
}

attr(`SharedString_Set`, 'returnType') = 'void'
attr(`SharedString_Set`, "inputTypes") = c('_p_SharedString', 'character')
class(`SharedString_Set`) = c("SWIGFunction", class('SharedString_Set'))

# Start of SharedString_Get

`SharedString_Get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedString_Get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedString_Get`, 'returnType') = 'character'
attr(`SharedString_Get`, "inputTypes") = c('_p_SharedString')
class(`SharedString_Get`) = c("SWIGFunction", class('SharedString_Get'))

# Start of SharedString_Index

`SharedString_Index` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_SharedString_Index', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`SharedString_Index`, 'returnType') = 'integer'
attr(`SharedString_Index`, "inputTypes") = c('_p_SharedString')
class(`SharedString_Index`) = c("SWIGFunction", class('SharedString_Index'))

# Start of accessor method for SharedString
setMethod('$', '_p_SharedString', function(x, name)

{
  accessorFuns = list('Set' = SharedString_Set, 'Get' = SharedString_Get, 'Index' = SharedString_Index);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for SharedString
setMethod('delete', '_p_SharedString', function(obj) {delete_SharedString(obj)})
# Start of new_WaterWatchEnums

`WaterWatchEnums` = function()
{
  ;ans = .Call('R_swig_new_WaterWatchEnums', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_WaterWatchEnums", ref=ans);
  
  reg.finalizer(ans@ref, delete_WaterWatchEnums);
  ans
  
}

attr(`WaterWatchEnums`, 'returnType') = '_p_WaterWatchEnums'
class(`WaterWatchEnums`) = c("SWIGFunction", class('WaterWatchEnums'))

# Start of delete_WaterWatchEnums

`delete_WaterWatchEnums` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_WaterWatchEnums', self, PACKAGE='Conv');
  
}

attr(`delete_WaterWatchEnums`, 'returnType') = 'void'
attr(`delete_WaterWatchEnums`, "inputTypes") = c('_p_WaterWatchEnums')
class(`delete_WaterWatchEnums`) = c("SWIGFunction", class('delete_WaterWatchEnums'))

# Start of WaterWatchEnums_Id_get

`WaterWatchEnums_Id_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Id_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Id_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Id_get`) = c("SWIGFunction", class('WaterWatchEnums_Id_get'))

# Start of WaterWatchEnums_Fun_Call_get

`WaterWatchEnums_Fun_Call_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Fun_Call_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Fun_Call_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Fun_Call_get`) = c("SWIGFunction", class('WaterWatchEnums_Fun_Call_get'))

# Start of WaterWatchEnums_Unused_Return_Fun_Call_get

`WaterWatchEnums_Unused_Return_Fun_Call_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Unused_Return_Fun_Call_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Unused_Return_Fun_Call_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Unused_Return_Fun_Call_get`) = c("SWIGFunction", class('WaterWatchEnums_Unused_Return_Fun_Call_get'))

# Start of WaterWatchEnums_Arg_List_get

`WaterWatchEnums_Arg_List_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Arg_List_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Arg_List_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Arg_List_get`) = c("SWIGFunction", class('WaterWatchEnums_Arg_List_get'))

# Start of WaterWatchEnums_Equation_get

`WaterWatchEnums_Equation_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Equation_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Equation_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Equation_get`) = c("SWIGFunction", class('WaterWatchEnums_Equation_get'))

# Start of WaterWatchEnums_Var_Decl_get

`WaterWatchEnums_Var_Decl_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Var_Decl_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Var_Decl_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Var_Decl_get`) = c("SWIGFunction", class('WaterWatchEnums_Var_Decl_get'))

# Start of WaterWatchEnums_Assign_Decl_get

`WaterWatchEnums_Assign_Decl_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Assign_Decl_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Assign_Decl_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Assign_Decl_get`) = c("SWIGFunction", class('WaterWatchEnums_Assign_Decl_get'))

# Start of WaterWatchEnums_Array_Call_get

`WaterWatchEnums_Array_Call_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Array_Call_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Array_Call_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Array_Call_get`) = c("SWIGFunction", class('WaterWatchEnums_Array_Call_get'))

# Start of WaterWatchEnums_Dot_Access_get

`WaterWatchEnums_Dot_Access_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Dot_Access_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Dot_Access_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Dot_Access_get`) = c("SWIGFunction", class('WaterWatchEnums_Dot_Access_get'))

# Start of WaterWatchEnums_Lambda_get

`WaterWatchEnums_Lambda_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Lambda_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Lambda_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Lambda_get`) = c("SWIGFunction", class('WaterWatchEnums_Lambda_get'))

# Start of WaterWatchEnums_Block_get

`WaterWatchEnums_Block_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Block_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Block_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Block_get`) = c("SWIGFunction", class('WaterWatchEnums_Block_get'))

# Start of WaterWatchEnums_Scopeless_Block_get

`WaterWatchEnums_Scopeless_Block_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Scopeless_Block_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Scopeless_Block_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Scopeless_Block_get`) = c("SWIGFunction", class('WaterWatchEnums_Scopeless_Block_get'))

# Start of WaterWatchEnums_Def_get

`WaterWatchEnums_Def_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Def_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Def_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Def_get`) = c("SWIGFunction", class('WaterWatchEnums_Def_get'))

# Start of WaterWatchEnums_While_get

`WaterWatchEnums_While_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_While_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_While_get`, 'returnType') = 'character'
class(`WaterWatchEnums_While_get`) = c("SWIGFunction", class('WaterWatchEnums_While_get'))

# Start of WaterWatchEnums_If_get

`WaterWatchEnums_If_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_If_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_If_get`, 'returnType') = 'character'
class(`WaterWatchEnums_If_get`) = c("SWIGFunction", class('WaterWatchEnums_If_get'))

# Start of WaterWatchEnums_For_get

`WaterWatchEnums_For_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_For_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_For_get`, 'returnType') = 'character'
class(`WaterWatchEnums_For_get`) = c("SWIGFunction", class('WaterWatchEnums_For_get'))

# Start of WaterWatchEnums_Ranged_For_get

`WaterWatchEnums_Ranged_For_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Ranged_For_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Ranged_For_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Ranged_For_get`) = c("SWIGFunction", class('WaterWatchEnums_Ranged_For_get'))

# Start of WaterWatchEnums_Inline_Array_get

`WaterWatchEnums_Inline_Array_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Inline_Array_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Inline_Array_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Inline_Array_get`) = c("SWIGFunction", class('WaterWatchEnums_Inline_Array_get'))

# Start of WaterWatchEnums_Inline_Map_get

`WaterWatchEnums_Inline_Map_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Inline_Map_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Inline_Map_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Inline_Map_get`) = c("SWIGFunction", class('WaterWatchEnums_Inline_Map_get'))

# Start of WaterWatchEnums_Return_get

`WaterWatchEnums_Return_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Return_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Return_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Return_get`) = c("SWIGFunction", class('WaterWatchEnums_Return_get'))

# Start of WaterWatchEnums_File_get

`WaterWatchEnums_File_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_File_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_File_get`, 'returnType') = 'character'
class(`WaterWatchEnums_File_get`) = c("SWIGFunction", class('WaterWatchEnums_File_get'))

# Start of WaterWatchEnums_Prefix_get

`WaterWatchEnums_Prefix_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Prefix_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Prefix_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Prefix_get`) = c("SWIGFunction", class('WaterWatchEnums_Prefix_get'))

# Start of WaterWatchEnums_Break_get

`WaterWatchEnums_Break_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Break_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Break_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Break_get`) = c("SWIGFunction", class('WaterWatchEnums_Break_get'))

# Start of WaterWatchEnums_Continue_get

`WaterWatchEnums_Continue_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Continue_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Continue_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Continue_get`) = c("SWIGFunction", class('WaterWatchEnums_Continue_get'))

# Start of WaterWatchEnums_Map_Pair_get

`WaterWatchEnums_Map_Pair_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Map_Pair_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Map_Pair_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Map_Pair_get`) = c("SWIGFunction", class('WaterWatchEnums_Map_Pair_get'))

# Start of WaterWatchEnums_Value_Range_get

`WaterWatchEnums_Value_Range_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Value_Range_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Value_Range_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Value_Range_get`) = c("SWIGFunction", class('WaterWatchEnums_Value_Range_get'))

# Start of WaterWatchEnums_Inline_Range_get

`WaterWatchEnums_Inline_Range_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Inline_Range_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Inline_Range_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Inline_Range_get`) = c("SWIGFunction", class('WaterWatchEnums_Inline_Range_get'))

# Start of WaterWatchEnums_Do_get

`WaterWatchEnums_Do_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Do_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Do_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Do_get`) = c("SWIGFunction", class('WaterWatchEnums_Do_get'))

# Start of WaterWatchEnums_Try_get

`WaterWatchEnums_Try_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Try_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Try_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Try_get`) = c("SWIGFunction", class('WaterWatchEnums_Try_get'))

# Start of WaterWatchEnums_Catch_get

`WaterWatchEnums_Catch_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Catch_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Catch_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Catch_get`) = c("SWIGFunction", class('WaterWatchEnums_Catch_get'))

# Start of WaterWatchEnums_Finally_get

`WaterWatchEnums_Finally_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Finally_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Finally_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Finally_get`) = c("SWIGFunction", class('WaterWatchEnums_Finally_get'))

# Start of WaterWatchEnums_Method_get

`WaterWatchEnums_Method_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Method_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Method_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Method_get`) = c("SWIGFunction", class('WaterWatchEnums_Method_get'))

# Start of WaterWatchEnums_Attr_Decl_get

`WaterWatchEnums_Attr_Decl_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Attr_Decl_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Attr_Decl_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Attr_Decl_get`) = c("SWIGFunction", class('WaterWatchEnums_Attr_Decl_get'))

# Start of WaterWatchEnums_Logical_And_get

`WaterWatchEnums_Logical_And_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Logical_And_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Logical_And_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Logical_And_get`) = c("SWIGFunction", class('WaterWatchEnums_Logical_And_get'))

# Start of WaterWatchEnums_Logical_Or_get

`WaterWatchEnums_Logical_Or_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Logical_Or_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Logical_Or_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Logical_Or_get`) = c("SWIGFunction", class('WaterWatchEnums_Logical_Or_get'))

# Start of WaterWatchEnums_Reference_get

`WaterWatchEnums_Reference_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Reference_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Reference_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Reference_get`) = c("SWIGFunction", class('WaterWatchEnums_Reference_get'))

# Start of WaterWatchEnums_Switch_get

`WaterWatchEnums_Switch_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Switch_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Switch_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Switch_get`) = c("SWIGFunction", class('WaterWatchEnums_Switch_get'))

# Start of WaterWatchEnums_Case_get

`WaterWatchEnums_Case_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Case_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Case_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Case_get`) = c("SWIGFunction", class('WaterWatchEnums_Case_get'))

# Start of WaterWatchEnums_Default_get

`WaterWatchEnums_Default_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Default_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Default_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Default_get`) = c("SWIGFunction", class('WaterWatchEnums_Default_get'))

# Start of WaterWatchEnums_Noop_get

`WaterWatchEnums_Noop_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Noop_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Noop_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Noop_get`) = c("SWIGFunction", class('WaterWatchEnums_Noop_get'))

# Start of WaterWatchEnums_Class_get

`WaterWatchEnums_Class_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Class_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Class_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Class_get`) = c("SWIGFunction", class('WaterWatchEnums_Class_get'))

# Start of WaterWatchEnums_Binary_get

`WaterWatchEnums_Binary_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Binary_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Binary_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Binary_get`) = c("SWIGFunction", class('WaterWatchEnums_Binary_get'))

# Start of WaterWatchEnums_Arg_get

`WaterWatchEnums_Arg_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Arg_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Arg_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Arg_get`) = c("SWIGFunction", class('WaterWatchEnums_Arg_get'))

# Start of WaterWatchEnums_Global_Decl_get

`WaterWatchEnums_Global_Decl_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Global_Decl_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Global_Decl_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Global_Decl_get`) = c("SWIGFunction", class('WaterWatchEnums_Global_Decl_get'))

# Start of WaterWatchEnums_Constant_get

`WaterWatchEnums_Constant_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Constant_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Constant_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Constant_get`) = c("SWIGFunction", class('WaterWatchEnums_Constant_get'))

# Start of WaterWatchEnums_Compiled_get

`WaterWatchEnums_Compiled_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Compiled_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Compiled_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Compiled_get`) = c("SWIGFunction", class('WaterWatchEnums_Compiled_get'))

# Start of WaterWatchEnums_ControlBlock_get

`WaterWatchEnums_ControlBlock_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_ControlBlock_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_ControlBlock_get`, 'returnType') = 'character'
class(`WaterWatchEnums_ControlBlock_get`) = c("SWIGFunction", class('WaterWatchEnums_ControlBlock_get'))

# Start of WaterWatchEnums_Postfix_get

`WaterWatchEnums_Postfix_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Postfix_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Postfix_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Postfix_get`) = c("SWIGFunction", class('WaterWatchEnums_Postfix_get'))

# Start of WaterWatchEnums_Assign_Retroactively_get

`WaterWatchEnums_Assign_Retroactively_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Assign_Retroactively_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Assign_Retroactively_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Assign_Retroactively_get`) = c("SWIGFunction", class('WaterWatchEnums_Assign_Retroactively_get'))

# Start of WaterWatchEnums_Error_get

`WaterWatchEnums_Error_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatchEnums_Error_get', as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`WaterWatchEnums_Error_get`, 'returnType') = 'character'
class(`WaterWatchEnums_Error_get`) = c("SWIGFunction", class('WaterWatchEnums_Error_get'))

setMethod('delete', '_p_WaterWatchEnums', function(obj) {delete_WaterWatchEnums(obj)})
# Start of new_ScriptingNode

`ScriptingNode` = function()
{
  ;ans = .Call('R_swig_new_ScriptingNode', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_ScriptingNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_ScriptingNode);
  ans
  
}

attr(`ScriptingNode`, 'returnType') = '_p_ScriptingNode'
class(`ScriptingNode`) = c("SWIGFunction", class('ScriptingNode'))

# Start of delete_ScriptingNode

`delete_ScriptingNode` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_ScriptingNode', self, PACKAGE='Conv');
  
}

attr(`delete_ScriptingNode`, 'returnType') = 'void'
attr(`delete_ScriptingNode`, "inputTypes") = c('_p_ScriptingNode')
class(`delete_ScriptingNode`) = c("SWIGFunction", class('delete_ScriptingNode'))

# Start of ScriptingNode_text_get

`ScriptingNode_text_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptingNode_text_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptingNode_text_get`, 'returnType') = 'character'
attr(`ScriptingNode_text_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_text_get`) = c("SWIGFunction", class('ScriptingNode_text_get'))

# Start of ScriptingNode_startLine_get

`ScriptingNode_startLine_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptingNode_startLine_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptingNode_startLine_get`, 'returnType') = 'integer'
attr(`ScriptingNode_startLine_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_startLine_get`) = c("SWIGFunction", class('ScriptingNode_startLine_get'))

# Start of ScriptingNode_startColumn_get

`ScriptingNode_startColumn_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptingNode_startColumn_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptingNode_startColumn_get`, 'returnType') = 'integer'
attr(`ScriptingNode_startColumn_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_startColumn_get`) = c("SWIGFunction", class('ScriptingNode_startColumn_get'))

# Start of ScriptingNode_endLine_get

`ScriptingNode_endLine_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptingNode_endLine_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptingNode_endLine_get`, 'returnType') = 'integer'
attr(`ScriptingNode_endLine_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_endLine_get`) = c("SWIGFunction", class('ScriptingNode_endLine_get'))

# Start of ScriptingNode_endColumn_get

`ScriptingNode_endColumn_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptingNode_endColumn_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptingNode_endColumn_get`, 'returnType') = 'integer'
attr(`ScriptingNode_endColumn_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_endColumn_get`) = c("SWIGFunction", class('ScriptingNode_endColumn_get'))

# Start of ScriptingNode_type_get

`ScriptingNode_type_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_ScriptingNode_type_get', self, as.logical(.copy), PACKAGE='Conv');
  ans = enumFromInteger(ans, "_WaterWatchEnums__ScriptNodeType");
  
  ans
  
}

attr(`ScriptingNode_type_get`, 'returnType') = 'character'
attr(`ScriptingNode_type_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_type_get`) = c("SWIGFunction", class('ScriptingNode_type_get'))

# Start of ScriptingNode_typeHint_get

`ScriptingNode_typeHint_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptingNode_typeHint_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptingNode_typeHint_get`, 'returnType') = 'character'
attr(`ScriptingNode_typeHint_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_typeHint_get`) = c("SWIGFunction", class('ScriptingNode_typeHint_get'))

# Start of ScriptingNode_depth_get

`ScriptingNode_depth_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptingNode_depth_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptingNode_depth_get`, 'returnType') = 'integer'
attr(`ScriptingNode_depth_get`, "inputTypes") = c('_p_ScriptingNode')
class(`ScriptingNode_depth_get`) = c("SWIGFunction", class('ScriptingNode_depth_get'))

# Start of ScriptingNode_text_set

`ScriptingNode_text_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = as(s, "character"); 
  ;.Call('R_swig_ScriptingNode_text_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_text_set`, 'returnType') = 'void'
attr(`ScriptingNode_text_set`, "inputTypes") = c('_p_ScriptingNode', 'character')
class(`ScriptingNode_text_set`) = c("SWIGFunction", class('ScriptingNode_text_set'))

# Start of ScriptingNode_startLine_set

`ScriptingNode_startLine_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = as.integer(s);
  
  if(length(s) > 1) {
    warning("using only the first element of s");
  };
  
  ;.Call('R_swig_ScriptingNode_startLine_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_startLine_set`, 'returnType') = 'void'
attr(`ScriptingNode_startLine_set`, "inputTypes") = c('_p_ScriptingNode', 'integer')
class(`ScriptingNode_startLine_set`) = c("SWIGFunction", class('ScriptingNode_startLine_set'))

# Start of ScriptingNode_startColumn_set

`ScriptingNode_startColumn_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = as.integer(s);
  
  if(length(s) > 1) {
    warning("using only the first element of s");
  };
  
  ;.Call('R_swig_ScriptingNode_startColumn_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_startColumn_set`, 'returnType') = 'void'
attr(`ScriptingNode_startColumn_set`, "inputTypes") = c('_p_ScriptingNode', 'integer')
class(`ScriptingNode_startColumn_set`) = c("SWIGFunction", class('ScriptingNode_startColumn_set'))

# Start of ScriptingNode_endLine_set

`ScriptingNode_endLine_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = as.integer(s);
  
  if(length(s) > 1) {
    warning("using only the first element of s");
  };
  
  ;.Call('R_swig_ScriptingNode_endLine_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_endLine_set`, 'returnType') = 'void'
attr(`ScriptingNode_endLine_set`, "inputTypes") = c('_p_ScriptingNode', 'integer')
class(`ScriptingNode_endLine_set`) = c("SWIGFunction", class('ScriptingNode_endLine_set'))

# Start of ScriptingNode_endColumn_set

`ScriptingNode_endColumn_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = as.integer(s);
  
  if(length(s) > 1) {
    warning("using only the first element of s");
  };
  
  ;.Call('R_swig_ScriptingNode_endColumn_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_endColumn_set`, 'returnType') = 'void'
attr(`ScriptingNode_endColumn_set`, "inputTypes") = c('_p_ScriptingNode', 'integer')
class(`ScriptingNode_endColumn_set`) = c("SWIGFunction", class('ScriptingNode_endColumn_set'))

# Start of ScriptingNode_type_set

`ScriptingNode_type_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = enumToInteger(s, "_WaterWatchEnums__ScriptNodeType"); 
  
  if(length(s) > 1) {
    warning("using only the first element of s");
  };
  
  ;.Call('R_swig_ScriptingNode_type_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_type_set`, 'returnType') = 'void'
attr(`ScriptingNode_type_set`, "inputTypes") = c('_p_ScriptingNode', 'character')
class(`ScriptingNode_type_set`) = c("SWIGFunction", class('ScriptingNode_type_set'))

# Start of ScriptingNode_typeHint_set

`ScriptingNode_typeHint_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = as(s, "character"); 
  ;.Call('R_swig_ScriptingNode_typeHint_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_typeHint_set`, 'returnType') = 'void'
attr(`ScriptingNode_typeHint_set`, "inputTypes") = c('_p_ScriptingNode', 'character')
class(`ScriptingNode_typeHint_set`) = c("SWIGFunction", class('ScriptingNode_typeHint_set'))

# Start of ScriptingNode_depth_set

`ScriptingNode_depth_set` = function(self, s)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s = as.integer(s);
  
  if(length(s) > 1) {
    warning("using only the first element of s");
  };
  
  ;.Call('R_swig_ScriptingNode_depth_set', self, s, PACKAGE='Conv');
  
}

attr(`ScriptingNode_depth_set`, 'returnType') = 'void'
attr(`ScriptingNode_depth_set`, "inputTypes") = c('_p_ScriptingNode', 'integer')
class(`ScriptingNode_depth_set`) = c("SWIGFunction", class('ScriptingNode_depth_set'))

# Start of accessor method for ScriptingNode
setMethod('$', '_p_ScriptingNode', function(x, name)

{
  accessorFuns = list('text_get' = ScriptingNode_text_get, 'startLine_get' = ScriptingNode_startLine_get, 'startColumn_get' = ScriptingNode_startColumn_get, 'endLine_get' = ScriptingNode_endLine_get, 'endColumn_get' = ScriptingNode_endColumn_get, 'type_get' = ScriptingNode_type_get, 'typeHint_get' = ScriptingNode_typeHint_get, 'depth_get' = ScriptingNode_depth_get, 'text_set' = ScriptingNode_text_set, 'startLine_set' = ScriptingNode_startLine_set, 'startColumn_set' = ScriptingNode_startColumn_set, 'endLine_set' = ScriptingNode_endLine_set, 'endColumn_set' = ScriptingNode_endColumn_set, 'type_set' = ScriptingNode_type_set, 'typeHint_set' = ScriptingNode_typeHint_set, 'depth_set' = ScriptingNode_depth_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for ScriptingNode
setMethod('delete', '_p_ScriptingNode', function(obj) {delete_ScriptingNode(obj)})
# Start of new_Color_Interop

`Color_Interop__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Color_Interop__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  reg.finalizer(ans@ref, delete_Color_Interop);
  ans
  
}

attr(`Color_Interop__SWIG_0`, 'returnType') = '_p_Color_Interop'
class(`Color_Interop__SWIG_0`) = c("SWIGFunction", class('Color_Interop__SWIG_0'))

# Start of new_Color_Interop

`Color_Interop__SWIG_1` = function(a)
{
  if (inherits(a, "ExternalReference")) a = slot(a,"ref"); 
  ;ans = .Call('R_swig_new_Color_Interop__SWIG_1', a, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  reg.finalizer(ans@ref, delete_Color_Interop);
  ans
  
}

attr(`Color_Interop__SWIG_1`, 'returnType') = '_p_Color_Interop'
attr(`Color_Interop__SWIG_1`, "inputTypes") = c('_p_Color_Interop')
class(`Color_Interop__SWIG_1`) = c("SWIGFunction", class('Color_Interop__SWIG_1'))

# Start of new_Color_Interop

`Color_Interop__SWIG_2` = function(s_R, s_G, s_B, s_A)
{
  ;ans = .Call('R_swig_new_Color_Interop__SWIG_2', s_R, s_G, s_B, s_A, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  reg.finalizer(ans@ref, delete_Color_Interop);
  ans
  
}

attr(`Color_Interop__SWIG_2`, 'returnType') = '_p_Color_Interop'
attr(`Color_Interop__SWIG_2`, "inputTypes") = c('numeric', 'numeric', 'numeric', 'numeric')
class(`Color_Interop__SWIG_2`) = c("SWIGFunction", class('Color_Interop__SWIG_2'))

`Color_Interop` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 3
  if (argc == 0) {
    f <- Color_Interop__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_Color_Interop') && length(argv[[1]]) == 1 ) {
      f <- Color_Interop__SWIG_1; 
    }
  } else if (argc == 4) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- Color_Interop__SWIG_2; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for Color_Interop with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Color_Interop_R_set

`Color_Interop_R_set` = function(self, s_R)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Color_Interop_R_set', self, s_R, PACKAGE='Conv');
  
}

attr(`Color_Interop_R_set`, 'returnType') = 'void'
attr(`Color_Interop_R_set`, "inputTypes") = c('_p_Color_Interop', 'numeric')
class(`Color_Interop_R_set`) = c("SWIGFunction", class('Color_Interop_R_set'))

# Start of Color_Interop_R_get

`Color_Interop_R_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Color_Interop_R_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`Color_Interop_R_get`, 'returnType') = 'numeric'
attr(`Color_Interop_R_get`, "inputTypes") = c('_p_Color_Interop')
class(`Color_Interop_R_get`) = c("SWIGFunction", class('Color_Interop_R_get'))

# Start of Color_Interop_G_set

`Color_Interop_G_set` = function(self, s_G)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Color_Interop_G_set', self, s_G, PACKAGE='Conv');
  
}

attr(`Color_Interop_G_set`, 'returnType') = 'void'
attr(`Color_Interop_G_set`, "inputTypes") = c('_p_Color_Interop', 'numeric')
class(`Color_Interop_G_set`) = c("SWIGFunction", class('Color_Interop_G_set'))

# Start of Color_Interop_G_get

`Color_Interop_G_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Color_Interop_G_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`Color_Interop_G_get`, 'returnType') = 'numeric'
attr(`Color_Interop_G_get`, "inputTypes") = c('_p_Color_Interop')
class(`Color_Interop_G_get`) = c("SWIGFunction", class('Color_Interop_G_get'))

# Start of Color_Interop_B_set

`Color_Interop_B_set` = function(self, s_B)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Color_Interop_B_set', self, s_B, PACKAGE='Conv');
  
}

attr(`Color_Interop_B_set`, 'returnType') = 'void'
attr(`Color_Interop_B_set`, "inputTypes") = c('_p_Color_Interop', 'numeric')
class(`Color_Interop_B_set`) = c("SWIGFunction", class('Color_Interop_B_set'))

# Start of Color_Interop_B_get

`Color_Interop_B_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Color_Interop_B_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`Color_Interop_B_get`, 'returnType') = 'numeric'
attr(`Color_Interop_B_get`, "inputTypes") = c('_p_Color_Interop')
class(`Color_Interop_B_get`) = c("SWIGFunction", class('Color_Interop_B_get'))

# Start of Color_Interop_A_set

`Color_Interop_A_set` = function(self, s_A)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Color_Interop_A_set', self, s_A, PACKAGE='Conv');
  
}

attr(`Color_Interop_A_set`, 'returnType') = 'void'
attr(`Color_Interop_A_set`, "inputTypes") = c('_p_Color_Interop', 'numeric')
class(`Color_Interop_A_set`) = c("SWIGFunction", class('Color_Interop_A_set'))

# Start of Color_Interop_A_get

`Color_Interop_A_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Color_Interop_A_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`Color_Interop_A_get`, 'returnType') = 'numeric'
attr(`Color_Interop_A_get`, "inputTypes") = c('_p_Color_Interop')
class(`Color_Interop_A_get`) = c("SWIGFunction", class('Color_Interop_A_get'))

# Start of delete_Color_Interop

`delete_Color_Interop` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Color_Interop', self, PACKAGE='Conv');
  
}

attr(`delete_Color_Interop`, 'returnType') = 'void'
attr(`delete_Color_Interop`, "inputTypes") = c('_p_Color_Interop')
class(`delete_Color_Interop`) = c("SWIGFunction", class('delete_Color_Interop'))

# Start of accessor method for Color_Interop
setMethod('$', '_p_Color_Interop', function(x, name)

{
  accessorFuns = list('R' = Color_Interop_R_get, 'G' = Color_Interop_G_get, 'B' = Color_Interop_B_get, 'A' = Color_Interop_A_get);
  vaccessors = c('R', 'G', 'B', 'A');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Color_Interop
# Start of accessor method for Color_Interop
setMethod('$<-', '_p_Color_Interop', function(x, name, value)

{
  accessorFuns = list('R' = Color_Interop_R_set, 'G' = Color_Interop_G_set, 'B' = Color_Interop_B_set, 'A' = Color_Interop_A_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Color_Interop', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('R' = Color_Interop_R_set, 'G' = Color_Interop_G_set, 'B' = Color_Interop_B_set, 'A' = Color_Interop_A_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Color_Interop
setMethod('delete', '_p_Color_Interop', function(obj) {delete_Color_Interop(obj)})
# Start of MapIcon_Interop_color_set

`MapIcon_Interop_color_set` = function(self, s_color)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_color, "ExternalReference")) s_color = slot(s_color,"ref"); 
  ;.Call('R_swig_MapIcon_Interop_color_set', self, s_color, PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_color_set`, 'returnType') = 'void'
attr(`MapIcon_Interop_color_set`, "inputTypes") = c('_p_MapIcon_Interop', '_p_Color_Interop')
class(`MapIcon_Interop_color_set`) = c("SWIGFunction", class('MapIcon_Interop_color_set'))

# Start of MapIcon_Interop_color_get

`MapIcon_Interop_color_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_MapIcon_Interop_color_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`MapIcon_Interop_color_get`, 'returnType') = '_p_Color_Interop'
attr(`MapIcon_Interop_color_get`, "inputTypes") = c('_p_MapIcon_Interop')
class(`MapIcon_Interop_color_get`) = c("SWIGFunction", class('MapIcon_Interop_color_get'))

# Start of MapIcon_Interop_size_set

`MapIcon_Interop_size_set` = function(self, s_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapIcon_Interop_size_set', self, s_size, PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_size_set`, 'returnType') = 'void'
attr(`MapIcon_Interop_size_set`, "inputTypes") = c('_p_MapIcon_Interop', 'numeric')
class(`MapIcon_Interop_size_set`) = c("SWIGFunction", class('MapIcon_Interop_size_set'))

# Start of MapIcon_Interop_size_get

`MapIcon_Interop_size_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapIcon_Interop_size_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_size_get`, 'returnType') = 'numeric'
attr(`MapIcon_Interop_size_get`, "inputTypes") = c('_p_MapIcon_Interop')
class(`MapIcon_Interop_size_get`) = c("SWIGFunction", class('MapIcon_Interop_size_get'))

# Start of MapIcon_Interop_longitude_set

`MapIcon_Interop_longitude_set` = function(self, s_longitude)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapIcon_Interop_longitude_set', self, s_longitude, PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_longitude_set`, 'returnType') = 'void'
attr(`MapIcon_Interop_longitude_set`, "inputTypes") = c('_p_MapIcon_Interop', 'numeric')
class(`MapIcon_Interop_longitude_set`) = c("SWIGFunction", class('MapIcon_Interop_longitude_set'))

# Start of MapIcon_Interop_longitude_get

`MapIcon_Interop_longitude_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapIcon_Interop_longitude_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_longitude_get`, 'returnType') = 'numeric'
attr(`MapIcon_Interop_longitude_get`, "inputTypes") = c('_p_MapIcon_Interop')
class(`MapIcon_Interop_longitude_get`) = c("SWIGFunction", class('MapIcon_Interop_longitude_get'))

# Start of MapIcon_Interop_latitude_set

`MapIcon_Interop_latitude_set` = function(self, s_latitude)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapIcon_Interop_latitude_set', self, s_latitude, PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_latitude_set`, 'returnType') = 'void'
attr(`MapIcon_Interop_latitude_set`, "inputTypes") = c('_p_MapIcon_Interop', 'numeric')
class(`MapIcon_Interop_latitude_set`) = c("SWIGFunction", class('MapIcon_Interop_latitude_set'))

# Start of MapIcon_Interop_latitude_get

`MapIcon_Interop_latitude_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapIcon_Interop_latitude_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_latitude_get`, 'returnType') = 'numeric'
attr(`MapIcon_Interop_latitude_get`, "inputTypes") = c('_p_MapIcon_Interop')
class(`MapIcon_Interop_latitude_get`) = c("SWIGFunction", class('MapIcon_Interop_latitude_get'))

# Start of MapIcon_Interop_HideOnCollision_set

`MapIcon_Interop_HideOnCollision_set` = function(self, s_HideOnCollision)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_HideOnCollision = as.logical(s_HideOnCollision);
  ;.Call('R_swig_MapIcon_Interop_HideOnCollision_set', self, s_HideOnCollision, PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_HideOnCollision_set`, 'returnType') = 'void'
attr(`MapIcon_Interop_HideOnCollision_set`, "inputTypes") = c('_p_MapIcon_Interop', 'logical')
class(`MapIcon_Interop_HideOnCollision_set`) = c("SWIGFunction", class('MapIcon_Interop_HideOnCollision_set'))

# Start of MapIcon_Interop_HideOnCollision_get

`MapIcon_Interop_HideOnCollision_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapIcon_Interop_HideOnCollision_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_HideOnCollision_get`, 'returnType') = 'logical'
attr(`MapIcon_Interop_HideOnCollision_get`, "inputTypes") = c('_p_MapIcon_Interop')
class(`MapIcon_Interop_HideOnCollision_get`) = c("SWIGFunction", class('MapIcon_Interop_HideOnCollision_get'))

# Start of MapIcon_Interop_IconPathGeometry_set

`MapIcon_Interop_IconPathGeometry_set` = function(self, s_IconPathGeometry)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_IconPathGeometry = as(s_IconPathGeometry, "character"); 
  ;.Call('R_swig_MapIcon_Interop_IconPathGeometry_set', self, s_IconPathGeometry, PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_IconPathGeometry_set`, 'returnType') = 'void'
attr(`MapIcon_Interop_IconPathGeometry_set`, "inputTypes") = c('_p_MapIcon_Interop', 'character')
class(`MapIcon_Interop_IconPathGeometry_set`) = c("SWIGFunction", class('MapIcon_Interop_IconPathGeometry_set'))

# Start of MapIcon_Interop_IconPathGeometry_get

`MapIcon_Interop_IconPathGeometry_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapIcon_Interop_IconPathGeometry_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_IconPathGeometry_get`, 'returnType') = 'character'
attr(`MapIcon_Interop_IconPathGeometry_get`, "inputTypes") = c('_p_MapIcon_Interop')
class(`MapIcon_Interop_IconPathGeometry_get`) = c("SWIGFunction", class('MapIcon_Interop_IconPathGeometry_get'))

# Start of MapIcon_Interop_Label_set

`MapIcon_Interop_Label_set` = function(self, s_Label)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_Label = as(s_Label, "character"); 
  ;.Call('R_swig_MapIcon_Interop_Label_set', self, s_Label, PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_Label_set`, 'returnType') = 'void'
attr(`MapIcon_Interop_Label_set`, "inputTypes") = c('_p_MapIcon_Interop', 'character')
class(`MapIcon_Interop_Label_set`) = c("SWIGFunction", class('MapIcon_Interop_Label_set'))

# Start of MapIcon_Interop_Label_get

`MapIcon_Interop_Label_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapIcon_Interop_Label_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapIcon_Interop_Label_get`, 'returnType') = 'character'
attr(`MapIcon_Interop_Label_get`, "inputTypes") = c('_p_MapIcon_Interop')
class(`MapIcon_Interop_Label_get`) = c("SWIGFunction", class('MapIcon_Interop_Label_get'))

# Start of new_MapIcon_Interop

`MapIcon_Interop` = function()
{
  ;ans = .Call('R_swig_new_MapIcon_Interop', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapIcon_Interop", ref=ans);
  
  reg.finalizer(ans@ref, delete_MapIcon_Interop);
  ans
  
}

attr(`MapIcon_Interop`, 'returnType') = '_p_MapIcon_Interop'
class(`MapIcon_Interop`) = c("SWIGFunction", class('MapIcon_Interop'))

# Start of delete_MapIcon_Interop

`delete_MapIcon_Interop` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MapIcon_Interop', self, PACKAGE='Conv');
  
}

attr(`delete_MapIcon_Interop`, 'returnType') = 'void'
attr(`delete_MapIcon_Interop`, "inputTypes") = c('_p_MapIcon_Interop')
class(`delete_MapIcon_Interop`) = c("SWIGFunction", class('delete_MapIcon_Interop'))

# Start of accessor method for MapIcon_Interop
setMethod('$', '_p_MapIcon_Interop', function(x, name)

{
  accessorFuns = list('color' = MapIcon_Interop_color_get, 'size' = MapIcon_Interop_size_get, 'longitude' = MapIcon_Interop_longitude_get, 'latitude' = MapIcon_Interop_latitude_get, 'HideOnCollision' = MapIcon_Interop_HideOnCollision_get, 'IconPathGeometry' = MapIcon_Interop_IconPathGeometry_get, 'Label' = MapIcon_Interop_Label_get);
  vaccessors = c('color', 'size', 'longitude', 'latitude', 'HideOnCollision', 'IconPathGeometry', 'Label');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for MapIcon_Interop
# Start of accessor method for MapIcon_Interop
setMethod('$<-', '_p_MapIcon_Interop', function(x, name, value)

{
  accessorFuns = list('color' = MapIcon_Interop_color_set, 'size' = MapIcon_Interop_size_set, 'longitude' = MapIcon_Interop_longitude_set, 'latitude' = MapIcon_Interop_latitude_set, 'HideOnCollision' = MapIcon_Interop_HideOnCollision_set, 'IconPathGeometry' = MapIcon_Interop_IconPathGeometry_set, 'Label' = MapIcon_Interop_Label_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_MapIcon_Interop', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('color' = MapIcon_Interop_color_set, 'size' = MapIcon_Interop_size_set, 'longitude' = MapIcon_Interop_longitude_set, 'latitude' = MapIcon_Interop_latitude_set, 'HideOnCollision' = MapIcon_Interop_HideOnCollision_set, 'IconPathGeometry' = MapIcon_Interop_IconPathGeometry_set, 'Label' = MapIcon_Interop_Label_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for MapIcon_Interop
setMethod('delete', '_p_MapIcon_Interop', function(obj) {delete_MapIcon_Interop(obj)})
# Start of MapPolyline_Interop_color_set

`MapPolyline_Interop_color_set` = function(self, s_color)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_color, "ExternalReference")) s_color = slot(s_color,"ref"); 
  ;.Call('R_swig_MapPolyline_Interop_color_set', self, s_color, PACKAGE='Conv');
  
}

attr(`MapPolyline_Interop_color_set`, 'returnType') = 'void'
attr(`MapPolyline_Interop_color_set`, "inputTypes") = c('_p_MapPolyline_Interop', '_p_Color_Interop')
class(`MapPolyline_Interop_color_set`) = c("SWIGFunction", class('MapPolyline_Interop_color_set'))

# Start of MapPolyline_Interop_color_get

`MapPolyline_Interop_color_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_MapPolyline_Interop_color_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`MapPolyline_Interop_color_get`, 'returnType') = '_p_Color_Interop'
attr(`MapPolyline_Interop_color_get`, "inputTypes") = c('_p_MapPolyline_Interop')
class(`MapPolyline_Interop_color_get`) = c("SWIGFunction", class('MapPolyline_Interop_color_get'))

# Start of MapPolyline_Interop_thickness_set

`MapPolyline_Interop_thickness_set` = function(self, s_thickness)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapPolyline_Interop_thickness_set', self, s_thickness, PACKAGE='Conv');
  
}

attr(`MapPolyline_Interop_thickness_set`, 'returnType') = 'void'
attr(`MapPolyline_Interop_thickness_set`, "inputTypes") = c('_p_MapPolyline_Interop', 'numeric')
class(`MapPolyline_Interop_thickness_set`) = c("SWIGFunction", class('MapPolyline_Interop_thickness_set'))

# Start of MapPolyline_Interop_thickness_get

`MapPolyline_Interop_thickness_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapPolyline_Interop_thickness_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapPolyline_Interop_thickness_get`, 'returnType') = 'numeric'
attr(`MapPolyline_Interop_thickness_get`, "inputTypes") = c('_p_MapPolyline_Interop')
class(`MapPolyline_Interop_thickness_get`) = c("SWIGFunction", class('MapPolyline_Interop_thickness_get'))

# Start of MapPolyline_Interop_dashed_set

`MapPolyline_Interop_dashed_set` = function(self, s_dashed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_dashed = as.logical(s_dashed);
  ;.Call('R_swig_MapPolyline_Interop_dashed_set', self, s_dashed, PACKAGE='Conv');
  
}

attr(`MapPolyline_Interop_dashed_set`, 'returnType') = 'void'
attr(`MapPolyline_Interop_dashed_set`, "inputTypes") = c('_p_MapPolyline_Interop', 'logical')
class(`MapPolyline_Interop_dashed_set`) = c("SWIGFunction", class('MapPolyline_Interop_dashed_set'))

# Start of MapPolyline_Interop_dashed_get

`MapPolyline_Interop_dashed_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapPolyline_Interop_dashed_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapPolyline_Interop_dashed_get`, 'returnType') = 'logical'
attr(`MapPolyline_Interop_dashed_get`, "inputTypes") = c('_p_MapPolyline_Interop')
class(`MapPolyline_Interop_dashed_get`) = c("SWIGFunction", class('MapPolyline_Interop_dashed_get'))

# Start of MapPolyline_Interop_coordinates_set

`MapPolyline_Interop_coordinates_set` = function(self, s_coordinates)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_coordinates, "ExternalReference")) s_coordinates = slot(s_coordinates,"ref"); 
  ;.Call('R_swig_MapPolyline_Interop_coordinates_set', self, s_coordinates, PACKAGE='Conv');
  
}

attr(`MapPolyline_Interop_coordinates_set`, 'returnType') = 'void'
attr(`MapPolyline_Interop_coordinates_set`, "inputTypes") = c('_p_MapPolyline_Interop', '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`MapPolyline_Interop_coordinates_set`) = c("SWIGFunction", class('MapPolyline_Interop_coordinates_set'))

# Start of MapPolyline_Interop_coordinates_get

`MapPolyline_Interop_coordinates_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_MapPolyline_Interop_coordinates_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`MapPolyline_Interop_coordinates_get`, 'returnType') = '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t'
attr(`MapPolyline_Interop_coordinates_get`, "inputTypes") = c('_p_MapPolyline_Interop')
class(`MapPolyline_Interop_coordinates_get`) = c("SWIGFunction", class('MapPolyline_Interop_coordinates_get'))

# Start of new_MapPolyline_Interop

`MapPolyline_Interop` = function()
{
  ;ans = .Call('R_swig_new_MapPolyline_Interop', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapPolyline_Interop", ref=ans);
  
  reg.finalizer(ans@ref, delete_MapPolyline_Interop);
  ans
  
}

attr(`MapPolyline_Interop`, 'returnType') = '_p_MapPolyline_Interop'
class(`MapPolyline_Interop`) = c("SWIGFunction", class('MapPolyline_Interop'))

# Start of delete_MapPolyline_Interop

`delete_MapPolyline_Interop` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MapPolyline_Interop', self, PACKAGE='Conv');
  
}

attr(`delete_MapPolyline_Interop`, 'returnType') = 'void'
attr(`delete_MapPolyline_Interop`, "inputTypes") = c('_p_MapPolyline_Interop')
class(`delete_MapPolyline_Interop`) = c("SWIGFunction", class('delete_MapPolyline_Interop'))

# Start of accessor method for MapPolyline_Interop
setMethod('$', '_p_MapPolyline_Interop', function(x, name)

{
  accessorFuns = list('color' = MapPolyline_Interop_color_get, 'thickness' = MapPolyline_Interop_thickness_get, 'dashed' = MapPolyline_Interop_dashed_get, 'coordinates' = MapPolyline_Interop_coordinates_get);
  vaccessors = c('color', 'thickness', 'dashed', 'coordinates');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for MapPolyline_Interop
# Start of accessor method for MapPolyline_Interop
setMethod('$<-', '_p_MapPolyline_Interop', function(x, name, value)

{
  accessorFuns = list('color' = MapPolyline_Interop_color_set, 'thickness' = MapPolyline_Interop_thickness_set, 'dashed' = MapPolyline_Interop_dashed_set, 'coordinates' = MapPolyline_Interop_coordinates_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_MapPolyline_Interop', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('color' = MapPolyline_Interop_color_set, 'thickness' = MapPolyline_Interop_thickness_set, 'dashed' = MapPolyline_Interop_dashed_set, 'coordinates' = MapPolyline_Interop_coordinates_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for MapPolyline_Interop
setMethod('delete', '_p_MapPolyline_Interop', function(obj) {delete_MapPolyline_Interop(obj)})
# Start of MapBackground_Interop_highQuality_set

`MapBackground_Interop_highQuality_set` = function(self, s_highQuality)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_highQuality = as.logical(s_highQuality);
  ;.Call('R_swig_MapBackground_Interop_highQuality_set', self, s_highQuality, PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_highQuality_set`, 'returnType') = 'void'
attr(`MapBackground_Interop_highQuality_set`, "inputTypes") = c('_p_MapBackground_Interop', 'logical')
class(`MapBackground_Interop_highQuality_set`) = c("SWIGFunction", class('MapBackground_Interop_highQuality_set'))

# Start of MapBackground_Interop_highQuality_get

`MapBackground_Interop_highQuality_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapBackground_Interop_highQuality_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_highQuality_get`, 'returnType') = 'logical'
attr(`MapBackground_Interop_highQuality_get`, "inputTypes") = c('_p_MapBackground_Interop')
class(`MapBackground_Interop_highQuality_get`) = c("SWIGFunction", class('MapBackground_Interop_highQuality_get'))

# Start of MapBackground_Interop_clipToBounds_set

`MapBackground_Interop_clipToBounds_set` = function(self, s_clipToBounds)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_clipToBounds = as.logical(s_clipToBounds);
  ;.Call('R_swig_MapBackground_Interop_clipToBounds_set', self, s_clipToBounds, PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_clipToBounds_set`, 'returnType') = 'void'
attr(`MapBackground_Interop_clipToBounds_set`, "inputTypes") = c('_p_MapBackground_Interop', 'logical')
class(`MapBackground_Interop_clipToBounds_set`) = c("SWIGFunction", class('MapBackground_Interop_clipToBounds_set'))

# Start of MapBackground_Interop_clipToBounds_get

`MapBackground_Interop_clipToBounds_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapBackground_Interop_clipToBounds_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_clipToBounds_get`, 'returnType') = 'logical'
attr(`MapBackground_Interop_clipToBounds_get`, "inputTypes") = c('_p_MapBackground_Interop')
class(`MapBackground_Interop_clipToBounds_get`) = c("SWIGFunction", class('MapBackground_Interop_clipToBounds_get'))

# Start of MapBackground_Interop_minValue_set

`MapBackground_Interop_minValue_set` = function(self, s_minValue)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapBackground_Interop_minValue_set', self, s_minValue, PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_minValue_set`, 'returnType') = 'void'
attr(`MapBackground_Interop_minValue_set`, "inputTypes") = c('_p_MapBackground_Interop', 'numeric')
class(`MapBackground_Interop_minValue_set`) = c("SWIGFunction", class('MapBackground_Interop_minValue_set'))

# Start of MapBackground_Interop_minValue_get

`MapBackground_Interop_minValue_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapBackground_Interop_minValue_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_minValue_get`, 'returnType') = 'numeric'
attr(`MapBackground_Interop_minValue_get`, "inputTypes") = c('_p_MapBackground_Interop')
class(`MapBackground_Interop_minValue_get`) = c("SWIGFunction", class('MapBackground_Interop_minValue_get'))

# Start of MapBackground_Interop_maxValue_set

`MapBackground_Interop_maxValue_set` = function(self, s_maxValue)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapBackground_Interop_maxValue_set', self, s_maxValue, PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_maxValue_set`, 'returnType') = 'void'
attr(`MapBackground_Interop_maxValue_set`, "inputTypes") = c('_p_MapBackground_Interop', 'numeric')
class(`MapBackground_Interop_maxValue_set`) = c("SWIGFunction", class('MapBackground_Interop_maxValue_set'))

# Start of MapBackground_Interop_maxValue_get

`MapBackground_Interop_maxValue_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapBackground_Interop_maxValue_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_maxValue_get`, 'returnType') = 'numeric'
attr(`MapBackground_Interop_maxValue_get`, "inputTypes") = c('_p_MapBackground_Interop')
class(`MapBackground_Interop_maxValue_get`) = c("SWIGFunction", class('MapBackground_Interop_maxValue_get'))

# Start of MapBackground_Interop_matrix_set

`MapBackground_Interop_matrix_set` = function(self, s_matrix)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_matrix = as.integer(s_matrix);
  
  if(length(s_matrix) > 1) {
    warning("using only the first element of s_matrix");
  };
  
  ;.Call('R_swig_MapBackground_Interop_matrix_set', self, s_matrix, PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_matrix_set`, 'returnType') = 'void'
attr(`MapBackground_Interop_matrix_set`, "inputTypes") = c('_p_MapBackground_Interop', 'integer')
class(`MapBackground_Interop_matrix_set`) = c("SWIGFunction", class('MapBackground_Interop_matrix_set'))

# Start of MapBackground_Interop_matrix_get

`MapBackground_Interop_matrix_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapBackground_Interop_matrix_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_matrix_get`, 'returnType') = 'integer'
attr(`MapBackground_Interop_matrix_get`, "inputTypes") = c('_p_MapBackground_Interop')
class(`MapBackground_Interop_matrix_get`) = c("SWIGFunction", class('MapBackground_Interop_matrix_get'))

# Start of MapBackground_Interop_min_color_set

`MapBackground_Interop_min_color_set` = function(self, s_min_color)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_min_color, "ExternalReference")) s_min_color = slot(s_min_color,"ref"); 
  ;.Call('R_swig_MapBackground_Interop_min_color_set', self, s_min_color, PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_min_color_set`, 'returnType') = 'void'
attr(`MapBackground_Interop_min_color_set`, "inputTypes") = c('_p_MapBackground_Interop', '_p_Color_Interop')
class(`MapBackground_Interop_min_color_set`) = c("SWIGFunction", class('MapBackground_Interop_min_color_set'))

# Start of MapBackground_Interop_min_color_get

`MapBackground_Interop_min_color_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_MapBackground_Interop_min_color_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`MapBackground_Interop_min_color_get`, 'returnType') = '_p_Color_Interop'
attr(`MapBackground_Interop_min_color_get`, "inputTypes") = c('_p_MapBackground_Interop')
class(`MapBackground_Interop_min_color_get`) = c("SWIGFunction", class('MapBackground_Interop_min_color_get'))

# Start of MapBackground_Interop_max_color_set

`MapBackground_Interop_max_color_set` = function(self, s_max_color)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_max_color, "ExternalReference")) s_max_color = slot(s_max_color,"ref"); 
  ;.Call('R_swig_MapBackground_Interop_max_color_set', self, s_max_color, PACKAGE='Conv');
  
}

attr(`MapBackground_Interop_max_color_set`, 'returnType') = 'void'
attr(`MapBackground_Interop_max_color_set`, "inputTypes") = c('_p_MapBackground_Interop', '_p_Color_Interop')
class(`MapBackground_Interop_max_color_set`) = c("SWIGFunction", class('MapBackground_Interop_max_color_set'))

# Start of MapBackground_Interop_max_color_get

`MapBackground_Interop_max_color_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_MapBackground_Interop_max_color_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`MapBackground_Interop_max_color_get`, 'returnType') = '_p_Color_Interop'
attr(`MapBackground_Interop_max_color_get`, "inputTypes") = c('_p_MapBackground_Interop')
class(`MapBackground_Interop_max_color_get`) = c("SWIGFunction", class('MapBackground_Interop_max_color_get'))

# Start of MapBackground_Interop_GetMatrix

`MapBackground_Interop_GetMatrix` = function(Left, Top, Right, Bottom, numColumns, numRows, backgrounds, .copy = FALSE)
{
  numColumns = as.integer(numColumns);
  
  if(length(numColumns) > 1) {
    warning("using only the first element of numColumns");
  };
  
  numRows = as.integer(numRows);
  
  if(length(numRows) > 1) {
    warning("using only the first element of numRows");
  };
  
  if (inherits(backgrounds, "ExternalReference")) backgrounds = slot(backgrounds,"ref"); 
  ;ans = .Call('R_swig_MapBackground_Interop_GetMatrix', Left, Top, Right, Bottom, numColumns, numRows, backgrounds, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t", ref=ans);
  
  ans
  
}

attr(`MapBackground_Interop_GetMatrix`, 'returnType') = '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t'
attr(`MapBackground_Interop_GetMatrix`, "inputTypes") = c('numeric', 'numeric', 'numeric', 'numeric', 'integer', 'integer', '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`MapBackground_Interop_GetMatrix`) = c("SWIGFunction", class('MapBackground_Interop_GetMatrix'))

# Start of new_MapBackground_Interop

`MapBackground_Interop` = function()
{
  ;ans = .Call('R_swig_new_MapBackground_Interop', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapBackground_Interop", ref=ans);
  
  reg.finalizer(ans@ref, delete_MapBackground_Interop);
  ans
  
}

attr(`MapBackground_Interop`, 'returnType') = '_p_MapBackground_Interop'
class(`MapBackground_Interop`) = c("SWIGFunction", class('MapBackground_Interop'))

# Start of delete_MapBackground_Interop

`delete_MapBackground_Interop` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MapBackground_Interop', self, PACKAGE='Conv');
  
}

attr(`delete_MapBackground_Interop`, 'returnType') = 'void'
attr(`delete_MapBackground_Interop`, "inputTypes") = c('_p_MapBackground_Interop')
class(`delete_MapBackground_Interop`) = c("SWIGFunction", class('delete_MapBackground_Interop'))

# Start of accessor method for MapBackground_Interop
setMethod('$', '_p_MapBackground_Interop', function(x, name)

{
  accessorFuns = list('highQuality' = MapBackground_Interop_highQuality_get, 'clipToBounds' = MapBackground_Interop_clipToBounds_get, 'minValue' = MapBackground_Interop_minValue_get, 'maxValue' = MapBackground_Interop_maxValue_get, 'matrix' = MapBackground_Interop_matrix_get, 'min_color' = MapBackground_Interop_min_color_get, 'max_color' = MapBackground_Interop_max_color_get);
  vaccessors = c('highQuality', 'clipToBounds', 'minValue', 'maxValue', 'matrix', 'min_color', 'max_color');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for MapBackground_Interop
# Start of accessor method for MapBackground_Interop
setMethod('$<-', '_p_MapBackground_Interop', function(x, name, value)

{
  accessorFuns = list('highQuality' = MapBackground_Interop_highQuality_set, 'clipToBounds' = MapBackground_Interop_clipToBounds_set, 'minValue' = MapBackground_Interop_minValue_set, 'maxValue' = MapBackground_Interop_maxValue_set, 'matrix' = MapBackground_Interop_matrix_set, 'min_color' = MapBackground_Interop_min_color_set, 'max_color' = MapBackground_Interop_max_color_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_MapBackground_Interop', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('highQuality' = MapBackground_Interop_highQuality_set, 'clipToBounds' = MapBackground_Interop_clipToBounds_set, 'minValue' = MapBackground_Interop_minValue_set, 'maxValue' = MapBackground_Interop_maxValue_set, 'matrix' = MapBackground_Interop_matrix_set, 'min_color' = MapBackground_Interop_min_color_set, 'max_color' = MapBackground_Interop_max_color_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for MapBackground_Interop
setMethod('delete', '_p_MapBackground_Interop', function(obj) {delete_MapBackground_Interop(obj)})
# Start of MapLayer_Interop_polylines_set

`MapLayer_Interop_polylines_set` = function(self, s_polylines)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_polylines, "ExternalReference")) s_polylines = slot(s_polylines,"ref"); 
  ;.Call('R_swig_MapLayer_Interop_polylines_set', self, s_polylines, PACKAGE='Conv');
  
}

attr(`MapLayer_Interop_polylines_set`, 'returnType') = 'void'
attr(`MapLayer_Interop_polylines_set`, "inputTypes") = c('_p_MapLayer_Interop', '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`MapLayer_Interop_polylines_set`) = c("SWIGFunction", class('MapLayer_Interop_polylines_set'))

# Start of MapLayer_Interop_polylines_get

`MapLayer_Interop_polylines_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_MapLayer_Interop_polylines_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t", ref=ans);
  
  ans
  
}

attr(`MapLayer_Interop_polylines_get`, 'returnType') = '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t'
attr(`MapLayer_Interop_polylines_get`, "inputTypes") = c('_p_MapLayer_Interop')
class(`MapLayer_Interop_polylines_get`) = c("SWIGFunction", class('MapLayer_Interop_polylines_get'))

# Start of MapLayer_Interop_icons_set

`MapLayer_Interop_icons_set` = function(self, s_icons)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_icons, "ExternalReference")) s_icons = slot(s_icons,"ref"); 
  ;.Call('R_swig_MapLayer_Interop_icons_set', self, s_icons, PACKAGE='Conv');
  
}

attr(`MapLayer_Interop_icons_set`, 'returnType') = 'void'
attr(`MapLayer_Interop_icons_set`, "inputTypes") = c('_p_MapLayer_Interop', '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`MapLayer_Interop_icons_set`) = c("SWIGFunction", class('MapLayer_Interop_icons_set'))

# Start of MapLayer_Interop_icons_get

`MapLayer_Interop_icons_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_MapLayer_Interop_icons_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t", ref=ans);
  
  ans
  
}

attr(`MapLayer_Interop_icons_get`, 'returnType') = '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t'
attr(`MapLayer_Interop_icons_get`, "inputTypes") = c('_p_MapLayer_Interop')
class(`MapLayer_Interop_icons_get`) = c("SWIGFunction", class('MapLayer_Interop_icons_get'))

# Start of new_MapLayer_Interop

`MapLayer_Interop` = function()
{
  ;ans = .Call('R_swig_new_MapLayer_Interop', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapLayer_Interop", ref=ans);
  
  reg.finalizer(ans@ref, delete_MapLayer_Interop);
  ans
  
}

attr(`MapLayer_Interop`, 'returnType') = '_p_MapLayer_Interop'
class(`MapLayer_Interop`) = c("SWIGFunction", class('MapLayer_Interop'))

# Start of delete_MapLayer_Interop

`delete_MapLayer_Interop` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MapLayer_Interop', self, PACKAGE='Conv');
  
}

attr(`delete_MapLayer_Interop`, 'returnType') = 'void'
attr(`delete_MapLayer_Interop`, "inputTypes") = c('_p_MapLayer_Interop')
class(`delete_MapLayer_Interop`) = c("SWIGFunction", class('delete_MapLayer_Interop'))

# Start of accessor method for MapLayer_Interop
setMethod('$', '_p_MapLayer_Interop', function(x, name)

{
  accessorFuns = list('polylines' = MapLayer_Interop_polylines_get, 'icons' = MapLayer_Interop_icons_get);
  vaccessors = c('polylines', 'icons');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for MapLayer_Interop
# Start of accessor method for MapLayer_Interop
setMethod('$<-', '_p_MapLayer_Interop', function(x, name, value)

{
  accessorFuns = list('polylines' = MapLayer_Interop_polylines_set, 'icons' = MapLayer_Interop_icons_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_MapLayer_Interop', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('polylines' = MapLayer_Interop_polylines_set, 'icons' = MapLayer_Interop_icons_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for MapLayer_Interop
setMethod('delete', '_p_MapLayer_Interop', function(obj) {delete_MapLayer_Interop(obj)})
# Start of new_ScriptObject

`ScriptObject` = function(p)
{
  if (inherits(p, "ExternalReference")) p = slot(p,"ref"); 
  ;ans = .Call('R_swig_new_ScriptObject', p, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_ScriptObject", ref=ans);
  
  reg.finalizer(ans@ref, delete_ScriptObject);
  ans
  
}

attr(`ScriptObject`, 'returnType') = '_p_ScriptObject'
attr(`ScriptObject`, "inputTypes") = c('_p_cweeSharedPtrT_void_t')
class(`ScriptObject`) = c("SWIGFunction", class('ScriptObject'))

# Start of delete_ScriptObject

`delete_ScriptObject` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_ScriptObject', self, PACKAGE='Conv');
  
}

attr(`delete_ScriptObject`, 'returnType') = 'void'
attr(`delete_ScriptObject`, "inputTypes") = c('_p_ScriptObject')
class(`delete_ScriptObject`) = c("SWIGFunction", class('delete_ScriptObject'))

# Start of ScriptObject_Cast_String

`ScriptObject_Cast_String` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptObject_Cast_String', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptObject_Cast_String`, 'returnType') = 'character'
attr(`ScriptObject_Cast_String`, "inputTypes") = c('_p_ScriptObject')
class(`ScriptObject_Cast_String`) = c("SWIGFunction", class('ScriptObject_Cast_String'))

# Start of ScriptObject_Cast_Color

`ScriptObject_Cast_Color` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_ScriptObject_Cast_Color', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptObject_Cast_Color`, 'returnType') = '_p_Color_Interop'
attr(`ScriptObject_Cast_Color`, "inputTypes") = c('_p_ScriptObject')
class(`ScriptObject_Cast_Color`) = c("SWIGFunction", class('ScriptObject_Cast_Color'))

# Start of ScriptObject_Cast_MapIcon

`ScriptObject_Cast_MapIcon` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_ScriptObject_Cast_MapIcon', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapIcon_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptObject_Cast_MapIcon`, 'returnType') = '_p_MapIcon_Interop'
attr(`ScriptObject_Cast_MapIcon`, "inputTypes") = c('_p_ScriptObject')
class(`ScriptObject_Cast_MapIcon`) = c("SWIGFunction", class('ScriptObject_Cast_MapIcon'))

# Start of ScriptObject_Cast_MapPolyline

`ScriptObject_Cast_MapPolyline` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_ScriptObject_Cast_MapPolyline', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapPolyline_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptObject_Cast_MapPolyline`, 'returnType') = '_p_MapPolyline_Interop'
attr(`ScriptObject_Cast_MapPolyline`, "inputTypes") = c('_p_ScriptObject')
class(`ScriptObject_Cast_MapPolyline`) = c("SWIGFunction", class('ScriptObject_Cast_MapPolyline'))

# Start of ScriptObject_Cast_MapLayer

`ScriptObject_Cast_MapLayer` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_ScriptObject_Cast_MapLayer', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapLayer_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptObject_Cast_MapLayer`, 'returnType') = '_p_MapLayer_Interop'
attr(`ScriptObject_Cast_MapLayer`, "inputTypes") = c('_p_ScriptObject')
class(`ScriptObject_Cast_MapLayer`) = c("SWIGFunction", class('ScriptObject_Cast_MapLayer'))

# Start of accessor method for ScriptObject
setMethod('$', '_p_ScriptObject', function(x, name)

{
  accessorFuns = list('Cast_String' = ScriptObject_Cast_String, 'Cast_Color' = ScriptObject_Cast_Color, 'Cast_MapIcon' = ScriptObject_Cast_MapIcon, 'Cast_MapPolyline' = ScriptObject_Cast_MapPolyline, 'Cast_MapLayer' = ScriptObject_Cast_MapLayer);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for ScriptObject
setMethod('delete', '_p_ScriptObject', function(obj) {delete_ScriptObject(obj)})
# Start of new_ScriptEngine

`ScriptEngine` = function()
{
  ;ans = .Call('R_swig_new_ScriptEngine', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_ScriptEngine", ref=ans);
  
  reg.finalizer(ans@ref, delete_ScriptEngine);
  ans
  
}

attr(`ScriptEngine`, 'returnType') = '_p_ScriptEngine'
class(`ScriptEngine`) = c("SWIGFunction", class('ScriptEngine'))

# Start of delete_ScriptEngine

`delete_ScriptEngine` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_ScriptEngine', self, PACKAGE='Conv');
  
}

attr(`delete_ScriptEngine`, 'returnType') = 'void'
attr(`delete_ScriptEngine`, "inputTypes") = c('_p_ScriptEngine')
class(`delete_ScriptEngine`) = c("SWIGFunction", class('delete_ScriptEngine'))

# Start of ScriptEngine_DoScript_Cast_VectorStrings

`ScriptEngine_DoScript_Cast_VectorStrings` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;.Call('R_swig_ScriptEngine_DoScript_Cast_VectorStrings', self, command, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptEngine_DoScript_Cast_VectorStrings`, 'returnType') = 'character'
attr(`ScriptEngine_DoScript_Cast_VectorStrings`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_DoScript_Cast_VectorStrings`) = c("SWIGFunction", class('ScriptEngine_DoScript_Cast_VectorStrings'))

# Start of ScriptEngine_DoScript_Cast_VectorFloats

`ScriptEngine_DoScript_Cast_VectorFloats` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;.Call('R_swig_ScriptEngine_DoScript_Cast_VectorFloats', self, command, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptEngine_DoScript_Cast_VectorFloats`, 'returnType') = 'numeric'
attr(`ScriptEngine_DoScript_Cast_VectorFloats`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_DoScript_Cast_VectorFloats`) = c("SWIGFunction", class('ScriptEngine_DoScript_Cast_VectorFloats'))

# Start of ScriptEngine_DoScript

`ScriptEngine_DoScript` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;.Call('R_swig_ScriptEngine_DoScript', self, command, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptEngine_DoScript`, 'returnType') = 'character'
attr(`ScriptEngine_DoScript`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_DoScript`) = c("SWIGFunction", class('ScriptEngine_DoScript'))

# Start of ScriptEngine_DoScriptAsync

`ScriptEngine_DoScriptAsync` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;ans = .Call('R_swig_ScriptEngine_DoScriptAsync', self, command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Awaiter", ref=ans);
  
  ans
  
}

attr(`ScriptEngine_DoScriptAsync`, 'returnType') = '_p_Awaiter'
attr(`ScriptEngine_DoScriptAsync`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_DoScriptAsync`) = c("SWIGFunction", class('ScriptEngine_DoScriptAsync'))

# Start of ScriptEngine_PreParseScript

`ScriptEngine_PreParseScript` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;ans = .Call('R_swig_ScriptEngine_PreParseScript', self, command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t", ref=ans);
  
  ans
  
}

attr(`ScriptEngine_PreParseScript`, 'returnType') = '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t'
attr(`ScriptEngine_PreParseScript`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_PreParseScript`) = c("SWIGFunction", class('ScriptEngine_PreParseScript'))

# Start of ScriptEngine_CompatibleFunctions

`ScriptEngine_CompatibleFunctions` = function(self, TypeName, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  TypeName = as(TypeName, "character"); 
  ;.Call('R_swig_ScriptEngine_CompatibleFunctions', self, TypeName, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptEngine_CompatibleFunctions`, 'returnType') = 'character'
attr(`ScriptEngine_CompatibleFunctions`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_CompatibleFunctions`) = c("SWIGFunction", class('ScriptEngine_CompatibleFunctions'))

# Start of ScriptEngine_FunctionsThatStartWith

`ScriptEngine_FunctionsThatStartWith` = function(self, startsWith, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  startsWith = as(startsWith, "character"); 
  ;.Call('R_swig_ScriptEngine_FunctionsThatStartWith', self, startsWith, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptEngine_FunctionsThatStartWith`, 'returnType') = 'character'
attr(`ScriptEngine_FunctionsThatStartWith`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_FunctionsThatStartWith`) = c("SWIGFunction", class('ScriptEngine_FunctionsThatStartWith'))

# Start of ScriptEngine_StopCurrentScript

`ScriptEngine_StopCurrentScript` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_ScriptEngine_StopCurrentScript', self, PACKAGE='Conv');
  
}

attr(`ScriptEngine_StopCurrentScript`, 'returnType') = 'void'
attr(`ScriptEngine_StopCurrentScript`, "inputTypes") = c('_p_ScriptEngine')
class(`ScriptEngine_StopCurrentScript`) = c("SWIGFunction", class('ScriptEngine_StopCurrentScript'))

# Start of ScriptEngine_Cast_String

`ScriptEngine_Cast_String` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;.Call('R_swig_ScriptEngine_Cast_String', self, command, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptEngine_Cast_String`, 'returnType') = 'character'
attr(`ScriptEngine_Cast_String`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_Cast_String`) = c("SWIGFunction", class('ScriptEngine_Cast_String'))

# Start of ScriptEngine_Cast_Color

`ScriptEngine_Cast_Color` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;ans = .Call('R_swig_ScriptEngine_Cast_Color', self, command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptEngine_Cast_Color`, 'returnType') = '_p_Color_Interop'
attr(`ScriptEngine_Cast_Color`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_Cast_Color`) = c("SWIGFunction", class('ScriptEngine_Cast_Color'))

# Start of ScriptEngine_Cast_MapIcon

`ScriptEngine_Cast_MapIcon` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;ans = .Call('R_swig_ScriptEngine_Cast_MapIcon', self, command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapIcon_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptEngine_Cast_MapIcon`, 'returnType') = '_p_MapIcon_Interop'
attr(`ScriptEngine_Cast_MapIcon`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_Cast_MapIcon`) = c("SWIGFunction", class('ScriptEngine_Cast_MapIcon'))

# Start of ScriptEngine_Cast_MapPolyline

`ScriptEngine_Cast_MapPolyline` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;ans = .Call('R_swig_ScriptEngine_Cast_MapPolyline', self, command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapPolyline_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptEngine_Cast_MapPolyline`, 'returnType') = '_p_MapPolyline_Interop'
attr(`ScriptEngine_Cast_MapPolyline`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_Cast_MapPolyline`) = c("SWIGFunction", class('ScriptEngine_Cast_MapPolyline'))

# Start of ScriptEngine_Cast_MapBackground

`ScriptEngine_Cast_MapBackground` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;ans = .Call('R_swig_ScriptEngine_Cast_MapBackground', self, command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapBackground_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptEngine_Cast_MapBackground`, 'returnType') = '_p_MapBackground_Interop'
attr(`ScriptEngine_Cast_MapBackground`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_Cast_MapBackground`) = c("SWIGFunction", class('ScriptEngine_Cast_MapBackground'))

# Start of ScriptEngine_Cast_MapLayer

`ScriptEngine_Cast_MapLayer` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;ans = .Call('R_swig_ScriptEngine_Cast_MapLayer', self, command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapLayer_Interop", ref=ans);
  
  ans
  
}

attr(`ScriptEngine_Cast_MapLayer`, 'returnType') = '_p_MapLayer_Interop'
attr(`ScriptEngine_Cast_MapLayer`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_Cast_MapLayer`) = c("SWIGFunction", class('ScriptEngine_Cast_MapLayer'))

# Start of ScriptEngine_Cast_VectorFloats

`ScriptEngine_Cast_VectorFloats` = function(self, command, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  command = as(command, "character"); 
  ;.Call('R_swig_ScriptEngine_Cast_VectorFloats', self, command, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`ScriptEngine_Cast_VectorFloats`, 'returnType') = 'numeric'
attr(`ScriptEngine_Cast_VectorFloats`, "inputTypes") = c('_p_ScriptEngine', 'character')
class(`ScriptEngine_Cast_VectorFloats`) = c("SWIGFunction", class('ScriptEngine_Cast_VectorFloats'))

# Start of accessor method for ScriptEngine
setMethod('$', '_p_ScriptEngine', function(x, name)

{
  accessorFuns = list('DoScript_Cast_VectorStrings' = ScriptEngine_DoScript_Cast_VectorStrings, 'DoScript_Cast_VectorFloats' = ScriptEngine_DoScript_Cast_VectorFloats, 'DoScript' = ScriptEngine_DoScript, 'DoScriptAsync' = ScriptEngine_DoScriptAsync, 'PreParseScript' = ScriptEngine_PreParseScript, 'CompatibleFunctions' = ScriptEngine_CompatibleFunctions, 'FunctionsThatStartWith' = ScriptEngine_FunctionsThatStartWith, 'StopCurrentScript' = ScriptEngine_StopCurrentScript, 'Cast_String' = ScriptEngine_Cast_String, 'Cast_Color' = ScriptEngine_Cast_Color, 'Cast_MapIcon' = ScriptEngine_Cast_MapIcon, 'Cast_MapPolyline' = ScriptEngine_Cast_MapPolyline, 'Cast_MapBackground' = ScriptEngine_Cast_MapBackground, 'Cast_MapLayer' = ScriptEngine_Cast_MapLayer, 'Cast_VectorFloats' = ScriptEngine_Cast_VectorFloats);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for ScriptEngine
setMethod('delete', '_p_ScriptEngine', function(obj) {delete_ScriptEngine(obj)})
# Start of WaterWatch_SubmitToast

`WaterWatch_SubmitToast` = function(title, content)
{
  title = as(title, "character"); 
  content = as(content, "character"); 
  ;.Call('R_swig_WaterWatch_SubmitToast', title, content, PACKAGE='Conv');
  
}

attr(`WaterWatch_SubmitToast`, 'returnType') = 'void'
attr(`WaterWatch_SubmitToast`, "inputTypes") = c('character', 'character')
class(`WaterWatch_SubmitToast`) = c("SWIGFunction", class('WaterWatch_SubmitToast'))

# Start of WaterWatch_TryGetToast

`WaterWatch_TryGetToast` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatch_TryGetToast', as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_bool_PairT_std__string_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`WaterWatch_TryGetToast`, 'returnType') = '_p_PairT_bool_PairT_std__string_std__string_t_t'
class(`WaterWatch_TryGetToast`) = c("SWIGFunction", class('WaterWatch_TryGetToast'))

# Start of WaterWatch_TryGetAppRequest

`WaterWatch_TryGetAppRequest` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatch_TryGetAppRequest', as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`WaterWatch_TryGetAppRequest`, 'returnType') = '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
class(`WaterWatch_TryGetAppRequest`) = c("SWIGFunction", class('WaterWatch_TryGetAppRequest'))

# Start of WaterWatch_CompleteAppRequest

`WaterWatch_CompleteAppRequest` = function(ID, reply)
{
  ID = as.integer(ID);
  
  if(length(ID) > 1) {
    warning("using only the first element of ID");
  };
  
  reply = as(reply, "character"); 
  ;.Call('R_swig_WaterWatch_CompleteAppRequest', ID, reply, PACKAGE='Conv');
  
}

attr(`WaterWatch_CompleteAppRequest`, 'returnType') = 'void'
attr(`WaterWatch_CompleteAppRequest`, "inputTypes") = c('integer', 'character')
class(`WaterWatch_CompleteAppRequest`) = c("SWIGFunction", class('WaterWatch_CompleteAppRequest'))

# Start of WaterWatch_GetDataDirectory

`WaterWatch_GetDataDirectory` = function(.copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GetDataDirectory', as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetDataDirectory`, 'returnType') = 'character'
class(`WaterWatch_GetDataDirectory`) = c("SWIGFunction", class('WaterWatch_GetDataDirectory'))

# Start of WaterWatch_SetDataDirectory

`WaterWatch_SetDataDirectory` = function(dir)
{
  dir = as(dir, "character"); 
  ;.Call('R_swig_WaterWatch_SetDataDirectory', dir, PACKAGE='Conv');
  
}

attr(`WaterWatch_SetDataDirectory`, 'returnType') = 'void'
attr(`WaterWatch_SetDataDirectory`, "inputTypes") = c('character')
class(`WaterWatch_SetDataDirectory`) = c("SWIGFunction", class('WaterWatch_SetDataDirectory'))

# Start of WaterWatch_GetTemporaryFilePath

`WaterWatch_GetTemporaryFilePath` = function(extension, .copy = FALSE)
{
  extension = as(extension, "character"); 
  ;.Call('R_swig_WaterWatch_GetTemporaryFilePath', extension, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetTemporaryFilePath`, 'returnType') = 'character'
attr(`WaterWatch_GetTemporaryFilePath`, "inputTypes") = c('character')
class(`WaterWatch_GetTemporaryFilePath`) = c("SWIGFunction", class('WaterWatch_GetTemporaryFilePath'))

# Start of WaterWatch_GeocodeAddress

`WaterWatch_GeocodeAddress__SWIG_0` = function(address, .copy = FALSE)
{
  address = as(address, "character"); 
  ;ans = .Call('R_swig_WaterWatch_GeocodeAddress__SWIG_0', address, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  ans
  
}

attr(`WaterWatch_GeocodeAddress__SWIG_0`, 'returnType') = '_p_PairT_double_double_t'
attr(`WaterWatch_GeocodeAddress__SWIG_0`, "inputTypes") = c('character')
class(`WaterWatch_GeocodeAddress__SWIG_0`) = c("SWIGFunction", class('WaterWatch_GeocodeAddress__SWIG_0'))

# Start of WaterWatch_GeocodeAddress

`WaterWatch_GeocodeAddress__SWIG_1` = function(longitude, latitude, .copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GeocodeAddress__SWIG_1', longitude, latitude, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GeocodeAddress__SWIG_1`, 'returnType') = 'character'
attr(`WaterWatch_GeocodeAddress__SWIG_1`, "inputTypes") = c('numeric', 'numeric')
class(`WaterWatch_GeocodeAddress__SWIG_1`) = c("SWIGFunction", class('WaterWatch_GeocodeAddress__SWIG_1'))

`WaterWatch_GeocodeAddress` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 1) {
    if ( is.character(argv[[1]]) && length(argv[[1]]) == 1 ) {
      f <- WaterWatch_GeocodeAddress__SWIG_0; 
    }
  } else if (argc == 2) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- WaterWatch_GeocodeAddress__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for WaterWatch_GeocodeAddress with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of WaterWatch_GeocodeElevation

`WaterWatch_GeocodeElevation` = function(longitude, latitude, .copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GeocodeElevation', longitude, latitude, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GeocodeElevation`, 'returnType') = 'numeric'
attr(`WaterWatch_GeocodeElevation`, "inputTypes") = c('numeric', 'numeric')
class(`WaterWatch_GeocodeElevation`) = c("SWIGFunction", class('WaterWatch_GeocodeElevation'))

# Start of WaterWatch_ValidateCoordinates

`WaterWatch_ValidateCoordinates` = function(longitude, latitude, .copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatch_ValidateCoordinates', longitude, latitude, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  ans
  
}

attr(`WaterWatch_ValidateCoordinates`, 'returnType') = '_p_PairT_double_double_t'
attr(`WaterWatch_ValidateCoordinates`, "inputTypes") = c('numeric', 'numeric')
class(`WaterWatch_ValidateCoordinates`) = c("SWIGFunction", class('WaterWatch_ValidateCoordinates'))

# Start of WaterWatch_Encode_2D_to_1D

`WaterWatch_Encode_2D_to_1D` = function(x, y, H, .copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_Encode_2D_to_1D', x, y, H, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_Encode_2D_to_1D`, 'returnType') = 'numeric'
attr(`WaterWatch_Encode_2D_to_1D`, "inputTypes") = c('numeric', 'numeric', 'numeric')
class(`WaterWatch_Encode_2D_to_1D`) = c("SWIGFunction", class('WaterWatch_Encode_2D_to_1D'))

# Start of WaterWatch_Decode_1D_to_2D

`WaterWatch_Decode_1D_to_2D` = function(l, H, .copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatch_Decode_1D_to_2D', l, H, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  ans
  
}

attr(`WaterWatch_Decode_1D_to_2D`, 'returnType') = '_p_PairT_double_double_t'
attr(`WaterWatch_Decode_1D_to_2D`, "inputTypes") = c('numeric', 'numeric')
class(`WaterWatch_Decode_1D_to_2D`) = c("SWIGFunction", class('WaterWatch_Decode_1D_to_2D'))

# Start of WaterWatch_PredictNext

`WaterWatch_PredictNext` = function(data, nextN, .copy = FALSE)
{
  data = as.numeric(data);
  nextN = as.integer(nextN);
  
  if(length(nextN) > 1) {
    warning("using only the first element of nextN");
  };
  
  ;.Call('R_swig_WaterWatch_PredictNext', data, nextN, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_PredictNext`, 'returnType') = 'numeric'
attr(`WaterWatch_PredictNext`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`WaterWatch_PredictNext`) = c("SWIGFunction", class('WaterWatch_PredictNext'))

# Start of WaterWatch_getCurrentTime

`WaterWatch_getCurrentTime` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_WaterWatch_getCurrentTime', as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_cweeDateTime", ref=ans);
  
  ans
  
}

attr(`WaterWatch_getCurrentTime`, 'returnType') = '_p_cweeDateTime'
class(`WaterWatch_getCurrentTime`) = c("SWIGFunction", class('WaterWatch_getCurrentTime'))

# Start of WaterWatch_RandomInt

`WaterWatch_RandomInt` = function(min, max, .copy = FALSE)
{
  min = as.integer(min);
  
  if(length(min) > 1) {
    warning("using only the first element of min");
  };
  
  max = as.integer(max);
  
  if(length(max) > 1) {
    warning("using only the first element of max");
  };
  
  ;.Call('R_swig_WaterWatch_RandomInt', min, max, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_RandomInt`, 'returnType') = 'integer'
attr(`WaterWatch_RandomInt`, "inputTypes") = c('integer', 'integer')
class(`WaterWatch_RandomInt`) = c("SWIGFunction", class('WaterWatch_RandomInt'))

# Start of WaterWatch_RandomFloat

`WaterWatch_RandomFloat` = function(min, max, .copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_RandomFloat', min, max, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_RandomFloat`, 'returnType') = 'numeric'
attr(`WaterWatch_RandomFloat`, "inputTypes") = c('numeric', 'numeric')
class(`WaterWatch_RandomFloat`) = c("SWIGFunction", class('WaterWatch_RandomFloat'))

# Start of WaterWatch_GetBestMatch

`WaterWatch_GetBestMatch` = function(input, options, .copy = FALSE)
{
  input = as(input, "character"); 
  if (inherits(options, "ExternalReference")) options = slot(options,"ref"); 
  ;.Call('R_swig_WaterWatch_GetBestMatch', input, options, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetBestMatch`, 'returnType') = 'character'
attr(`WaterWatch_GetBestMatch`, "inputTypes") = c('character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`WaterWatch_GetBestMatch`) = c("SWIGFunction", class('WaterWatch_GetBestMatch'))

# Start of WaterWatch_GetNumMultithreadingCores

`WaterWatch_GetNumMultithreadingCores` = function(.copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GetNumMultithreadingCores', as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetNumMultithreadingCores`, 'returnType') = 'integer'
class(`WaterWatch_GetNumMultithreadingCores`) = c("SWIGFunction", class('WaterWatch_GetNumMultithreadingCores'))

# Start of WaterWatch_GetNumLogicalCoresOnMachine

`WaterWatch_GetNumLogicalCoresOnMachine` = function(.copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GetNumLogicalCoresOnMachine', as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetNumLogicalCoresOnMachine`, 'returnType') = 'integer'
class(`WaterWatch_GetNumLogicalCoresOnMachine`) = c("SWIGFunction", class('WaterWatch_GetNumLogicalCoresOnMachine'))

# Start of WaterWatch_GetNumPhysicalCoresOnMachine

`WaterWatch_GetNumPhysicalCoresOnMachine` = function(.copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GetNumPhysicalCoresOnMachine', as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetNumPhysicalCoresOnMachine`, 'returnType') = 'integer'
class(`WaterWatch_GetNumPhysicalCoresOnMachine`) = c("SWIGFunction", class('WaterWatch_GetNumPhysicalCoresOnMachine'))

# Start of WaterWatch_GetPercentMemoryUsedOfMachine

`WaterWatch_GetPercentMemoryUsedOfMachine` = function(.copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GetPercentMemoryUsedOfMachine', as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetPercentMemoryUsedOfMachine`, 'returnType') = 'numeric'
class(`WaterWatch_GetPercentMemoryUsedOfMachine`) = c("SWIGFunction", class('WaterWatch_GetPercentMemoryUsedOfMachine'))

# Start of WaterWatch_GetPercentCpuUsedOfMachine

`WaterWatch_GetPercentCpuUsedOfMachine` = function(.copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GetPercentCpuUsedOfMachine', as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetPercentCpuUsedOfMachine`, 'returnType') = 'numeric'
class(`WaterWatch_GetPercentCpuUsedOfMachine`) = c("SWIGFunction", class('WaterWatch_GetPercentCpuUsedOfMachine'))

# Start of WaterWatch_DoScript

`WaterWatch_DoScript` = function(command, .copy = FALSE)
{
  command = as(command, "character"); 
  ;ans = .Call('R_swig_WaterWatch_DoScript', command, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Awaiter", ref=ans);
  
  ans
  
}

attr(`WaterWatch_DoScript`, 'returnType') = '_p_Awaiter'
attr(`WaterWatch_DoScript`, "inputTypes") = c('character')
class(`WaterWatch_DoScript`) = c("SWIGFunction", class('WaterWatch_DoScript'))

# Start of WaterWatch_DoScriptImmediately

`WaterWatch_DoScriptImmediately` = function(command, .copy = FALSE)
{
  command = as(command, "character"); 
  ;.Call('R_swig_WaterWatch_DoScriptImmediately', command, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_DoScriptImmediately`, 'returnType') = 'character'
attr(`WaterWatch_DoScriptImmediately`, "inputTypes") = c('character')
class(`WaterWatch_DoScriptImmediately`) = c("SWIGFunction", class('WaterWatch_DoScriptImmediately'))

# Start of WaterWatch_AddToLog

`WaterWatch_AddToLog` = function(filePath, content)
{
  filePath = as(filePath, "character"); 
  content = as(content, "character"); 
  ;.Call('R_swig_WaterWatch_AddToLog', filePath, content, PACKAGE='Conv');
  
}

attr(`WaterWatch_AddToLog`, 'returnType') = 'void'
attr(`WaterWatch_AddToLog`, "inputTypes") = c('character', 'character')
class(`WaterWatch_AddToLog`) = c("SWIGFunction", class('WaterWatch_AddToLog'))

# Start of WaterWatch_GetNanosecondsSinceStart

`WaterWatch_GetNanosecondsSinceStart` = function(.copy = FALSE)
{
  ;.Call('R_swig_WaterWatch_GetNanosecondsSinceStart', as.logical(.copy), PACKAGE='Conv');
  
}

attr(`WaterWatch_GetNanosecondsSinceStart`, 'returnType') = 'numeric'
class(`WaterWatch_GetNanosecondsSinceStart`) = c("SWIGFunction", class('WaterWatch_GetNanosecondsSinceStart'))

# Start of new_WaterWatch

`WaterWatch` = function()
{
  ;ans = .Call('R_swig_new_WaterWatch', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_WaterWatch", ref=ans);
  
  reg.finalizer(ans@ref, delete_WaterWatch);
  ans
  
}

attr(`WaterWatch`, 'returnType') = '_p_WaterWatch'
class(`WaterWatch`) = c("SWIGFunction", class('WaterWatch'))

# Start of delete_WaterWatch

`delete_WaterWatch` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_WaterWatch', self, PACKAGE='Conv');
  
}

attr(`delete_WaterWatch`, 'returnType') = 'void'
attr(`delete_WaterWatch`, "inputTypes") = c('_p_WaterWatch')
class(`delete_WaterWatch`) = c("SWIGFunction", class('delete_WaterWatch'))

setMethod('delete', '_p_WaterWatch', function(obj) {delete_WaterWatch(obj)})
# Start of vector_string___nonzero__

`vector_string___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string___nonzero__`, 'returnType') = 'logical'
attr(`vector_string___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string___nonzero__`) = c("SWIGFunction", class('vector_string___nonzero__'))

# Start of vector_string___len__

`vector_string___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string___len__`, 'returnType') = 'integer'
attr(`vector_string___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string___len__`) = c("SWIGFunction", class('vector_string___len__'))

# Start of vector_string_pop

`vector_string_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_pop', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string_pop`, 'returnType') = 'character'
attr(`vector_string_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_pop`) = c("SWIGFunction", class('vector_string_pop'))

# Start of vector_string___getslice__

`vector_string___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_vector_string___getslice__', self, i, j, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`vector_string___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`vector_string___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`vector_string___getslice__`) = c("SWIGFunction", class('vector_string___getslice__'))

# Start of vector_string___setslice__

`vector_string___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_string___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_string___setslice__`, 'returnType') = 'void'
attr(`vector_string___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string___setslice__`) = c("SWIGFunction", class('vector_string___setslice__'))

# Start of vector_string___delslice__

`vector_string___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_string___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_string___delslice__`, 'returnType') = 'void'
attr(`vector_string___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`vector_string___delslice__`) = c("SWIGFunction", class('vector_string___delslice__'))

# Start of vector_string___delitem__

`vector_string___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_string___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_string___delitem__`, 'returnType') = 'void'
attr(`vector_string___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`vector_string___delitem__`) = c("SWIGFunction", class('vector_string___delitem__'))

# Start of vector_string___getitem__

`vector_string___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_string___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string___getitem__`, 'returnType') = 'character'
attr(`vector_string___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`vector_string___getitem__`) = c("SWIGFunction", class('vector_string___getitem__'))

# Start of vector_string___setitem__

`vector_string___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_vector_string___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_string___setitem__`, 'returnType') = 'void'
attr(`vector_string___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`vector_string___setitem__`) = c("SWIGFunction", class('vector_string___setitem__'))

# Start of vector_string_append

`vector_string_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as(x, "character"); 
  ;.Call('R_swig_vector_string_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_string_append`, 'returnType') = 'void'
attr(`vector_string_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`vector_string_append`) = c("SWIGFunction", class('vector_string_append'))

# Start of new_vector_string

`vector_string__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_vector_string__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_string);
  ans
  
}

attr(`vector_string__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`vector_string__SWIG_0`) = c("SWIGFunction", class('vector_string__SWIG_0'))

# Start of new_vector_string

`vector_string__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_vector_string__SWIG_1', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_string);
  ans
  
}

attr(`vector_string__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`vector_string__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string__SWIG_1`) = c("SWIGFunction", class('vector_string__SWIG_1'))

# Start of vector_string_empty

`vector_string_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string_empty`, 'returnType') = 'logical'
attr(`vector_string_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_empty`) = c("SWIGFunction", class('vector_string_empty'))

# Start of vector_string_size

`vector_string_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string_size`, 'returnType') = 'integer'
attr(`vector_string_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_size`) = c("SWIGFunction", class('vector_string_size'))

# Start of vector_string_swap

`vector_string_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_string_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_string_swap`, 'returnType') = 'void'
attr(`vector_string_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_swap`) = c("SWIGFunction", class('vector_string_swap'))

# Start of vector_string_clear

`vector_string_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_clear', self, PACKAGE='Conv');
  
}

attr(`vector_string_clear`, 'returnType') = 'void'
attr(`vector_string_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_clear`) = c("SWIGFunction", class('vector_string_clear'))

# Start of vector_string_get_allocator

`vector_string_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_string_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`vector_string_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`vector_string_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_get_allocator`) = c("SWIGFunction", class('vector_string_get_allocator'))

# Start of new_vector_string

`vector_string__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_vector_string__SWIG_2', size, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_string);
  ans
  
}

attr(`vector_string__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`vector_string__SWIG_2`, "inputTypes") = c('integer')
class(`vector_string__SWIG_2`) = c("SWIGFunction", class('vector_string__SWIG_2'))

# Start of vector_string_pop_back

`vector_string_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_string_pop_back`, 'returnType') = 'void'
attr(`vector_string_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_pop_back`) = c("SWIGFunction", class('vector_string_pop_back'))

# Start of vector_string_resize

`vector_string_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_string_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_string_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_string_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`vector_string_resize__SWIG_0`) = c("SWIGFunction", class('vector_string_resize__SWIG_0'))

# Start of new_vector_string

`vector_string__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_vector_string__SWIG_3', size, value, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_string);
  ans
  
}

attr(`vector_string__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`vector_string__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`vector_string__SWIG_3`) = c("SWIGFunction", class('vector_string__SWIG_3'))

`vector_string` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_string__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_string__SWIG_2; 
    }
    else if ( extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1 ) {
      f <- vector_string__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.character(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- vector_string__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_string with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_string_push_back

`vector_string_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as(x, "character"); 
  ;.Call('R_swig_vector_string_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_string_push_back`, 'returnType') = 'void'
attr(`vector_string_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`vector_string_push_back`) = c("SWIGFunction", class('vector_string_push_back'))

# Start of vector_string_front

`vector_string_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_front', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string_front`, 'returnType') = 'character'
attr(`vector_string_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_front`) = c("SWIGFunction", class('vector_string_front'))

# Start of vector_string_back

`vector_string_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_back', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string_back`, 'returnType') = 'character'
attr(`vector_string_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_back`) = c("SWIGFunction", class('vector_string_back'))

# Start of vector_string_assign

`vector_string_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_vector_string_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_string_assign`, 'returnType') = 'void'
attr(`vector_string_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`vector_string_assign`) = c("SWIGFunction", class('vector_string_assign'))

# Start of vector_string_resize

`vector_string_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_vector_string_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_string_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_string_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`vector_string_resize__SWIG_1`) = c("SWIGFunction", class('vector_string_resize__SWIG_1'))

`vector_string_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_string_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.character(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- vector_string_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_string_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_string_reserve

`vector_string_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_string_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_string_reserve`, 'returnType') = 'void'
attr(`vector_string_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`vector_string_reserve`) = c("SWIGFunction", class('vector_string_reserve'))

# Start of vector_string_capacity

`vector_string_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_string_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_string_capacity`, 'returnType') = 'integer'
attr(`vector_string_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`vector_string_capacity`) = c("SWIGFunction", class('vector_string_capacity'))

# Start of delete_vector_string

`delete_vector_string` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_vector_string', self, PACKAGE='Conv');
  
}

attr(`delete_vector_string`, 'returnType') = 'void'
attr(`delete_vector_string`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_vector_string`) = c("SWIGFunction", class('delete_vector_string'))

# Start of accessor method for std::vector< std::string >
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_string___nonzero__, '__len__' = vector_string___len__, 'pop' = vector_string_pop, '__getslice__' = vector_string___getslice__, '__setslice__' = vector_string___setslice__, '__delslice__' = vector_string___delslice__, '__delitem__' = vector_string___delitem__, '__getitem__' = vector_string___getitem__, '__setitem__' = vector_string___setitem__, 'append' = vector_string_append, 'empty' = vector_string_empty, 'size' = vector_string_size, 'swap' = vector_string_swap, 'clear' = vector_string_clear, 'get_allocator' = vector_string_get_allocator, 'pop_back' = vector_string_pop_back, 'resize' = vector_string_resize, 'push_back' = vector_string_push_back, 'front' = vector_string_front, 'back' = vector_string_back, 'assign' = vector_string_assign, 'reserve' = vector_string_reserve, 'capacity' = vector_string_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< std::string >
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of new_pair_timeseries

`pair_timeseries__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_pair_timeseries__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_timeseries);
  ans
  
}

attr(`pair_timeseries__SWIG_0`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
class(`pair_timeseries__SWIG_0`) = c("SWIGFunction", class('pair_timeseries__SWIG_0'))

# Start of new_pair_timeseries

`pair_timeseries__SWIG_1` = function(t1, t2)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref"); 
  
  ;ans = .Call('R_swig_new_pair_timeseries__SWIG_1', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_timeseries);
  ans
  
}

attr(`pair_timeseries__SWIG_1`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
attr(`pair_timeseries__SWIG_1`, "inputTypes") = c('_p_cweeDateTime', 'numeric')
class(`pair_timeseries__SWIG_1`) = c("SWIGFunction", class('pair_timeseries__SWIG_1'))

# Start of new_pair_timeseries

`pair_timeseries__SWIG_2` = function(t1, t2)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref"); 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_timeseries__SWIG_2', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_timeseries);
  ans
  
}

attr(`pair_timeseries__SWIG_2`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
attr(`pair_timeseries__SWIG_2`, "inputTypes") = c('_p_cweeDateTime', '_p_float')
class(`pair_timeseries__SWIG_2`) = c("SWIGFunction", class('pair_timeseries__SWIG_2'))

# Start of new_pair_timeseries

`pair_timeseries__SWIG_3` = function(t)
{
  if (inherits(t, "ExternalReference")) t = slot(t,"ref"); 
  ;ans = .Call('R_swig_new_pair_timeseries__SWIG_3', t, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_timeseries);
  ans
  
}

attr(`pair_timeseries__SWIG_3`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
attr(`pair_timeseries__SWIG_3`, "inputTypes") = c('_p_std__pairT_cweeDateTime_float_t')
class(`pair_timeseries__SWIG_3`) = c("SWIGFunction", class('pair_timeseries__SWIG_3'))

`pair_timeseries` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- pair_timeseries__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__pairT_cweeDateTime_float_t') && length(argv[[1]]) == 1 ) {
      f <- pair_timeseries__SWIG_3; 
    }
  } else if (argc == 2) {
    if (( extends(argtypes[1], '_p_cweeDateTime') && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_float') && length(argv[[2]]) == 1 )) {
      f <- pair_timeseries__SWIG_2; 
    }
    else if (( extends(argtypes[1], '_p_cweeDateTime') && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- pair_timeseries__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for pair_timeseries with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of pair_timeseries_first_set

`pair_timeseries_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_first, "ExternalReference")) s_first = slot(s_first,"ref"); 
  ;.Call('R_swig_pair_timeseries_first_set', self, s_first, PACKAGE='Conv');
  
}

attr(`pair_timeseries_first_set`, 'returnType') = 'void'
attr(`pair_timeseries_first_set`, "inputTypes") = c('_p_PairT_cweeDateTime_float_t', '_p_cweeDateTime')
class(`pair_timeseries_first_set`) = c("SWIGFunction", class('pair_timeseries_first_set'))

# Start of pair_timeseries_first_get

`pair_timeseries_first_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_pair_timeseries_first_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_cweeDateTime", ref=ans);
  
  ans
  
}

attr(`pair_timeseries_first_get`, 'returnType') = '_p_cweeDateTime'
attr(`pair_timeseries_first_get`, "inputTypes") = c('_p_PairT_cweeDateTime_float_t')
class(`pair_timeseries_first_get`) = c("SWIGFunction", class('pair_timeseries_first_get'))

# Start of pair_timeseries_second_set

`pair_timeseries_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_pair_timeseries_second_set', self, s_second, PACKAGE='Conv');
  
}

attr(`pair_timeseries_second_set`, 'returnType') = 'void'
attr(`pair_timeseries_second_set`, "inputTypes") = c('_p_PairT_cweeDateTime_float_t', 'numeric')
class(`pair_timeseries_second_set`) = c("SWIGFunction", class('pair_timeseries_second_set'))

# Start of pair_timeseries_second_get

`pair_timeseries_second_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_timeseries_second_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_timeseries_second_get`, 'returnType') = 'numeric'
attr(`pair_timeseries_second_get`, "inputTypes") = c('_p_PairT_cweeDateTime_float_t')
class(`pair_timeseries_second_get`) = c("SWIGFunction", class('pair_timeseries_second_get'))

# Start of delete_pair_timeseries

`delete_pair_timeseries` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_pair_timeseries', self, PACKAGE='Conv');
  
}

attr(`delete_pair_timeseries`, 'returnType') = 'void'
attr(`delete_pair_timeseries`, "inputTypes") = c('_p_PairT_cweeDateTime_float_t')
class(`delete_pair_timeseries`) = c("SWIGFunction", class('delete_pair_timeseries'))

# Start of accessor method for Pair< cweeDateTime,float >
setMethod('$', '_p_PairT_cweeDateTime_float_t', function(x, name)

{
  accessorFuns = list('first' = pair_timeseries_first_get, 'second' = pair_timeseries_second_get);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Pair< cweeDateTime,float >
# Start of accessor method for Pair< cweeDateTime,float >
setMethod('$<-', '_p_PairT_cweeDateTime_float_t', function(x, name, value)

{
  accessorFuns = list('first' = pair_timeseries_first_set, 'second' = pair_timeseries_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PairT_cweeDateTime_float_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = pair_timeseries_first_set, 'second' = pair_timeseries_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Pair< cweeDateTime,float >
setMethod('delete', '_p_PairT_cweeDateTime_float_t', function(obj) {delete_PairT_cweeDateTime_float_t(obj)})
# Start of new_pair_string_vector_string

`pair_string_vector_string__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_pair_string_vector_string__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_vector_string);
  ans
  
}

attr(`pair_string_vector_string__SWIG_0`, 'returnType') = '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t'
class(`pair_string_vector_string__SWIG_0`) = c("SWIGFunction", class('pair_string_vector_string__SWIG_0'))

# Start of new_pair_string_vector_string

`pair_string_vector_string__SWIG_1` = function(t1, t2)
{
  t1 = as(t1, "character"); 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_string_vector_string__SWIG_1', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_vector_string);
  ans
  
}

attr(`pair_string_vector_string__SWIG_1`, 'returnType') = '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t'
attr(`pair_string_vector_string__SWIG_1`, "inputTypes") = c('character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`pair_string_vector_string__SWIG_1`) = c("SWIGFunction", class('pair_string_vector_string__SWIG_1'))

# Start of new_pair_string_vector_string

`pair_string_vector_string__SWIG_2` = function(t1, t2)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref"); 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_string_vector_string__SWIG_2', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_vector_string);
  ans
  
}

attr(`pair_string_vector_string__SWIG_2`, 'returnType') = '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t'
attr(`pair_string_vector_string__SWIG_2`, "inputTypes") = c('_p_std__string', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`pair_string_vector_string__SWIG_2`) = c("SWIGFunction", class('pair_string_vector_string__SWIG_2'))

# Start of new_pair_string_vector_string

`pair_string_vector_string__SWIG_3` = function(t)
{
  if (inherits(t, "ExternalReference")) t = slot(t,"ref"); 
  ;ans = .Call('R_swig_new_pair_string_vector_string__SWIG_3', t, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_vector_string);
  ans
  
}

attr(`pair_string_vector_string__SWIG_3`, 'returnType') = '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t'
attr(`pair_string_vector_string__SWIG_3`, "inputTypes") = c('_p_std__pairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t')
class(`pair_string_vector_string__SWIG_3`) = c("SWIGFunction", class('pair_string_vector_string__SWIG_3'))

`pair_string_vector_string` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- pair_string_vector_string__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__pairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t') && length(argv[[1]]) == 1 ) {
      f <- pair_string_vector_string__SWIG_3; 
    }
  } else if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__string') && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[2]]) == 1 )) {
      f <- pair_string_vector_string__SWIG_2; 
    }
    else if (( is.character(argv[[1]]) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[2]]) == 1 )) {
      f <- pair_string_vector_string__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for pair_string_vector_string with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of pair_string_vector_string_first_set

`pair_string_vector_string_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_first = as(s_first, "character"); 
  ;.Call('R_swig_pair_string_vector_string_first_set', self, s_first, PACKAGE='Conv');
  
}

attr(`pair_string_vector_string_first_set`, 'returnType') = 'void'
attr(`pair_string_vector_string_first_set`, "inputTypes") = c('_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t', 'character')
class(`pair_string_vector_string_first_set`) = c("SWIGFunction", class('pair_string_vector_string_first_set'))

# Start of pair_string_vector_string_first_get

`pair_string_vector_string_first_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_string_vector_string_first_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_string_vector_string_first_get`, 'returnType') = 'character'
attr(`pair_string_vector_string_first_get`, "inputTypes") = c('_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t')
class(`pair_string_vector_string_first_get`) = c("SWIGFunction", class('pair_string_vector_string_first_get'))

# Start of pair_string_vector_string_second_set

`pair_string_vector_string_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_second, "ExternalReference")) s_second = slot(s_second,"ref"); 
  ;.Call('R_swig_pair_string_vector_string_second_set', self, s_second, PACKAGE='Conv');
  
}

attr(`pair_string_vector_string_second_set`, 'returnType') = 'void'
attr(`pair_string_vector_string_second_set`, "inputTypes") = c('_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`pair_string_vector_string_second_set`) = c("SWIGFunction", class('pair_string_vector_string_second_set'))

# Start of pair_string_vector_string_second_get

`pair_string_vector_string_second_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_pair_string_vector_string_second_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`pair_string_vector_string_second_get`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`pair_string_vector_string_second_get`, "inputTypes") = c('_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t')
class(`pair_string_vector_string_second_get`) = c("SWIGFunction", class('pair_string_vector_string_second_get'))

# Start of delete_pair_string_vector_string

`delete_pair_string_vector_string` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_pair_string_vector_string', self, PACKAGE='Conv');
  
}

attr(`delete_pair_string_vector_string`, 'returnType') = 'void'
attr(`delete_pair_string_vector_string`, "inputTypes") = c('_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t')
class(`delete_pair_string_vector_string`) = c("SWIGFunction", class('delete_pair_string_vector_string'))

# Start of accessor method for Pair< std::string,std::vector< std::string > >
setMethod('$', '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t', function(x, name)

{
  accessorFuns = list('first' = pair_string_vector_string_first_get, 'second' = pair_string_vector_string_second_get);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Pair< std::string,std::vector< std::string > >
# Start of accessor method for Pair< std::string,std::vector< std::string > >
setMethod('$<-', '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t', function(x, name, value)

{
  accessorFuns = list('first' = pair_string_vector_string_first_set, 'second' = pair_string_vector_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = pair_string_vector_string_first_set, 'second' = pair_string_vector_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Pair< std::string,std::vector< std::string > >
setMethod('delete', '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t', function(obj) {delete_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t(obj)})
# Start of new_pair_int_pair_string_vector_string

`pair_int_pair_string_vector_string__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_pair_int_pair_string_vector_string__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_int_pair_string_vector_string);
  ans
  
}

attr(`pair_int_pair_string_vector_string__SWIG_0`, 'returnType') = '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
class(`pair_int_pair_string_vector_string__SWIG_0`) = c("SWIGFunction", class('pair_int_pair_string_vector_string__SWIG_0'))

# Start of new_pair_int_pair_string_vector_string

`pair_int_pair_string_vector_string__SWIG_1` = function(t1, t2)
{
  t1 = as.integer(t1);
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_int_pair_string_vector_string__SWIG_1', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_int_pair_string_vector_string);
  ans
  
}

attr(`pair_int_pair_string_vector_string__SWIG_1`, 'returnType') = '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
attr(`pair_int_pair_string_vector_string__SWIG_1`, "inputTypes") = c('integer', '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t')
class(`pair_int_pair_string_vector_string__SWIG_1`) = c("SWIGFunction", class('pair_int_pair_string_vector_string__SWIG_1'))

# Start of new_pair_int_pair_string_vector_string

`pair_int_pair_string_vector_string__SWIG_2` = function(t1, t2)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref"); 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_int_pair_string_vector_string__SWIG_2', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_int_pair_string_vector_string);
  ans
  
}

attr(`pair_int_pair_string_vector_string__SWIG_2`, 'returnType') = '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
attr(`pair_int_pair_string_vector_string__SWIG_2`, "inputTypes") = c('_p_int', '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t')
class(`pair_int_pair_string_vector_string__SWIG_2`) = c("SWIGFunction", class('pair_int_pair_string_vector_string__SWIG_2'))

# Start of new_pair_int_pair_string_vector_string

`pair_int_pair_string_vector_string__SWIG_3` = function(t)
{
  if (inherits(t, "ExternalReference")) t = slot(t,"ref"); 
  ;ans = .Call('R_swig_new_pair_int_pair_string_vector_string__SWIG_3', t, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_int_pair_string_vector_string);
  ans
  
}

attr(`pair_int_pair_string_vector_string__SWIG_3`, 'returnType') = '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
attr(`pair_int_pair_string_vector_string__SWIG_3`, "inputTypes") = c('_p_std__pairT_int_PairT_std__string_std__vectorT_std__string_t_t_t')
class(`pair_int_pair_string_vector_string__SWIG_3`) = c("SWIGFunction", class('pair_int_pair_string_vector_string__SWIG_3'))

`pair_int_pair_string_vector_string` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- pair_int_pair_string_vector_string__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__pairT_int_PairT_std__string_std__vectorT_std__string_t_t_t') && length(argv[[1]]) == 1 ) {
      f <- pair_int_pair_string_vector_string__SWIG_3; 
    }
  } else if (argc == 2) {
    if (( extends(argtypes[1], '_p_int') && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t') && length(argv[[2]]) == 1 )) {
      f <- pair_int_pair_string_vector_string__SWIG_2; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t') && length(argv[[2]]) == 1 )) {
      f <- pair_int_pair_string_vector_string__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for pair_int_pair_string_vector_string with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of pair_int_pair_string_vector_string_first_set

`pair_int_pair_string_vector_string_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_first = as.integer(s_first);
  
  if(length(s_first) > 1) {
    warning("using only the first element of s_first");
  };
  
  ;.Call('R_swig_pair_int_pair_string_vector_string_first_set', self, s_first, PACKAGE='Conv');
  
}

attr(`pair_int_pair_string_vector_string_first_set`, 'returnType') = 'void'
attr(`pair_int_pair_string_vector_string_first_set`, "inputTypes") = c('_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer')
class(`pair_int_pair_string_vector_string_first_set`) = c("SWIGFunction", class('pair_int_pair_string_vector_string_first_set'))

# Start of pair_int_pair_string_vector_string_first_get

`pair_int_pair_string_vector_string_first_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_int_pair_string_vector_string_first_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_int_pair_string_vector_string_first_get`, 'returnType') = 'integer'
attr(`pair_int_pair_string_vector_string_first_get`, "inputTypes") = c('_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`pair_int_pair_string_vector_string_first_get`) = c("SWIGFunction", class('pair_int_pair_string_vector_string_first_get'))

# Start of pair_int_pair_string_vector_string_second_set

`pair_int_pair_string_vector_string_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_second, "ExternalReference")) s_second = slot(s_second,"ref"); 
  ;.Call('R_swig_pair_int_pair_string_vector_string_second_set', self, s_second, PACKAGE='Conv');
  
}

attr(`pair_int_pair_string_vector_string_second_set`, 'returnType') = 'void'
attr(`pair_int_pair_string_vector_string_second_set`, "inputTypes") = c('_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t')
class(`pair_int_pair_string_vector_string_second_set`) = c("SWIGFunction", class('pair_int_pair_string_vector_string_second_set'))

# Start of pair_int_pair_string_vector_string_second_get

`pair_int_pair_string_vector_string_second_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_pair_int_pair_string_vector_string_second_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t", ref=ans);
  
  ans
  
}

attr(`pair_int_pair_string_vector_string_second_get`, 'returnType') = '_p_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t'
attr(`pair_int_pair_string_vector_string_second_get`, "inputTypes") = c('_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`pair_int_pair_string_vector_string_second_get`) = c("SWIGFunction", class('pair_int_pair_string_vector_string_second_get'))

# Start of delete_pair_int_pair_string_vector_string

`delete_pair_int_pair_string_vector_string` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_pair_int_pair_string_vector_string', self, PACKAGE='Conv');
  
}

attr(`delete_pair_int_pair_string_vector_string`, 'returnType') = 'void'
attr(`delete_pair_int_pair_string_vector_string`, "inputTypes") = c('_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`delete_pair_int_pair_string_vector_string`) = c("SWIGFunction", class('delete_pair_int_pair_string_vector_string'))

# Start of accessor method for Pair< int,Pair< std::string,std::vector< std::string > > >
setMethod('$', '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', function(x, name)

{
  accessorFuns = list('first' = pair_int_pair_string_vector_string_first_get, 'second' = pair_int_pair_string_vector_string_second_get);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Pair< int,Pair< std::string,std::vector< std::string > > >
# Start of accessor method for Pair< int,Pair< std::string,std::vector< std::string > > >
setMethod('$<-', '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', function(x, name, value)

{
  accessorFuns = list('first' = pair_int_pair_string_vector_string_first_set, 'second' = pair_int_pair_string_vector_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = pair_int_pair_string_vector_string_first_set, 'second' = pair_int_pair_string_vector_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Pair< int,Pair< std::string,std::vector< std::string > > >
setMethod('delete', '_p_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', function(obj) {delete_PairT_int_PairT_std__string_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t(obj)})
# Start of new_pair_double_double

`pair_double_double__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_pair_double_double__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_double_double);
  ans
  
}

attr(`pair_double_double__SWIG_0`, 'returnType') = '_p_PairT_double_double_t'
class(`pair_double_double__SWIG_0`) = c("SWIGFunction", class('pair_double_double__SWIG_0'))

# Start of new_pair_double_double

`pair_double_double__SWIG_1` = function(t1, t2)
{
  ;ans = .Call('R_swig_new_pair_double_double__SWIG_1', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_double_double);
  ans
  
}

attr(`pair_double_double__SWIG_1`, 'returnType') = '_p_PairT_double_double_t'
attr(`pair_double_double__SWIG_1`, "inputTypes") = c('numeric', 'numeric')
class(`pair_double_double__SWIG_1`) = c("SWIGFunction", class('pair_double_double__SWIG_1'))

# Start of new_pair_double_double

`pair_double_double__SWIG_2` = function(t1, t2)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref"); 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_double_double__SWIG_2', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_double_double);
  ans
  
}

attr(`pair_double_double__SWIG_2`, 'returnType') = '_p_PairT_double_double_t'
attr(`pair_double_double__SWIG_2`, "inputTypes") = c('_p_double', '_p_double')
class(`pair_double_double__SWIG_2`) = c("SWIGFunction", class('pair_double_double__SWIG_2'))

# Start of new_pair_double_double

`pair_double_double__SWIG_3` = function(t)
{
  if (inherits(t, "ExternalReference")) t = slot(t,"ref"); 
  ;ans = .Call('R_swig_new_pair_double_double__SWIG_3', t, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_double_double);
  ans
  
}

attr(`pair_double_double__SWIG_3`, 'returnType') = '_p_PairT_double_double_t'
attr(`pair_double_double__SWIG_3`, "inputTypes") = c('_p_std__pairT_double_double_t')
class(`pair_double_double__SWIG_3`) = c("SWIGFunction", class('pair_double_double__SWIG_3'))

`pair_double_double` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- pair_double_double__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__pairT_double_double_t') && length(argv[[1]]) == 1 ) {
      f <- pair_double_double__SWIG_3; 
    }
  } else if (argc == 2) {
    if (( extends(argtypes[1], '_p_double') && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_double') && length(argv[[2]]) == 1 )) {
      f <- pair_double_double__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- pair_double_double__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for pair_double_double with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of pair_double_double_first_set

`pair_double_double_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_pair_double_double_first_set', self, s_first, PACKAGE='Conv');
  
}

attr(`pair_double_double_first_set`, 'returnType') = 'void'
attr(`pair_double_double_first_set`, "inputTypes") = c('_p_PairT_double_double_t', 'numeric')
class(`pair_double_double_first_set`) = c("SWIGFunction", class('pair_double_double_first_set'))

# Start of pair_double_double_first_get

`pair_double_double_first_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_double_double_first_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_double_double_first_get`, 'returnType') = 'numeric'
attr(`pair_double_double_first_get`, "inputTypes") = c('_p_PairT_double_double_t')
class(`pair_double_double_first_get`) = c("SWIGFunction", class('pair_double_double_first_get'))

# Start of pair_double_double_second_set

`pair_double_double_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_pair_double_double_second_set', self, s_second, PACKAGE='Conv');
  
}

attr(`pair_double_double_second_set`, 'returnType') = 'void'
attr(`pair_double_double_second_set`, "inputTypes") = c('_p_PairT_double_double_t', 'numeric')
class(`pair_double_double_second_set`) = c("SWIGFunction", class('pair_double_double_second_set'))

# Start of pair_double_double_second_get

`pair_double_double_second_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_double_double_second_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_double_double_second_get`, 'returnType') = 'numeric'
attr(`pair_double_double_second_get`, "inputTypes") = c('_p_PairT_double_double_t')
class(`pair_double_double_second_get`) = c("SWIGFunction", class('pair_double_double_second_get'))

# Start of delete_pair_double_double

`delete_pair_double_double` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_pair_double_double', self, PACKAGE='Conv');
  
}

attr(`delete_pair_double_double`, 'returnType') = 'void'
attr(`delete_pair_double_double`, "inputTypes") = c('_p_PairT_double_double_t')
class(`delete_pair_double_double`) = c("SWIGFunction", class('delete_pair_double_double'))

# Start of accessor method for Pair< double,double >
setMethod('$', '_p_PairT_double_double_t', function(x, name)

{
  accessorFuns = list('first' = pair_double_double_first_get, 'second' = pair_double_double_second_get);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Pair< double,double >
# Start of accessor method for Pair< double,double >
setMethod('$<-', '_p_PairT_double_double_t', function(x, name, value)

{
  accessorFuns = list('first' = pair_double_double_first_set, 'second' = pair_double_double_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PairT_double_double_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = pair_double_double_first_set, 'second' = pair_double_double_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Pair< double,double >
setMethod('delete', '_p_PairT_double_double_t', function(obj) {delete_PairT_double_double_t(obj)})
# Start of new_pair_string_string

`pair_string_string__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_pair_string_string__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__string_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_string);
  ans
  
}

attr(`pair_string_string__SWIG_0`, 'returnType') = '_p_PairT_std__string_std__string_t'
class(`pair_string_string__SWIG_0`) = c("SWIGFunction", class('pair_string_string__SWIG_0'))

# Start of new_pair_string_string

`pair_string_string__SWIG_1` = function(t1, t2)
{
  t1 = as(t1, "character"); 
  t2 = as(t2, "character"); 
  ;ans = .Call('R_swig_new_pair_string_string__SWIG_1', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__string_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_string);
  ans
  
}

attr(`pair_string_string__SWIG_1`, 'returnType') = '_p_PairT_std__string_std__string_t'
attr(`pair_string_string__SWIG_1`, "inputTypes") = c('character', 'character')
class(`pair_string_string__SWIG_1`) = c("SWIGFunction", class('pair_string_string__SWIG_1'))

# Start of new_pair_string_string

`pair_string_string__SWIG_2` = function(t1, t2)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref"); 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_string_string__SWIG_2', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__string_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_string);
  ans
  
}

attr(`pair_string_string__SWIG_2`, 'returnType') = '_p_PairT_std__string_std__string_t'
attr(`pair_string_string__SWIG_2`, "inputTypes") = c('_p_std__string', '_p_std__string')
class(`pair_string_string__SWIG_2`) = c("SWIGFunction", class('pair_string_string__SWIG_2'))

# Start of new_pair_string_string

`pair_string_string__SWIG_3` = function(t)
{
  if (inherits(t, "ExternalReference")) t = slot(t,"ref"); 
  ;ans = .Call('R_swig_new_pair_string_string__SWIG_3', t, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__string_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_string_string);
  ans
  
}

attr(`pair_string_string__SWIG_3`, 'returnType') = '_p_PairT_std__string_std__string_t'
attr(`pair_string_string__SWIG_3`, "inputTypes") = c('_p_std__pairT_std__string_std__string_t')
class(`pair_string_string__SWIG_3`) = c("SWIGFunction", class('pair_string_string__SWIG_3'))

`pair_string_string` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- pair_string_string__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__pairT_std__string_std__string_t') && length(argv[[1]]) == 1 ) {
      f <- pair_string_string__SWIG_3; 
    }
  } else if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__string') && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_std__string') && length(argv[[2]]) == 1 )) {
      f <- pair_string_string__SWIG_2; 
    }
    else if (( is.character(argv[[1]]) && length(argv[[1]]) == 1 ) && ( is.character(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- pair_string_string__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for pair_string_string with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of pair_string_string_first_set

`pair_string_string_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_first = as(s_first, "character"); 
  ;.Call('R_swig_pair_string_string_first_set', self, s_first, PACKAGE='Conv');
  
}

attr(`pair_string_string_first_set`, 'returnType') = 'void'
attr(`pair_string_string_first_set`, "inputTypes") = c('_p_PairT_std__string_std__string_t', 'character')
class(`pair_string_string_first_set`) = c("SWIGFunction", class('pair_string_string_first_set'))

# Start of pair_string_string_first_get

`pair_string_string_first_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_string_string_first_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_string_string_first_get`, 'returnType') = 'character'
attr(`pair_string_string_first_get`, "inputTypes") = c('_p_PairT_std__string_std__string_t')
class(`pair_string_string_first_get`) = c("SWIGFunction", class('pair_string_string_first_get'))

# Start of pair_string_string_second_set

`pair_string_string_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_second = as(s_second, "character"); 
  ;.Call('R_swig_pair_string_string_second_set', self, s_second, PACKAGE='Conv');
  
}

attr(`pair_string_string_second_set`, 'returnType') = 'void'
attr(`pair_string_string_second_set`, "inputTypes") = c('_p_PairT_std__string_std__string_t', 'character')
class(`pair_string_string_second_set`) = c("SWIGFunction", class('pair_string_string_second_set'))

# Start of pair_string_string_second_get

`pair_string_string_second_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_string_string_second_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_string_string_second_get`, 'returnType') = 'character'
attr(`pair_string_string_second_get`, "inputTypes") = c('_p_PairT_std__string_std__string_t')
class(`pair_string_string_second_get`) = c("SWIGFunction", class('pair_string_string_second_get'))

# Start of delete_pair_string_string

`delete_pair_string_string` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_pair_string_string', self, PACKAGE='Conv');
  
}

attr(`delete_pair_string_string`, 'returnType') = 'void'
attr(`delete_pair_string_string`, "inputTypes") = c('_p_PairT_std__string_std__string_t')
class(`delete_pair_string_string`) = c("SWIGFunction", class('delete_pair_string_string'))

# Start of accessor method for Pair< std::string,std::string >
setMethod('$', '_p_PairT_std__string_std__string_t', function(x, name)

{
  accessorFuns = list('first' = pair_string_string_first_get, 'second' = pair_string_string_second_get);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Pair< std::string,std::string >
# Start of accessor method for Pair< std::string,std::string >
setMethod('$<-', '_p_PairT_std__string_std__string_t', function(x, name, value)

{
  accessorFuns = list('first' = pair_string_string_first_set, 'second' = pair_string_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PairT_std__string_std__string_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = pair_string_string_first_set, 'second' = pair_string_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Pair< std::string,std::string >
setMethod('delete', '_p_PairT_std__string_std__string_t', function(obj) {delete_PairT_std__string_std__string_t(obj)})
# Start of new_pair_bool_pair_string_string

`pair_bool_pair_string_string__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_pair_bool_pair_string_string__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_bool_PairT_std__string_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_bool_pair_string_string);
  ans
  
}

attr(`pair_bool_pair_string_string__SWIG_0`, 'returnType') = '_p_PairT_bool_PairT_std__string_std__string_t_t'
class(`pair_bool_pair_string_string__SWIG_0`) = c("SWIGFunction", class('pair_bool_pair_string_string__SWIG_0'))

# Start of new_pair_bool_pair_string_string

`pair_bool_pair_string_string__SWIG_1` = function(t1, t2)
{
  t1 = as.logical(t1);
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_bool_pair_string_string__SWIG_1', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_bool_PairT_std__string_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_bool_pair_string_string);
  ans
  
}

attr(`pair_bool_pair_string_string__SWIG_1`, 'returnType') = '_p_PairT_bool_PairT_std__string_std__string_t_t'
attr(`pair_bool_pair_string_string__SWIG_1`, "inputTypes") = c('_p_bool', '_p_PairT_std__string_std__string_t')
class(`pair_bool_pair_string_string__SWIG_1`) = c("SWIGFunction", class('pair_bool_pair_string_string__SWIG_1'))

# Start of new_pair_bool_pair_string_string

`pair_bool_pair_string_string__SWIG_2` = function(t1, t2)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref"); 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref"); 
  ;ans = .Call('R_swig_new_pair_bool_pair_string_string__SWIG_2', t1, t2, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_bool_PairT_std__string_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_bool_pair_string_string);
  ans
  
}

attr(`pair_bool_pair_string_string__SWIG_2`, 'returnType') = '_p_PairT_bool_PairT_std__string_std__string_t_t'
attr(`pair_bool_pair_string_string__SWIG_2`, "inputTypes") = c('_p_bool', '_p_PairT_std__string_std__string_t')
class(`pair_bool_pair_string_string__SWIG_2`) = c("SWIGFunction", class('pair_bool_pair_string_string__SWIG_2'))

# Start of new_pair_bool_pair_string_string

`pair_bool_pair_string_string__SWIG_3` = function(t)
{
  if (inherits(t, "ExternalReference")) t = slot(t,"ref"); 
  ;ans = .Call('R_swig_new_pair_bool_pair_string_string__SWIG_3', t, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_bool_PairT_std__string_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_pair_bool_pair_string_string);
  ans
  
}

attr(`pair_bool_pair_string_string__SWIG_3`, 'returnType') = '_p_PairT_bool_PairT_std__string_std__string_t_t'
attr(`pair_bool_pair_string_string__SWIG_3`, "inputTypes") = c('_p_std__pairT_bool_PairT_std__string_std__string_t_t')
class(`pair_bool_pair_string_string__SWIG_3`) = c("SWIGFunction", class('pair_bool_pair_string_string__SWIG_3'))

`pair_bool_pair_string_string` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- pair_bool_pair_string_string__SWIG_0; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__pairT_bool_PairT_std__string_std__string_t_t') && length(argv[[1]]) == 1 ) {
      f <- pair_bool_pair_string_string__SWIG_3; 
    }
  } else if (argc == 2) {
    if (( extends(argtypes[1], '_p_bool') && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_PairT_std__string_std__string_t') && length(argv[[2]]) == 1 )) {
      f <- pair_bool_pair_string_string__SWIG_2; 
    }
    else if (( is.logical(argv[[1]]) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_PairT_std__string_std__string_t') && length(argv[[2]]) == 1 )) {
      f <- pair_bool_pair_string_string__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for pair_bool_pair_string_string with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of pair_bool_pair_string_string_first_set

`pair_bool_pair_string_string_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_first = as.logical(s_first);
  ;.Call('R_swig_pair_bool_pair_string_string_first_set', self, s_first, PACKAGE='Conv');
  
}

attr(`pair_bool_pair_string_string_first_set`, 'returnType') = 'void'
attr(`pair_bool_pair_string_string_first_set`, "inputTypes") = c('_p_PairT_bool_PairT_std__string_std__string_t_t', 'logical')
class(`pair_bool_pair_string_string_first_set`) = c("SWIGFunction", class('pair_bool_pair_string_string_first_set'))

# Start of pair_bool_pair_string_string_first_get

`pair_bool_pair_string_string_first_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_pair_bool_pair_string_string_first_get', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`pair_bool_pair_string_string_first_get`, 'returnType') = 'logical'
attr(`pair_bool_pair_string_string_first_get`, "inputTypes") = c('_p_PairT_bool_PairT_std__string_std__string_t_t')
class(`pair_bool_pair_string_string_first_get`) = c("SWIGFunction", class('pair_bool_pair_string_string_first_get'))

# Start of pair_bool_pair_string_string_second_set

`pair_bool_pair_string_string_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_second, "ExternalReference")) s_second = slot(s_second,"ref"); 
  ;.Call('R_swig_pair_bool_pair_string_string_second_set', self, s_second, PACKAGE='Conv');
  
}

attr(`pair_bool_pair_string_string_second_set`, 'returnType') = 'void'
attr(`pair_bool_pair_string_string_second_set`, "inputTypes") = c('_p_PairT_bool_PairT_std__string_std__string_t_t', '_p_PairT_std__string_std__string_t')
class(`pair_bool_pair_string_string_second_set`) = c("SWIGFunction", class('pair_bool_pair_string_string_second_set'))

# Start of pair_bool_pair_string_string_second_get

`pair_bool_pair_string_string_second_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_pair_bool_pair_string_string_second_get', self, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_std__string_std__string_t", ref=ans);
  
  ans
  
}

attr(`pair_bool_pair_string_string_second_get`, 'returnType') = '_p_PairT_std__string_std__string_t'
attr(`pair_bool_pair_string_string_second_get`, "inputTypes") = c('_p_PairT_bool_PairT_std__string_std__string_t_t')
class(`pair_bool_pair_string_string_second_get`) = c("SWIGFunction", class('pair_bool_pair_string_string_second_get'))

# Start of delete_pair_bool_pair_string_string

`delete_pair_bool_pair_string_string` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_pair_bool_pair_string_string', self, PACKAGE='Conv');
  
}

attr(`delete_pair_bool_pair_string_string`, 'returnType') = 'void'
attr(`delete_pair_bool_pair_string_string`, "inputTypes") = c('_p_PairT_bool_PairT_std__string_std__string_t_t')
class(`delete_pair_bool_pair_string_string`) = c("SWIGFunction", class('delete_pair_bool_pair_string_string'))

# Start of accessor method for Pair< bool,Pair< std::string,std::string > >
setMethod('$', '_p_PairT_bool_PairT_std__string_std__string_t_t', function(x, name)

{
  accessorFuns = list('first' = pair_bool_pair_string_string_first_get, 'second' = pair_bool_pair_string_string_second_get);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Pair< bool,Pair< std::string,std::string > >
# Start of accessor method for Pair< bool,Pair< std::string,std::string > >
setMethod('$<-', '_p_PairT_bool_PairT_std__string_std__string_t_t', function(x, name, value)

{
  accessorFuns = list('first' = pair_bool_pair_string_string_first_set, 'second' = pair_bool_pair_string_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PairT_bool_PairT_std__string_std__string_t_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = pair_bool_pair_string_string_first_set, 'second' = pair_bool_pair_string_string_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Pair< bool,Pair< std::string,std::string > >
setMethod('delete', '_p_PairT_bool_PairT_std__string_std__string_t_t', function(obj) {delete_PairT_bool_PairT_std__string_std__string_t_t(obj)})
# Start of vector_float___nonzero__

`vector_float___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float___nonzero__`, 'returnType') = 'logical'
attr(`vector_float___nonzero__`, "inputTypes") = c('numeric')
class(`vector_float___nonzero__`) = c("SWIGFunction", class('vector_float___nonzero__'))

# Start of vector_float___len__

`vector_float___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float___len__`, 'returnType') = 'integer'
attr(`vector_float___len__`, "inputTypes") = c('numeric')
class(`vector_float___len__`) = c("SWIGFunction", class('vector_float___len__'))

# Start of vector_float_pop

`vector_float_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_pop', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float_pop`, 'returnType') = 'numeric'
attr(`vector_float_pop`, "inputTypes") = c('numeric')
class(`vector_float_pop`) = c("SWIGFunction", class('vector_float_pop'))

# Start of vector_float___getslice__

`vector_float___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_float___getslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_float___getslice__`, 'returnType') = 'numeric'
attr(`vector_float___getslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`vector_float___getslice__`) = c("SWIGFunction", class('vector_float___getslice__'))

# Start of vector_float___setslice__

`vector_float___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_vector_float___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_float___setslice__`, 'returnType') = 'void'
attr(`vector_float___setslice__`, "inputTypes") = c('numeric', 'integer', 'integer', 'numeric')
class(`vector_float___setslice__`) = c("SWIGFunction", class('vector_float___setslice__'))

# Start of vector_float___delslice__

`vector_float___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_float___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_float___delslice__`, 'returnType') = 'void'
attr(`vector_float___delslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`vector_float___delslice__`) = c("SWIGFunction", class('vector_float___delslice__'))

# Start of vector_float___delitem__

`vector_float___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_float___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_float___delitem__`, 'returnType') = 'void'
attr(`vector_float___delitem__`, "inputTypes") = c('numeric', 'integer')
class(`vector_float___delitem__`) = c("SWIGFunction", class('vector_float___delitem__'))

# Start of vector_float___getitem__

`vector_float___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_float___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float___getitem__`, 'returnType') = 'numeric'
attr(`vector_float___getitem__`, "inputTypes") = c('numeric', 'integer')
class(`vector_float___getitem__`) = c("SWIGFunction", class('vector_float___getitem__'))

# Start of vector_float___setitem__

`vector_float___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_vector_float___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_float___setitem__`, 'returnType') = 'void'
attr(`vector_float___setitem__`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`vector_float___setitem__`) = c("SWIGFunction", class('vector_float___setitem__'))

# Start of vector_float_append

`vector_float_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_vector_float_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_float_append`, 'returnType') = 'void'
attr(`vector_float_append`, "inputTypes") = c('numeric', 'numeric')
class(`vector_float_append`) = c("SWIGFunction", class('vector_float_append'))

# Start of new_vector_float

`vector_float__SWIG_0` = function()
{
  ;.Call('R_swig_new_vector_float__SWIG_0', PACKAGE='Conv');
  
}

attr(`vector_float__SWIG_0`, 'returnType') = 'numeric'
class(`vector_float__SWIG_0`) = c("SWIGFunction", class('vector_float__SWIG_0'))

# Start of new_vector_float

`vector_float__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_vector_float__SWIG_1', other, PACKAGE='Conv');
  
}

attr(`vector_float__SWIG_1`, 'returnType') = 'numeric'
attr(`vector_float__SWIG_1`, "inputTypes") = c('numeric')
class(`vector_float__SWIG_1`) = c("SWIGFunction", class('vector_float__SWIG_1'))

# Start of vector_float_empty

`vector_float_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float_empty`, 'returnType') = 'logical'
attr(`vector_float_empty`, "inputTypes") = c('numeric')
class(`vector_float_empty`) = c("SWIGFunction", class('vector_float_empty'))

# Start of vector_float_size

`vector_float_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float_size`, 'returnType') = 'integer'
attr(`vector_float_size`, "inputTypes") = c('numeric')
class(`vector_float_size`) = c("SWIGFunction", class('vector_float_size'))

# Start of vector_float_swap

`vector_float_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_vector_float_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_float_swap`, 'returnType') = 'void'
attr(`vector_float_swap`, "inputTypes") = c('numeric', 'numeric')
class(`vector_float_swap`) = c("SWIGFunction", class('vector_float_swap'))

# Start of vector_float_clear

`vector_float_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_clear', self, PACKAGE='Conv');
  
}

attr(`vector_float_clear`, 'returnType') = 'void'
attr(`vector_float_clear`, "inputTypes") = c('numeric')
class(`vector_float_clear`) = c("SWIGFunction", class('vector_float_clear'))

# Start of vector_float_get_allocator

`vector_float_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_vector_float_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_float_t", ref=ans);
  
  ans
  
}

attr(`vector_float_get_allocator`, 'returnType') = '_p_std__allocatorT_float_t'
attr(`vector_float_get_allocator`, "inputTypes") = c('numeric')
class(`vector_float_get_allocator`) = c("SWIGFunction", class('vector_float_get_allocator'))

# Start of new_vector_float

`vector_float__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_vector_float__SWIG_2', size, PACKAGE='Conv');
  
}

attr(`vector_float__SWIG_2`, 'returnType') = 'numeric'
attr(`vector_float__SWIG_2`, "inputTypes") = c('integer')
class(`vector_float__SWIG_2`) = c("SWIGFunction", class('vector_float__SWIG_2'))

# Start of vector_float_pop_back

`vector_float_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_float_pop_back`, 'returnType') = 'void'
attr(`vector_float_pop_back`, "inputTypes") = c('numeric')
class(`vector_float_pop_back`) = c("SWIGFunction", class('vector_float_pop_back'))

# Start of vector_float_resize

`vector_float_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_float_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_float_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_float_resize__SWIG_0`, "inputTypes") = c('numeric', 'integer')
class(`vector_float_resize__SWIG_0`) = c("SWIGFunction", class('vector_float_resize__SWIG_0'))

# Start of new_vector_float

`vector_float__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_vector_float__SWIG_3', size, value, PACKAGE='Conv');
  
}

attr(`vector_float__SWIG_3`, 'returnType') = 'numeric'
attr(`vector_float__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`vector_float__SWIG_3`) = c("SWIGFunction", class('vector_float__SWIG_3'))

`vector_float` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_float__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_float__SWIG_2; 
    }
    else if ( is.numeric(argv[[1]]) ) {
      f <- vector_float__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- vector_float__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_float with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_float_push_back

`vector_float_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_vector_float_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_float_push_back`, 'returnType') = 'void'
attr(`vector_float_push_back`, "inputTypes") = c('numeric', 'numeric')
class(`vector_float_push_back`) = c("SWIGFunction", class('vector_float_push_back'))

# Start of vector_float_front

`vector_float_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_front', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float_front`, 'returnType') = 'numeric'
attr(`vector_float_front`, "inputTypes") = c('numeric')
class(`vector_float_front`) = c("SWIGFunction", class('vector_float_front'))

# Start of vector_float_back

`vector_float_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_back', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float_back`, 'returnType') = 'numeric'
attr(`vector_float_back`, "inputTypes") = c('numeric')
class(`vector_float_back`) = c("SWIGFunction", class('vector_float_back'))

# Start of vector_float_assign

`vector_float_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_vector_float_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_float_assign`, 'returnType') = 'void'
attr(`vector_float_assign`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`vector_float_assign`) = c("SWIGFunction", class('vector_float_assign'))

# Start of vector_float_resize

`vector_float_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_vector_float_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_float_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_float_resize__SWIG_1`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`vector_float_resize__SWIG_1`) = c("SWIGFunction", class('vector_float_resize__SWIG_1'))

`vector_float_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_float_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- vector_float_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_float_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_float_reserve

`vector_float_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_float_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_float_reserve`, 'returnType') = 'void'
attr(`vector_float_reserve`, "inputTypes") = c('numeric', 'integer')
class(`vector_float_reserve`) = c("SWIGFunction", class('vector_float_reserve'))

# Start of vector_float_capacity

`vector_float_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_float_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_float_capacity`, 'returnType') = 'integer'
attr(`vector_float_capacity`, "inputTypes") = c('numeric')
class(`vector_float_capacity`) = c("SWIGFunction", class('vector_float_capacity'))

# Start of delete_vector_float

`delete_vector_float` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_vector_float', self, PACKAGE='Conv');
  
}

attr(`delete_vector_float`, 'returnType') = 'void'
attr(`delete_vector_float`, "inputTypes") = c('numeric')
class(`delete_vector_float`) = c("SWIGFunction", class('delete_vector_float'))

# Start of accessor method for std::vector< float >
setMethod('$', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_float___nonzero__, '__len__' = vector_float___len__, 'pop' = vector_float_pop, '__getslice__' = vector_float___getslice__, '__setslice__' = vector_float___setslice__, '__delslice__' = vector_float___delslice__, '__delitem__' = vector_float___delitem__, '__getitem__' = vector_float___getitem__, '__setitem__' = vector_float___setitem__, 'append' = vector_float_append, 'empty' = vector_float_empty, 'size' = vector_float_size, 'swap' = vector_float_swap, 'clear' = vector_float_clear, 'get_allocator' = vector_float_get_allocator, 'pop_back' = vector_float_pop_back, 'resize' = vector_float_resize, 'push_back' = vector_float_push_back, 'front' = vector_float_front, 'back' = vector_float_back, 'assign' = vector_float_assign, 'reserve' = vector_float_reserve, 'capacity' = vector_float_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< float >
setMethod('delete', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(obj) {delete_std__vectorT_float_std__allocatorT_float_t_t(obj)})
# Start of vector_double___nonzero__

`vector_double___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double___nonzero__`, 'returnType') = 'logical'
attr(`vector_double___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double___nonzero__`) = c("SWIGFunction", class('vector_double___nonzero__'))

# Start of vector_double___len__

`vector_double___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double___len__`, 'returnType') = 'integer'
attr(`vector_double___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double___len__`) = c("SWIGFunction", class('vector_double___len__'))

# Start of vector_double_pop

`vector_double_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_pop', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double_pop`, 'returnType') = 'numeric'
attr(`vector_double_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_pop`) = c("SWIGFunction", class('vector_double_pop'))

# Start of vector_double___getslice__

`vector_double___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_double___getslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_double___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`vector_double___getslice__`) = c("SWIGFunction", class('vector_double___getslice__'))

# Start of vector_double___setslice__

`vector_double___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_vector_double___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_double___setslice__`, 'returnType') = 'void'
attr(`vector_double___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double___setslice__`) = c("SWIGFunction", class('vector_double___setslice__'))

# Start of vector_double___delslice__

`vector_double___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_double___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_double___delslice__`, 'returnType') = 'void'
attr(`vector_double___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`vector_double___delslice__`) = c("SWIGFunction", class('vector_double___delslice__'))

# Start of vector_double___delitem__

`vector_double___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_double___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_double___delitem__`, 'returnType') = 'void'
attr(`vector_double___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double___delitem__`) = c("SWIGFunction", class('vector_double___delitem__'))

# Start of vector_double___getitem__

`vector_double___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_double___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double___getitem__`, 'returnType') = 'numeric'
attr(`vector_double___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double___getitem__`) = c("SWIGFunction", class('vector_double___getitem__'))

# Start of vector_double___setitem__

`vector_double___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_vector_double___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_double___setitem__`, 'returnType') = 'void'
attr(`vector_double___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`vector_double___setitem__`) = c("SWIGFunction", class('vector_double___setitem__'))

# Start of vector_double_append

`vector_double_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_vector_double_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_double_append`, 'returnType') = 'void'
attr(`vector_double_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`vector_double_append`) = c("SWIGFunction", class('vector_double_append'))

# Start of new_vector_double

`vector_double__SWIG_0` = function()
{
  ;.Call('R_swig_new_vector_double__SWIG_0', PACKAGE='Conv');
  
}

attr(`vector_double__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`vector_double__SWIG_0`) = c("SWIGFunction", class('vector_double__SWIG_0'))

# Start of new_vector_double

`vector_double__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_vector_double__SWIG_1', other, PACKAGE='Conv');
  
}

attr(`vector_double__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double__SWIG_1`) = c("SWIGFunction", class('vector_double__SWIG_1'))

# Start of vector_double_empty

`vector_double_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double_empty`, 'returnType') = 'logical'
attr(`vector_double_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_empty`) = c("SWIGFunction", class('vector_double_empty'))

# Start of vector_double_size

`vector_double_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double_size`, 'returnType') = 'integer'
attr(`vector_double_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_size`) = c("SWIGFunction", class('vector_double_size'))

# Start of vector_double_swap

`vector_double_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_vector_double_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_double_swap`, 'returnType') = 'void'
attr(`vector_double_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_swap`) = c("SWIGFunction", class('vector_double_swap'))

# Start of vector_double_clear

`vector_double_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_clear', self, PACKAGE='Conv');
  
}

attr(`vector_double_clear`, 'returnType') = 'void'
attr(`vector_double_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_clear`) = c("SWIGFunction", class('vector_double_clear'))

# Start of vector_double_get_allocator

`vector_double_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_vector_double_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`vector_double_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`vector_double_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_get_allocator`) = c("SWIGFunction", class('vector_double_get_allocator'))

# Start of new_vector_double

`vector_double__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_vector_double__SWIG_2', size, PACKAGE='Conv');
  
}

attr(`vector_double__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double__SWIG_2`, "inputTypes") = c('integer')
class(`vector_double__SWIG_2`) = c("SWIGFunction", class('vector_double__SWIG_2'))

# Start of vector_double_pop_back

`vector_double_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_double_pop_back`, 'returnType') = 'void'
attr(`vector_double_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_pop_back`) = c("SWIGFunction", class('vector_double_pop_back'))

# Start of vector_double_resize

`vector_double_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_double_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_double_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_double_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double_resize__SWIG_0`) = c("SWIGFunction", class('vector_double_resize__SWIG_0'))

# Start of new_vector_double

`vector_double__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_vector_double__SWIG_3', size, value, PACKAGE='Conv');
  
}

attr(`vector_double__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`vector_double__SWIG_3`) = c("SWIGFunction", class('vector_double__SWIG_3'))

`vector_double` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_double__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_double__SWIG_2; 
    }
    else if ( is.numeric(argv[[1]]) ) {
      f <- vector_double__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- vector_double__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_double with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_double_push_back

`vector_double_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_vector_double_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_double_push_back`, 'returnType') = 'void'
attr(`vector_double_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`vector_double_push_back`) = c("SWIGFunction", class('vector_double_push_back'))

# Start of vector_double_front

`vector_double_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_front', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double_front`, 'returnType') = 'numeric'
attr(`vector_double_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_front`) = c("SWIGFunction", class('vector_double_front'))

# Start of vector_double_back

`vector_double_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_back', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double_back`, 'returnType') = 'numeric'
attr(`vector_double_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_back`) = c("SWIGFunction", class('vector_double_back'))

# Start of vector_double_assign

`vector_double_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_vector_double_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_double_assign`, 'returnType') = 'void'
attr(`vector_double_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`vector_double_assign`) = c("SWIGFunction", class('vector_double_assign'))

# Start of vector_double_resize

`vector_double_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_vector_double_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_double_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_double_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`vector_double_resize__SWIG_1`) = c("SWIGFunction", class('vector_double_resize__SWIG_1'))

`vector_double_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_double_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- vector_double_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_double_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_double_reserve

`vector_double_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_double_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_double_reserve`, 'returnType') = 'void'
attr(`vector_double_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double_reserve`) = c("SWIGFunction", class('vector_double_reserve'))

# Start of vector_double_capacity

`vector_double_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_double_capacity`, 'returnType') = 'integer'
attr(`vector_double_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_capacity`) = c("SWIGFunction", class('vector_double_capacity'))

# Start of delete_vector_double

`delete_vector_double` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_vector_double', self, PACKAGE='Conv');
  
}

attr(`delete_vector_double`, 'returnType') = 'void'
attr(`delete_vector_double`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_vector_double`) = c("SWIGFunction", class('delete_vector_double'))

# Start of accessor method for std::vector< double >
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_double___nonzero__, '__len__' = vector_double___len__, 'pop' = vector_double_pop, '__getslice__' = vector_double___getslice__, '__setslice__' = vector_double___setslice__, '__delslice__' = vector_double___delslice__, '__delitem__' = vector_double___delitem__, '__getitem__' = vector_double___getitem__, '__setitem__' = vector_double___setitem__, 'append' = vector_double_append, 'empty' = vector_double_empty, 'size' = vector_double_size, 'swap' = vector_double_swap, 'clear' = vector_double_clear, 'get_allocator' = vector_double_get_allocator, 'pop_back' = vector_double_pop_back, 'resize' = vector_double_resize, 'push_back' = vector_double_push_back, 'front' = vector_double_front, 'back' = vector_double_back, 'assign' = vector_double_assign, 'reserve' = vector_double_reserve, 'capacity' = vector_double_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< double >
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of vector_pair_timeseries___nonzero__

`vector_pair_timeseries___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries___nonzero__`, 'returnType') = 'logical'
attr(`vector_pair_timeseries___nonzero__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries___nonzero__`) = c("SWIGFunction", class('vector_pair_timeseries___nonzero__'))

# Start of vector_pair_timeseries___len__

`vector_pair_timeseries___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries___len__`, 'returnType') = 'integer'
attr(`vector_pair_timeseries___len__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries___len__`) = c("SWIGFunction", class('vector_pair_timeseries___len__'))

# Start of vector_pair_timeseries_pop

`vector_pair_timeseries_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_timeseries_pop', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_timeseries_pop`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
attr(`vector_pair_timeseries_pop`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_pop`) = c("SWIGFunction", class('vector_pair_timeseries_pop'))

# Start of vector_pair_timeseries___getslice__

`vector_pair_timeseries___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_vector_pair_timeseries___getslice__', self, i, j, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_timeseries___getslice__`, 'returnType') = '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t'
attr(`vector_pair_timeseries___getslice__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer', 'integer')
class(`vector_pair_timeseries___getslice__`) = c("SWIGFunction", class('vector_pair_timeseries___getslice__'))

# Start of vector_pair_timeseries___setslice__

`vector_pair_timeseries___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries___setslice__`, 'returnType') = 'void'
attr(`vector_pair_timeseries___setslice__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer', 'integer', '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries___setslice__`) = c("SWIGFunction", class('vector_pair_timeseries___setslice__'))

# Start of vector_pair_timeseries___delslice__

`vector_pair_timeseries___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_pair_timeseries___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries___delslice__`, 'returnType') = 'void'
attr(`vector_pair_timeseries___delslice__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer', 'integer')
class(`vector_pair_timeseries___delslice__`) = c("SWIGFunction", class('vector_pair_timeseries___delslice__'))

# Start of vector_pair_timeseries___delitem__

`vector_pair_timeseries___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_pair_timeseries___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries___delitem__`, 'returnType') = 'void'
attr(`vector_pair_timeseries___delitem__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer')
class(`vector_pair_timeseries___delitem__`) = c("SWIGFunction", class('vector_pair_timeseries___delitem__'))

# Start of vector_pair_timeseries___getitem__

`vector_pair_timeseries___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_vector_pair_timeseries___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_timeseries___getitem__`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
attr(`vector_pair_timeseries___getitem__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer')
class(`vector_pair_timeseries___getitem__`) = c("SWIGFunction", class('vector_pair_timeseries___getitem__'))

# Start of vector_pair_timeseries___setitem__

`vector_pair_timeseries___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries___setitem__`, 'returnType') = 'void'
attr(`vector_pair_timeseries___setitem__`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer', '_p_PairT_cweeDateTime_float_t')
class(`vector_pair_timeseries___setitem__`) = c("SWIGFunction", class('vector_pair_timeseries___setitem__'))

# Start of vector_pair_timeseries_append

`vector_pair_timeseries_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_append`, 'returnType') = 'void'
attr(`vector_pair_timeseries_append`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', '_p_PairT_cweeDateTime_float_t')
class(`vector_pair_timeseries_append`) = c("SWIGFunction", class('vector_pair_timeseries_append'))

# Start of new_vector_pair_timeseries

`vector_pair_timeseries__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_vector_pair_timeseries__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_timeseries);
  ans
  
}

attr(`vector_pair_timeseries__SWIG_0`, 'returnType') = '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t'
class(`vector_pair_timeseries__SWIG_0`) = c("SWIGFunction", class('vector_pair_timeseries__SWIG_0'))

# Start of new_vector_pair_timeseries

`vector_pair_timeseries__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_vector_pair_timeseries__SWIG_1', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_timeseries);
  ans
  
}

attr(`vector_pair_timeseries__SWIG_1`, 'returnType') = '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t'
attr(`vector_pair_timeseries__SWIG_1`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries__SWIG_1`) = c("SWIGFunction", class('vector_pair_timeseries__SWIG_1'))

# Start of vector_pair_timeseries_empty

`vector_pair_timeseries_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_empty`, 'returnType') = 'logical'
attr(`vector_pair_timeseries_empty`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_empty`) = c("SWIGFunction", class('vector_pair_timeseries_empty'))

# Start of vector_pair_timeseries_size

`vector_pair_timeseries_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_size`, 'returnType') = 'integer'
attr(`vector_pair_timeseries_size`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_size`) = c("SWIGFunction", class('vector_pair_timeseries_size'))

# Start of vector_pair_timeseries_swap

`vector_pair_timeseries_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_swap`, 'returnType') = 'void'
attr(`vector_pair_timeseries_swap`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_swap`) = c("SWIGFunction", class('vector_pair_timeseries_swap'))

# Start of vector_pair_timeseries_clear

`vector_pair_timeseries_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_clear', self, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_clear`, 'returnType') = 'void'
attr(`vector_pair_timeseries_clear`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_clear`) = c("SWIGFunction", class('vector_pair_timeseries_clear'))

# Start of vector_pair_timeseries_get_allocator

`vector_pair_timeseries_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_timeseries_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_PairT_cweeDateTime_float_t_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_timeseries_get_allocator`, 'returnType') = '_p_std__allocatorT_PairT_cweeDateTime_float_t_t'
attr(`vector_pair_timeseries_get_allocator`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_get_allocator`) = c("SWIGFunction", class('vector_pair_timeseries_get_allocator'))

# Start of new_vector_pair_timeseries

`vector_pair_timeseries__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_vector_pair_timeseries__SWIG_2', size, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_timeseries);
  ans
  
}

attr(`vector_pair_timeseries__SWIG_2`, 'returnType') = '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t'
attr(`vector_pair_timeseries__SWIG_2`, "inputTypes") = c('integer')
class(`vector_pair_timeseries__SWIG_2`) = c("SWIGFunction", class('vector_pair_timeseries__SWIG_2'))

# Start of vector_pair_timeseries_pop_back

`vector_pair_timeseries_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_pop_back`, 'returnType') = 'void'
attr(`vector_pair_timeseries_pop_back`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_pop_back`) = c("SWIGFunction", class('vector_pair_timeseries_pop_back'))

# Start of vector_pair_timeseries_resize

`vector_pair_timeseries_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_pair_timeseries_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_pair_timeseries_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer')
class(`vector_pair_timeseries_resize__SWIG_0`) = c("SWIGFunction", class('vector_pair_timeseries_resize__SWIG_0'))

# Start of new_vector_pair_timeseries

`vector_pair_timeseries__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref"); 
  ;ans = .Call('R_swig_new_vector_pair_timeseries__SWIG_3', size, value, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_timeseries);
  ans
  
}

attr(`vector_pair_timeseries__SWIG_3`, 'returnType') = '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t'
attr(`vector_pair_timeseries__SWIG_3`, "inputTypes") = c('integer', '_p_PairT_cweeDateTime_float_t')
class(`vector_pair_timeseries__SWIG_3`) = c("SWIGFunction", class('vector_pair_timeseries__SWIG_3'))

`vector_pair_timeseries` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_pair_timeseries__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_pair_timeseries__SWIG_2; 
    }
    else if ( extends(argtypes[1], '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t') && length(argv[[1]]) == 1 ) {
      f <- vector_pair_timeseries__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_PairT_cweeDateTime_float_t') && length(argv[[2]]) == 1 )) {
      f <- vector_pair_timeseries__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_pair_timeseries with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_pair_timeseries_push_back

`vector_pair_timeseries_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_push_back`, 'returnType') = 'void'
attr(`vector_pair_timeseries_push_back`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', '_p_PairT_cweeDateTime_float_t')
class(`vector_pair_timeseries_push_back`) = c("SWIGFunction", class('vector_pair_timeseries_push_back'))

# Start of vector_pair_timeseries_front

`vector_pair_timeseries_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_timeseries_front', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_timeseries_front`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
attr(`vector_pair_timeseries_front`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_front`) = c("SWIGFunction", class('vector_pair_timeseries_front'))

# Start of vector_pair_timeseries_back

`vector_pair_timeseries_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_timeseries_back', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_cweeDateTime_float_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_timeseries_back`, 'returnType') = '_p_PairT_cweeDateTime_float_t'
attr(`vector_pair_timeseries_back`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_back`) = c("SWIGFunction", class('vector_pair_timeseries_back'))

# Start of vector_pair_timeseries_assign

`vector_pair_timeseries_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_assign`, 'returnType') = 'void'
attr(`vector_pair_timeseries_assign`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer', '_p_PairT_cweeDateTime_float_t')
class(`vector_pair_timeseries_assign`) = c("SWIGFunction", class('vector_pair_timeseries_assign'))

# Start of vector_pair_timeseries_resize

`vector_pair_timeseries_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_pair_timeseries_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer', '_p_PairT_cweeDateTime_float_t')
class(`vector_pair_timeseries_resize__SWIG_1`) = c("SWIGFunction", class('vector_pair_timeseries_resize__SWIG_1'))

`vector_pair_timeseries_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_pair_timeseries_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( extends(argtypes[1], '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( extends(argtypes[3], '_p_PairT_cweeDateTime_float_t') && length(argv[[3]]) == 1 )) {
      f <- vector_pair_timeseries_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_pair_timeseries_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_pair_timeseries_reserve

`vector_pair_timeseries_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_pair_timeseries_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_reserve`, 'returnType') = 'void'
attr(`vector_pair_timeseries_reserve`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', 'integer')
class(`vector_pair_timeseries_reserve`) = c("SWIGFunction", class('vector_pair_timeseries_reserve'))

# Start of vector_pair_timeseries_capacity

`vector_pair_timeseries_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_timeseries_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_timeseries_capacity`, 'returnType') = 'integer'
attr(`vector_pair_timeseries_capacity`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`vector_pair_timeseries_capacity`) = c("SWIGFunction", class('vector_pair_timeseries_capacity'))

# Start of delete_vector_pair_timeseries

`delete_vector_pair_timeseries` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_vector_pair_timeseries', self, PACKAGE='Conv');
  
}

attr(`delete_vector_pair_timeseries`, 'returnType') = 'void'
attr(`delete_vector_pair_timeseries`, "inputTypes") = c('_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t')
class(`delete_vector_pair_timeseries`) = c("SWIGFunction", class('delete_vector_pair_timeseries'))

# Start of accessor method for std::vector< Pair< cweeDateTime,float > >
setMethod('$', '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_pair_timeseries___nonzero__, '__len__' = vector_pair_timeseries___len__, 'pop' = vector_pair_timeseries_pop, '__getslice__' = vector_pair_timeseries___getslice__, '__setslice__' = vector_pair_timeseries___setslice__, '__delslice__' = vector_pair_timeseries___delslice__, '__delitem__' = vector_pair_timeseries___delitem__, '__getitem__' = vector_pair_timeseries___getitem__, '__setitem__' = vector_pair_timeseries___setitem__, 'append' = vector_pair_timeseries_append, 'empty' = vector_pair_timeseries_empty, 'size' = vector_pair_timeseries_size, 'swap' = vector_pair_timeseries_swap, 'clear' = vector_pair_timeseries_clear, 'get_allocator' = vector_pair_timeseries_get_allocator, 'pop_back' = vector_pair_timeseries_pop_back, 'resize' = vector_pair_timeseries_resize, 'push_back' = vector_pair_timeseries_push_back, 'front' = vector_pair_timeseries_front, 'back' = vector_pair_timeseries_back, 'assign' = vector_pair_timeseries_assign, 'reserve' = vector_pair_timeseries_reserve, 'capacity' = vector_pair_timeseries_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< Pair< cweeDateTime,float > >
setMethod('delete', '_p_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t', function(obj) {delete_std__vectorT_PairT_cweeDateTime_float_t_std__allocatorT_PairT_cweeDateTime_float_t_t_t(obj)})
# Start of vector_pair_double_double___nonzero__

`vector_pair_double_double___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_double_double___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_double_double___nonzero__`, 'returnType') = 'logical'
attr(`vector_pair_double_double___nonzero__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double___nonzero__`) = c("SWIGFunction", class('vector_pair_double_double___nonzero__'))

# Start of vector_pair_double_double___len__

`vector_pair_double_double___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_double_double___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_double_double___len__`, 'returnType') = 'integer'
attr(`vector_pair_double_double___len__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double___len__`) = c("SWIGFunction", class('vector_pair_double_double___len__'))

# Start of vector_pair_double_double_pop

`vector_pair_double_double_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_double_double_pop', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_double_double_pop`, 'returnType') = '_p_PairT_double_double_t'
attr(`vector_pair_double_double_pop`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_pop`) = c("SWIGFunction", class('vector_pair_double_double_pop'))

# Start of vector_pair_double_double___getslice__

`vector_pair_double_double___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_vector_pair_double_double___getslice__', self, i, j, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_double_double___getslice__`, 'returnType') = '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t'
attr(`vector_pair_double_double___getslice__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer', 'integer')
class(`vector_pair_double_double___getslice__`) = c("SWIGFunction", class('vector_pair_double_double___getslice__'))

# Start of vector_pair_double_double___setslice__

`vector_pair_double_double___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_pair_double_double___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double___setslice__`, 'returnType') = 'void'
attr(`vector_pair_double_double___setslice__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer', 'integer', '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double___setslice__`) = c("SWIGFunction", class('vector_pair_double_double___setslice__'))

# Start of vector_pair_double_double___delslice__

`vector_pair_double_double___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_pair_double_double___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double___delslice__`, 'returnType') = 'void'
attr(`vector_pair_double_double___delslice__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer', 'integer')
class(`vector_pair_double_double___delslice__`) = c("SWIGFunction", class('vector_pair_double_double___delslice__'))

# Start of vector_pair_double_double___delitem__

`vector_pair_double_double___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_pair_double_double___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double___delitem__`, 'returnType') = 'void'
attr(`vector_pair_double_double___delitem__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer')
class(`vector_pair_double_double___delitem__`) = c("SWIGFunction", class('vector_pair_double_double___delitem__'))

# Start of vector_pair_double_double___getitem__

`vector_pair_double_double___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_vector_pair_double_double___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_double_double___getitem__`, 'returnType') = '_p_PairT_double_double_t'
attr(`vector_pair_double_double___getitem__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer')
class(`vector_pair_double_double___getitem__`) = c("SWIGFunction", class('vector_pair_double_double___getitem__'))

# Start of vector_pair_double_double___setitem__

`vector_pair_double_double___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_double_double___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double___setitem__`, 'returnType') = 'void'
attr(`vector_pair_double_double___setitem__`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer', '_p_PairT_double_double_t')
class(`vector_pair_double_double___setitem__`) = c("SWIGFunction", class('vector_pair_double_double___setitem__'))

# Start of vector_pair_double_double_append

`vector_pair_double_double_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_append`, 'returnType') = 'void'
attr(`vector_pair_double_double_append`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', '_p_PairT_double_double_t')
class(`vector_pair_double_double_append`) = c("SWIGFunction", class('vector_pair_double_double_append'))

# Start of new_vector_pair_double_double

`vector_pair_double_double__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_vector_pair_double_double__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_double_double);
  ans
  
}

attr(`vector_pair_double_double__SWIG_0`, 'returnType') = '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t'
class(`vector_pair_double_double__SWIG_0`) = c("SWIGFunction", class('vector_pair_double_double__SWIG_0'))

# Start of new_vector_pair_double_double

`vector_pair_double_double__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_vector_pair_double_double__SWIG_1', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_double_double);
  ans
  
}

attr(`vector_pair_double_double__SWIG_1`, 'returnType') = '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t'
attr(`vector_pair_double_double__SWIG_1`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double__SWIG_1`) = c("SWIGFunction", class('vector_pair_double_double__SWIG_1'))

# Start of vector_pair_double_double_empty

`vector_pair_double_double_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_empty`, 'returnType') = 'logical'
attr(`vector_pair_double_double_empty`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_empty`) = c("SWIGFunction", class('vector_pair_double_double_empty'))

# Start of vector_pair_double_double_size

`vector_pair_double_double_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_size`, 'returnType') = 'integer'
attr(`vector_pair_double_double_size`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_size`) = c("SWIGFunction", class('vector_pair_double_double_size'))

# Start of vector_pair_double_double_swap

`vector_pair_double_double_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_swap`, 'returnType') = 'void'
attr(`vector_pair_double_double_swap`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_swap`) = c("SWIGFunction", class('vector_pair_double_double_swap'))

# Start of vector_pair_double_double_clear

`vector_pair_double_double_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_clear', self, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_clear`, 'returnType') = 'void'
attr(`vector_pair_double_double_clear`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_clear`) = c("SWIGFunction", class('vector_pair_double_double_clear'))

# Start of vector_pair_double_double_get_allocator

`vector_pair_double_double_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_double_double_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_PairT_double_double_t_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_double_double_get_allocator`, 'returnType') = '_p_std__allocatorT_PairT_double_double_t_t'
attr(`vector_pair_double_double_get_allocator`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_get_allocator`) = c("SWIGFunction", class('vector_pair_double_double_get_allocator'))

# Start of new_vector_pair_double_double

`vector_pair_double_double__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_vector_pair_double_double__SWIG_2', size, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_double_double);
  ans
  
}

attr(`vector_pair_double_double__SWIG_2`, 'returnType') = '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t'
attr(`vector_pair_double_double__SWIG_2`, "inputTypes") = c('integer')
class(`vector_pair_double_double__SWIG_2`) = c("SWIGFunction", class('vector_pair_double_double__SWIG_2'))

# Start of vector_pair_double_double_pop_back

`vector_pair_double_double_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_pop_back`, 'returnType') = 'void'
attr(`vector_pair_double_double_pop_back`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_pop_back`) = c("SWIGFunction", class('vector_pair_double_double_pop_back'))

# Start of vector_pair_double_double_resize

`vector_pair_double_double_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_pair_double_double_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_pair_double_double_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer')
class(`vector_pair_double_double_resize__SWIG_0`) = c("SWIGFunction", class('vector_pair_double_double_resize__SWIG_0'))

# Start of new_vector_pair_double_double

`vector_pair_double_double__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref"); 
  ;ans = .Call('R_swig_new_vector_pair_double_double__SWIG_3', size, value, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_pair_double_double);
  ans
  
}

attr(`vector_pair_double_double__SWIG_3`, 'returnType') = '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t'
attr(`vector_pair_double_double__SWIG_3`, "inputTypes") = c('integer', '_p_PairT_double_double_t')
class(`vector_pair_double_double__SWIG_3`) = c("SWIGFunction", class('vector_pair_double_double__SWIG_3'))

`vector_pair_double_double` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_pair_double_double__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_pair_double_double__SWIG_2; 
    }
    else if ( extends(argtypes[1], '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t') && length(argv[[1]]) == 1 ) {
      f <- vector_pair_double_double__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_PairT_double_double_t') && length(argv[[2]]) == 1 )) {
      f <- vector_pair_double_double__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_pair_double_double with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_pair_double_double_push_back

`vector_pair_double_double_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_push_back`, 'returnType') = 'void'
attr(`vector_pair_double_double_push_back`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', '_p_PairT_double_double_t')
class(`vector_pair_double_double_push_back`) = c("SWIGFunction", class('vector_pair_double_double_push_back'))

# Start of vector_pair_double_double_front

`vector_pair_double_double_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_double_double_front', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_double_double_front`, 'returnType') = '_p_PairT_double_double_t'
attr(`vector_pair_double_double_front`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_front`) = c("SWIGFunction", class('vector_pair_double_double_front'))

# Start of vector_pair_double_double_back

`vector_pair_double_double_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_pair_double_double_back', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_PairT_double_double_t", ref=ans);
  
  ans
  
}

attr(`vector_pair_double_double_back`, 'returnType') = '_p_PairT_double_double_t'
attr(`vector_pair_double_double_back`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_back`) = c("SWIGFunction", class('vector_pair_double_double_back'))

# Start of vector_pair_double_double_assign

`vector_pair_double_double_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_assign`, 'returnType') = 'void'
attr(`vector_pair_double_double_assign`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer', '_p_PairT_double_double_t')
class(`vector_pair_double_double_assign`) = c("SWIGFunction", class('vector_pair_double_double_assign'))

# Start of vector_pair_double_double_resize

`vector_pair_double_double_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_pair_double_double_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer', '_p_PairT_double_double_t')
class(`vector_pair_double_double_resize__SWIG_1`) = c("SWIGFunction", class('vector_pair_double_double_resize__SWIG_1'))

`vector_pair_double_double_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_pair_double_double_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( extends(argtypes[1], '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( extends(argtypes[3], '_p_PairT_double_double_t') && length(argv[[3]]) == 1 )) {
      f <- vector_pair_double_double_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_pair_double_double_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_pair_double_double_reserve

`vector_pair_double_double_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_pair_double_double_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_reserve`, 'returnType') = 'void'
attr(`vector_pair_double_double_reserve`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', 'integer')
class(`vector_pair_double_double_reserve`) = c("SWIGFunction", class('vector_pair_double_double_reserve'))

# Start of vector_pair_double_double_capacity

`vector_pair_double_double_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_pair_double_double_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_pair_double_double_capacity`, 'returnType') = 'integer'
attr(`vector_pair_double_double_capacity`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`vector_pair_double_double_capacity`) = c("SWIGFunction", class('vector_pair_double_double_capacity'))

# Start of delete_vector_pair_double_double

`delete_vector_pair_double_double` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_vector_pair_double_double', self, PACKAGE='Conv');
  
}

attr(`delete_vector_pair_double_double`, 'returnType') = 'void'
attr(`delete_vector_pair_double_double`, "inputTypes") = c('_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t')
class(`delete_vector_pair_double_double`) = c("SWIGFunction", class('delete_vector_pair_double_double'))

# Start of accessor method for std::vector< Pair< double,double > >
setMethod('$', '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_pair_double_double___nonzero__, '__len__' = vector_pair_double_double___len__, 'pop' = vector_pair_double_double_pop, '__getslice__' = vector_pair_double_double___getslice__, '__setslice__' = vector_pair_double_double___setslice__, '__delslice__' = vector_pair_double_double___delslice__, '__delitem__' = vector_pair_double_double___delitem__, '__getitem__' = vector_pair_double_double___getitem__, '__setitem__' = vector_pair_double_double___setitem__, 'append' = vector_pair_double_double_append, 'empty' = vector_pair_double_double_empty, 'size' = vector_pair_double_double_size, 'swap' = vector_pair_double_double_swap, 'clear' = vector_pair_double_double_clear, 'get_allocator' = vector_pair_double_double_get_allocator, 'pop_back' = vector_pair_double_double_pop_back, 'resize' = vector_pair_double_double_resize, 'push_back' = vector_pair_double_double_push_back, 'front' = vector_pair_double_double_front, 'back' = vector_pair_double_double_back, 'assign' = vector_pair_double_double_assign, 'reserve' = vector_pair_double_double_reserve, 'capacity' = vector_pair_double_double_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< Pair< double,double > >
setMethod('delete', '_p_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t', function(obj) {delete_std__vectorT_PairT_double_double_t_std__allocatorT_PairT_double_double_t_t_t(obj)})
# Start of vector_scriptingnode___nonzero__

`vector_scriptingnode___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_scriptingnode___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_scriptingnode___nonzero__`, 'returnType') = 'logical'
attr(`vector_scriptingnode___nonzero__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode___nonzero__`) = c("SWIGFunction", class('vector_scriptingnode___nonzero__'))

# Start of vector_scriptingnode___len__

`vector_scriptingnode___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_scriptingnode___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_scriptingnode___len__`, 'returnType') = 'integer'
attr(`vector_scriptingnode___len__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode___len__`) = c("SWIGFunction", class('vector_scriptingnode___len__'))

# Start of vector_scriptingnode_pop

`vector_scriptingnode_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_scriptingnode_pop', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_ScriptingNode", ref=ans);
  
  ans
  
}

attr(`vector_scriptingnode_pop`, 'returnType') = '_p_ScriptingNode'
attr(`vector_scriptingnode_pop`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_pop`) = c("SWIGFunction", class('vector_scriptingnode_pop'))

# Start of vector_scriptingnode___getslice__

`vector_scriptingnode___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_vector_scriptingnode___getslice__', self, i, j, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t", ref=ans);
  
  ans
  
}

attr(`vector_scriptingnode___getslice__`, 'returnType') = '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t'
attr(`vector_scriptingnode___getslice__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer', 'integer')
class(`vector_scriptingnode___getslice__`) = c("SWIGFunction", class('vector_scriptingnode___getslice__'))

# Start of vector_scriptingnode___setslice__

`vector_scriptingnode___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_scriptingnode___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode___setslice__`, 'returnType') = 'void'
attr(`vector_scriptingnode___setslice__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer', 'integer', '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode___setslice__`) = c("SWIGFunction", class('vector_scriptingnode___setslice__'))

# Start of vector_scriptingnode___delslice__

`vector_scriptingnode___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_scriptingnode___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode___delslice__`, 'returnType') = 'void'
attr(`vector_scriptingnode___delslice__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer', 'integer')
class(`vector_scriptingnode___delslice__`) = c("SWIGFunction", class('vector_scriptingnode___delslice__'))

# Start of vector_scriptingnode___delitem__

`vector_scriptingnode___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_scriptingnode___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode___delitem__`, 'returnType') = 'void'
attr(`vector_scriptingnode___delitem__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer')
class(`vector_scriptingnode___delitem__`) = c("SWIGFunction", class('vector_scriptingnode___delitem__'))

# Start of vector_scriptingnode___getitem__

`vector_scriptingnode___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_vector_scriptingnode___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_ScriptingNode", ref=ans);
  
  ans
  
}

attr(`vector_scriptingnode___getitem__`, 'returnType') = '_p_ScriptingNode'
attr(`vector_scriptingnode___getitem__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer')
class(`vector_scriptingnode___getitem__`) = c("SWIGFunction", class('vector_scriptingnode___getitem__'))

# Start of vector_scriptingnode___setitem__

`vector_scriptingnode___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_scriptingnode___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode___setitem__`, 'returnType') = 'void'
attr(`vector_scriptingnode___setitem__`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer', '_p_ScriptingNode')
class(`vector_scriptingnode___setitem__`) = c("SWIGFunction", class('vector_scriptingnode___setitem__'))

# Start of vector_scriptingnode_append

`vector_scriptingnode_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_append`, 'returnType') = 'void'
attr(`vector_scriptingnode_append`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', '_p_ScriptingNode')
class(`vector_scriptingnode_append`) = c("SWIGFunction", class('vector_scriptingnode_append'))

# Start of new_vector_scriptingnode

`vector_scriptingnode__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_vector_scriptingnode__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_scriptingnode);
  ans
  
}

attr(`vector_scriptingnode__SWIG_0`, 'returnType') = '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t'
class(`vector_scriptingnode__SWIG_0`) = c("SWIGFunction", class('vector_scriptingnode__SWIG_0'))

# Start of new_vector_scriptingnode

`vector_scriptingnode__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_vector_scriptingnode__SWIG_1', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_scriptingnode);
  ans
  
}

attr(`vector_scriptingnode__SWIG_1`, 'returnType') = '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t'
attr(`vector_scriptingnode__SWIG_1`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode__SWIG_1`) = c("SWIGFunction", class('vector_scriptingnode__SWIG_1'))

# Start of vector_scriptingnode_empty

`vector_scriptingnode_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_empty`, 'returnType') = 'logical'
attr(`vector_scriptingnode_empty`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_empty`) = c("SWIGFunction", class('vector_scriptingnode_empty'))

# Start of vector_scriptingnode_size

`vector_scriptingnode_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_size`, 'returnType') = 'integer'
attr(`vector_scriptingnode_size`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_size`) = c("SWIGFunction", class('vector_scriptingnode_size'))

# Start of vector_scriptingnode_swap

`vector_scriptingnode_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_swap`, 'returnType') = 'void'
attr(`vector_scriptingnode_swap`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_swap`) = c("SWIGFunction", class('vector_scriptingnode_swap'))

# Start of vector_scriptingnode_clear

`vector_scriptingnode_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_clear', self, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_clear`, 'returnType') = 'void'
attr(`vector_scriptingnode_clear`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_clear`) = c("SWIGFunction", class('vector_scriptingnode_clear'))

# Start of vector_scriptingnode_get_allocator

`vector_scriptingnode_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_scriptingnode_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_ScriptingNode_t", ref=ans);
  
  ans
  
}

attr(`vector_scriptingnode_get_allocator`, 'returnType') = '_p_std__allocatorT_ScriptingNode_t'
attr(`vector_scriptingnode_get_allocator`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_get_allocator`) = c("SWIGFunction", class('vector_scriptingnode_get_allocator'))

# Start of new_vector_scriptingnode

`vector_scriptingnode__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_vector_scriptingnode__SWIG_2', size, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_scriptingnode);
  ans
  
}

attr(`vector_scriptingnode__SWIG_2`, 'returnType') = '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t'
attr(`vector_scriptingnode__SWIG_2`, "inputTypes") = c('integer')
class(`vector_scriptingnode__SWIG_2`) = c("SWIGFunction", class('vector_scriptingnode__SWIG_2'))

# Start of vector_scriptingnode_pop_back

`vector_scriptingnode_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_pop_back`, 'returnType') = 'void'
attr(`vector_scriptingnode_pop_back`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_pop_back`) = c("SWIGFunction", class('vector_scriptingnode_pop_back'))

# Start of vector_scriptingnode_resize

`vector_scriptingnode_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_scriptingnode_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_scriptingnode_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer')
class(`vector_scriptingnode_resize__SWIG_0`) = c("SWIGFunction", class('vector_scriptingnode_resize__SWIG_0'))

# Start of new_vector_scriptingnode

`vector_scriptingnode__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref"); 
  ;ans = .Call('R_swig_new_vector_scriptingnode__SWIG_3', size, value, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_scriptingnode);
  ans
  
}

attr(`vector_scriptingnode__SWIG_3`, 'returnType') = '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t'
attr(`vector_scriptingnode__SWIG_3`, "inputTypes") = c('integer', '_p_ScriptingNode')
class(`vector_scriptingnode__SWIG_3`) = c("SWIGFunction", class('vector_scriptingnode__SWIG_3'))

`vector_scriptingnode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_scriptingnode__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_scriptingnode__SWIG_2; 
    }
    else if ( extends(argtypes[1], '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t') && length(argv[[1]]) == 1 ) {
      f <- vector_scriptingnode__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_ScriptingNode') && length(argv[[2]]) == 1 )) {
      f <- vector_scriptingnode__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_scriptingnode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_scriptingnode_push_back

`vector_scriptingnode_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_push_back`, 'returnType') = 'void'
attr(`vector_scriptingnode_push_back`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', '_p_ScriptingNode')
class(`vector_scriptingnode_push_back`) = c("SWIGFunction", class('vector_scriptingnode_push_back'))

# Start of vector_scriptingnode_front

`vector_scriptingnode_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_scriptingnode_front', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_ScriptingNode", ref=ans);
  
  ans
  
}

attr(`vector_scriptingnode_front`, 'returnType') = '_p_ScriptingNode'
attr(`vector_scriptingnode_front`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_front`) = c("SWIGFunction", class('vector_scriptingnode_front'))

# Start of vector_scriptingnode_back

`vector_scriptingnode_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_scriptingnode_back', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_ScriptingNode", ref=ans);
  
  ans
  
}

attr(`vector_scriptingnode_back`, 'returnType') = '_p_ScriptingNode'
attr(`vector_scriptingnode_back`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_back`) = c("SWIGFunction", class('vector_scriptingnode_back'))

# Start of vector_scriptingnode_assign

`vector_scriptingnode_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_assign`, 'returnType') = 'void'
attr(`vector_scriptingnode_assign`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer', '_p_ScriptingNode')
class(`vector_scriptingnode_assign`) = c("SWIGFunction", class('vector_scriptingnode_assign'))

# Start of vector_scriptingnode_resize

`vector_scriptingnode_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_scriptingnode_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer', '_p_ScriptingNode')
class(`vector_scriptingnode_resize__SWIG_1`) = c("SWIGFunction", class('vector_scriptingnode_resize__SWIG_1'))

`vector_scriptingnode_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_scriptingnode_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( extends(argtypes[1], '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( extends(argtypes[3], '_p_ScriptingNode') && length(argv[[3]]) == 1 )) {
      f <- vector_scriptingnode_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_scriptingnode_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_scriptingnode_reserve

`vector_scriptingnode_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_scriptingnode_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_reserve`, 'returnType') = 'void'
attr(`vector_scriptingnode_reserve`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', 'integer')
class(`vector_scriptingnode_reserve`) = c("SWIGFunction", class('vector_scriptingnode_reserve'))

# Start of vector_scriptingnode_capacity

`vector_scriptingnode_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_scriptingnode_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_scriptingnode_capacity`, 'returnType') = 'integer'
attr(`vector_scriptingnode_capacity`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`vector_scriptingnode_capacity`) = c("SWIGFunction", class('vector_scriptingnode_capacity'))

# Start of delete_vector_scriptingnode

`delete_vector_scriptingnode` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_vector_scriptingnode', self, PACKAGE='Conv');
  
}

attr(`delete_vector_scriptingnode`, 'returnType') = 'void'
attr(`delete_vector_scriptingnode`, "inputTypes") = c('_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t')
class(`delete_vector_scriptingnode`) = c("SWIGFunction", class('delete_vector_scriptingnode'))

# Start of accessor method for std::vector< ScriptingNode >
setMethod('$', '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_scriptingnode___nonzero__, '__len__' = vector_scriptingnode___len__, 'pop' = vector_scriptingnode_pop, '__getslice__' = vector_scriptingnode___getslice__, '__setslice__' = vector_scriptingnode___setslice__, '__delslice__' = vector_scriptingnode___delslice__, '__delitem__' = vector_scriptingnode___delitem__, '__getitem__' = vector_scriptingnode___getitem__, '__setitem__' = vector_scriptingnode___setitem__, 'append' = vector_scriptingnode_append, 'empty' = vector_scriptingnode_empty, 'size' = vector_scriptingnode_size, 'swap' = vector_scriptingnode_swap, 'clear' = vector_scriptingnode_clear, 'get_allocator' = vector_scriptingnode_get_allocator, 'pop_back' = vector_scriptingnode_pop_back, 'resize' = vector_scriptingnode_resize, 'push_back' = vector_scriptingnode_push_back, 'front' = vector_scriptingnode_front, 'back' = vector_scriptingnode_back, 'assign' = vector_scriptingnode_assign, 'reserve' = vector_scriptingnode_reserve, 'capacity' = vector_scriptingnode_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< ScriptingNode >
setMethod('delete', '_p_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t', function(obj) {delete_std__vectorT_ScriptingNode_std__allocatorT_ScriptingNode_t_t(obj)})
# Start of vector_background___nonzero__

`vector_background___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_background___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_background___nonzero__`, 'returnType') = 'logical'
attr(`vector_background___nonzero__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background___nonzero__`) = c("SWIGFunction", class('vector_background___nonzero__'))

# Start of vector_background___len__

`vector_background___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_background___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_background___len__`, 'returnType') = 'integer'
attr(`vector_background___len__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background___len__`) = c("SWIGFunction", class('vector_background___len__'))

# Start of vector_background_pop

`vector_background_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_background_pop', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapBackground_Interop", ref=ans);
  
  ans
  
}

attr(`vector_background_pop`, 'returnType') = '_p_MapBackground_Interop'
attr(`vector_background_pop`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_pop`) = c("SWIGFunction", class('vector_background_pop'))

# Start of vector_background___getslice__

`vector_background___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_vector_background___getslice__', self, i, j, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t", ref=ans);
  
  ans
  
}

attr(`vector_background___getslice__`, 'returnType') = '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t'
attr(`vector_background___getslice__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer', 'integer')
class(`vector_background___getslice__`) = c("SWIGFunction", class('vector_background___getslice__'))

# Start of vector_background___setslice__

`vector_background___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_background___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_background___setslice__`, 'returnType') = 'void'
attr(`vector_background___setslice__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer', 'integer', '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background___setslice__`) = c("SWIGFunction", class('vector_background___setslice__'))

# Start of vector_background___delslice__

`vector_background___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_background___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_background___delslice__`, 'returnType') = 'void'
attr(`vector_background___delslice__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer', 'integer')
class(`vector_background___delslice__`) = c("SWIGFunction", class('vector_background___delslice__'))

# Start of vector_background___delitem__

`vector_background___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_background___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_background___delitem__`, 'returnType') = 'void'
attr(`vector_background___delitem__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer')
class(`vector_background___delitem__`) = c("SWIGFunction", class('vector_background___delitem__'))

# Start of vector_background___getitem__

`vector_background___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_vector_background___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapBackground_Interop", ref=ans);
  
  ans
  
}

attr(`vector_background___getitem__`, 'returnType') = '_p_MapBackground_Interop'
attr(`vector_background___getitem__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer')
class(`vector_background___getitem__`) = c("SWIGFunction", class('vector_background___getitem__'))

# Start of vector_background___setitem__

`vector_background___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_background___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_background___setitem__`, 'returnType') = 'void'
attr(`vector_background___setitem__`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer', '_p_MapBackground_Interop')
class(`vector_background___setitem__`) = c("SWIGFunction", class('vector_background___setitem__'))

# Start of vector_background_append

`vector_background_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_background_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_background_append`, 'returnType') = 'void'
attr(`vector_background_append`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', '_p_MapBackground_Interop')
class(`vector_background_append`) = c("SWIGFunction", class('vector_background_append'))

# Start of new_vector_background

`vector_background__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_vector_background__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_background);
  ans
  
}

attr(`vector_background__SWIG_0`, 'returnType') = '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t'
class(`vector_background__SWIG_0`) = c("SWIGFunction", class('vector_background__SWIG_0'))

# Start of new_vector_background

`vector_background__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_vector_background__SWIG_1', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_background);
  ans
  
}

attr(`vector_background__SWIG_1`, 'returnType') = '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t'
attr(`vector_background__SWIG_1`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background__SWIG_1`) = c("SWIGFunction", class('vector_background__SWIG_1'))

# Start of vector_background_empty

`vector_background_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_background_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_background_empty`, 'returnType') = 'logical'
attr(`vector_background_empty`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_empty`) = c("SWIGFunction", class('vector_background_empty'))

# Start of vector_background_size

`vector_background_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_background_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_background_size`, 'returnType') = 'integer'
attr(`vector_background_size`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_size`) = c("SWIGFunction", class('vector_background_size'))

# Start of vector_background_swap

`vector_background_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_background_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_background_swap`, 'returnType') = 'void'
attr(`vector_background_swap`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_swap`) = c("SWIGFunction", class('vector_background_swap'))

# Start of vector_background_clear

`vector_background_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_background_clear', self, PACKAGE='Conv');
  
}

attr(`vector_background_clear`, 'returnType') = 'void'
attr(`vector_background_clear`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_clear`) = c("SWIGFunction", class('vector_background_clear'))

# Start of vector_background_get_allocator

`vector_background_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_background_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_MapBackground_Interop_t", ref=ans);
  
  ans
  
}

attr(`vector_background_get_allocator`, 'returnType') = '_p_std__allocatorT_MapBackground_Interop_t'
attr(`vector_background_get_allocator`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_get_allocator`) = c("SWIGFunction", class('vector_background_get_allocator'))

# Start of new_vector_background

`vector_background__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_vector_background__SWIG_2', size, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_background);
  ans
  
}

attr(`vector_background__SWIG_2`, 'returnType') = '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t'
attr(`vector_background__SWIG_2`, "inputTypes") = c('integer')
class(`vector_background__SWIG_2`) = c("SWIGFunction", class('vector_background__SWIG_2'))

# Start of vector_background_pop_back

`vector_background_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_background_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_background_pop_back`, 'returnType') = 'void'
attr(`vector_background_pop_back`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_pop_back`) = c("SWIGFunction", class('vector_background_pop_back'))

# Start of vector_background_resize

`vector_background_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_background_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_background_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_background_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer')
class(`vector_background_resize__SWIG_0`) = c("SWIGFunction", class('vector_background_resize__SWIG_0'))

# Start of new_vector_background

`vector_background__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref"); 
  ;ans = .Call('R_swig_new_vector_background__SWIG_3', size, value, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_background);
  ans
  
}

attr(`vector_background__SWIG_3`, 'returnType') = '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t'
attr(`vector_background__SWIG_3`, "inputTypes") = c('integer', '_p_MapBackground_Interop')
class(`vector_background__SWIG_3`) = c("SWIGFunction", class('vector_background__SWIG_3'))

`vector_background` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_background__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_background__SWIG_2; 
    }
    else if ( extends(argtypes[1], '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t') && length(argv[[1]]) == 1 ) {
      f <- vector_background__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_MapBackground_Interop') && length(argv[[2]]) == 1 )) {
      f <- vector_background__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_background with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_background_push_back

`vector_background_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_background_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_background_push_back`, 'returnType') = 'void'
attr(`vector_background_push_back`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', '_p_MapBackground_Interop')
class(`vector_background_push_back`) = c("SWIGFunction", class('vector_background_push_back'))

# Start of vector_background_front

`vector_background_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_background_front', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapBackground_Interop", ref=ans);
  
  ans
  
}

attr(`vector_background_front`, 'returnType') = '_p_MapBackground_Interop'
attr(`vector_background_front`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_front`) = c("SWIGFunction", class('vector_background_front'))

# Start of vector_background_back

`vector_background_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_background_back', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_MapBackground_Interop", ref=ans);
  
  ans
  
}

attr(`vector_background_back`, 'returnType') = '_p_MapBackground_Interop'
attr(`vector_background_back`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_back`) = c("SWIGFunction", class('vector_background_back'))

# Start of vector_background_assign

`vector_background_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_background_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_background_assign`, 'returnType') = 'void'
attr(`vector_background_assign`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer', '_p_MapBackground_Interop')
class(`vector_background_assign`) = c("SWIGFunction", class('vector_background_assign'))

# Start of vector_background_resize

`vector_background_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_background_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_background_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_background_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer', '_p_MapBackground_Interop')
class(`vector_background_resize__SWIG_1`) = c("SWIGFunction", class('vector_background_resize__SWIG_1'))

`vector_background_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_background_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( extends(argtypes[1], '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( extends(argtypes[3], '_p_MapBackground_Interop') && length(argv[[3]]) == 1 )) {
      f <- vector_background_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_background_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_background_reserve

`vector_background_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_background_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_background_reserve`, 'returnType') = 'void'
attr(`vector_background_reserve`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', 'integer')
class(`vector_background_reserve`) = c("SWIGFunction", class('vector_background_reserve'))

# Start of vector_background_capacity

`vector_background_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_background_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_background_capacity`, 'returnType') = 'integer'
attr(`vector_background_capacity`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`vector_background_capacity`) = c("SWIGFunction", class('vector_background_capacity'))

# Start of delete_vector_background

`delete_vector_background` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_vector_background', self, PACKAGE='Conv');
  
}

attr(`delete_vector_background`, 'returnType') = 'void'
attr(`delete_vector_background`, "inputTypes") = c('_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t')
class(`delete_vector_background`) = c("SWIGFunction", class('delete_vector_background'))

# Start of accessor method for std::vector< MapBackground_Interop >
setMethod('$', '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_background___nonzero__, '__len__' = vector_background___len__, 'pop' = vector_background_pop, '__getslice__' = vector_background___getslice__, '__setslice__' = vector_background___setslice__, '__delslice__' = vector_background___delslice__, '__delitem__' = vector_background___delitem__, '__getitem__' = vector_background___getitem__, '__setitem__' = vector_background___setitem__, 'append' = vector_background_append, 'empty' = vector_background_empty, 'size' = vector_background_size, 'swap' = vector_background_swap, 'clear' = vector_background_clear, 'get_allocator' = vector_background_get_allocator, 'pop_back' = vector_background_pop_back, 'resize' = vector_background_resize, 'push_back' = vector_background_push_back, 'front' = vector_background_front, 'back' = vector_background_back, 'assign' = vector_background_assign, 'reserve' = vector_background_reserve, 'capacity' = vector_background_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< MapBackground_Interop >
setMethod('delete', '_p_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t', function(obj) {delete_std__vectorT_MapBackground_Interop_std__allocatorT_MapBackground_Interop_t_t(obj)})
# Start of vector_colors___nonzero__

`vector_colors___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_colors___nonzero__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_colors___nonzero__`, 'returnType') = 'logical'
attr(`vector_colors___nonzero__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors___nonzero__`) = c("SWIGFunction", class('vector_colors___nonzero__'))

# Start of vector_colors___len__

`vector_colors___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_colors___len__', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_colors___len__`, 'returnType') = 'integer'
attr(`vector_colors___len__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors___len__`) = c("SWIGFunction", class('vector_colors___len__'))

# Start of vector_colors_pop

`vector_colors_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_colors_pop', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`vector_colors_pop`, 'returnType') = '_p_Color_Interop'
attr(`vector_colors_pop`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_pop`) = c("SWIGFunction", class('vector_colors_pop'))

# Start of vector_colors___getslice__

`vector_colors___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_vector_colors___getslice__', self, i, j, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t", ref=ans);
  
  ans
  
}

attr(`vector_colors___getslice__`, 'returnType') = '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t'
attr(`vector_colors___getslice__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer', 'integer')
class(`vector_colors___getslice__`) = c("SWIGFunction", class('vector_colors___getslice__'))

# Start of vector_colors___setslice__

`vector_colors___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_colors___setslice__', self, i, j, v, PACKAGE='Conv');
  
}

attr(`vector_colors___setslice__`, 'returnType') = 'void'
attr(`vector_colors___setslice__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer', 'integer', '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors___setslice__`) = c("SWIGFunction", class('vector_colors___setslice__'))

# Start of vector_colors___delslice__

`vector_colors___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_colors___delslice__', self, i, j, PACKAGE='Conv');
  
}

attr(`vector_colors___delslice__`, 'returnType') = 'void'
attr(`vector_colors___delslice__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer', 'integer')
class(`vector_colors___delslice__`) = c("SWIGFunction", class('vector_colors___delslice__'))

# Start of vector_colors___delitem__

`vector_colors___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_colors___delitem__', self, i, PACKAGE='Conv');
  
}

attr(`vector_colors___delitem__`, 'returnType') = 'void'
attr(`vector_colors___delitem__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer')
class(`vector_colors___delitem__`) = c("SWIGFunction", class('vector_colors___delitem__'))

# Start of vector_colors___getitem__

`vector_colors___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_vector_colors___getitem__', self, i, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`vector_colors___getitem__`, 'returnType') = '_p_Color_Interop'
attr(`vector_colors___getitem__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer')
class(`vector_colors___getitem__`) = c("SWIGFunction", class('vector_colors___getitem__'))

# Start of vector_colors___setitem__

`vector_colors___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_colors___setitem__', self, i, x, PACKAGE='Conv');
  
}

attr(`vector_colors___setitem__`, 'returnType') = 'void'
attr(`vector_colors___setitem__`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer', '_p_Color_Interop')
class(`vector_colors___setitem__`) = c("SWIGFunction", class('vector_colors___setitem__'))

# Start of vector_colors_append

`vector_colors_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_colors_append', self, x, PACKAGE='Conv');
  
}

attr(`vector_colors_append`, 'returnType') = 'void'
attr(`vector_colors_append`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', '_p_Color_Interop')
class(`vector_colors_append`) = c("SWIGFunction", class('vector_colors_append'))

# Start of new_vector_colors

`vector_colors__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_vector_colors__SWIG_0', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_colors);
  ans
  
}

attr(`vector_colors__SWIG_0`, 'returnType') = '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t'
class(`vector_colors__SWIG_0`) = c("SWIGFunction", class('vector_colors__SWIG_0'))

# Start of new_vector_colors

`vector_colors__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_vector_colors__SWIG_1', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_colors);
  ans
  
}

attr(`vector_colors__SWIG_1`, 'returnType') = '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t'
attr(`vector_colors__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors__SWIG_1`) = c("SWIGFunction", class('vector_colors__SWIG_1'))

# Start of vector_colors_empty

`vector_colors_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_colors_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_colors_empty`, 'returnType') = 'logical'
attr(`vector_colors_empty`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_empty`) = c("SWIGFunction", class('vector_colors_empty'))

# Start of vector_colors_size

`vector_colors_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_colors_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_colors_size`, 'returnType') = 'integer'
attr(`vector_colors_size`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_size`) = c("SWIGFunction", class('vector_colors_size'))

# Start of vector_colors_swap

`vector_colors_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_vector_colors_swap', self, v, PACKAGE='Conv');
  
}

attr(`vector_colors_swap`, 'returnType') = 'void'
attr(`vector_colors_swap`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_swap`) = c("SWIGFunction", class('vector_colors_swap'))

# Start of vector_colors_clear

`vector_colors_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_colors_clear', self, PACKAGE='Conv');
  
}

attr(`vector_colors_clear`, 'returnType') = 'void'
attr(`vector_colors_clear`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_clear`) = c("SWIGFunction", class('vector_colors_clear'))

# Start of vector_colors_get_allocator

`vector_colors_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_colors_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_Color_Interop_t", ref=ans);
  
  ans
  
}

attr(`vector_colors_get_allocator`, 'returnType') = '_p_std__allocatorT_Color_Interop_t'
attr(`vector_colors_get_allocator`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_get_allocator`) = c("SWIGFunction", class('vector_colors_get_allocator'))

# Start of new_vector_colors

`vector_colors__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_vector_colors__SWIG_2', size, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_colors);
  ans
  
}

attr(`vector_colors__SWIG_2`, 'returnType') = '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t'
attr(`vector_colors__SWIG_2`, "inputTypes") = c('integer')
class(`vector_colors__SWIG_2`) = c("SWIGFunction", class('vector_colors__SWIG_2'))

# Start of vector_colors_pop_back

`vector_colors_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_colors_pop_back', self, PACKAGE='Conv');
  
}

attr(`vector_colors_pop_back`, 'returnType') = 'void'
attr(`vector_colors_pop_back`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_pop_back`) = c("SWIGFunction", class('vector_colors_pop_back'))

# Start of vector_colors_resize

`vector_colors_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_colors_resize__SWIG_0', self, new_size, PACKAGE='Conv');
  
}

attr(`vector_colors_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_colors_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer')
class(`vector_colors_resize__SWIG_0`) = c("SWIGFunction", class('vector_colors_resize__SWIG_0'))

# Start of new_vector_colors

`vector_colors__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref"); 
  ;ans = .Call('R_swig_new_vector_colors__SWIG_3', size, value, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_vector_colors);
  ans
  
}

attr(`vector_colors__SWIG_3`, 'returnType') = '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t'
attr(`vector_colors__SWIG_3`, "inputTypes") = c('integer', '_p_Color_Interop')
class(`vector_colors__SWIG_3`) = c("SWIGFunction", class('vector_colors__SWIG_3'))

`vector_colors` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 4
  if (argc == 0) {
    f <- vector_colors__SWIG_0; 
  } else if (argc == 1) {
    if ( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) {
      f <- vector_colors__SWIG_2; 
    }
    else if ( extends(argtypes[1], '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t') && length(argv[[1]]) == 1 ) {
      f <- vector_colors__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( extends(argtypes[2], '_p_Color_Interop') && length(argv[[2]]) == 1 )) {
      f <- vector_colors__SWIG_3; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_colors with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_colors_push_back

`vector_colors_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_colors_push_back', self, x, PACKAGE='Conv');
  
}

attr(`vector_colors_push_back`, 'returnType') = 'void'
attr(`vector_colors_push_back`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', '_p_Color_Interop')
class(`vector_colors_push_back`) = c("SWIGFunction", class('vector_colors_push_back'))

# Start of vector_colors_front

`vector_colors_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_colors_front', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`vector_colors_front`, 'returnType') = '_p_Color_Interop'
attr(`vector_colors_front`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_front`) = c("SWIGFunction", class('vector_colors_front'))

# Start of vector_colors_back

`vector_colors_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_vector_colors_back', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_Color_Interop", ref=ans);
  
  ans
  
}

attr(`vector_colors_back`, 'returnType') = '_p_Color_Interop'
attr(`vector_colors_back`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_back`) = c("SWIGFunction", class('vector_colors_back'))

# Start of vector_colors_assign

`vector_colors_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_colors_assign', self, n, x, PACKAGE='Conv');
  
}

attr(`vector_colors_assign`, 'returnType') = 'void'
attr(`vector_colors_assign`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer', '_p_Color_Interop')
class(`vector_colors_assign`) = c("SWIGFunction", class('vector_colors_assign'))

# Start of vector_colors_resize

`vector_colors_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_colors_resize__SWIG_1', self, new_size, x, PACKAGE='Conv');
  
}

attr(`vector_colors_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_colors_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer', '_p_Color_Interop')
class(`vector_colors_resize__SWIG_1`) = c("SWIGFunction", class('vector_colors_resize__SWIG_1'))

`vector_colors_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 2
  if (argc == 2) {
    if (( extends(argtypes[1], '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_colors_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( extends(argtypes[1], '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t') || is.null(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( extends(argtypes[3], '_p_Color_Interop') && length(argv[[3]]) == 1 )) {
      f <- vector_colors_resize__SWIG_1; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for vector_colors_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_colors_reserve

`vector_colors_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_colors_reserve', self, n, PACKAGE='Conv');
  
}

attr(`vector_colors_reserve`, 'returnType') = 'void'
attr(`vector_colors_reserve`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', 'integer')
class(`vector_colors_reserve`) = c("SWIGFunction", class('vector_colors_reserve'))

# Start of vector_colors_capacity

`vector_colors_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_vector_colors_capacity', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`vector_colors_capacity`, 'returnType') = 'integer'
attr(`vector_colors_capacity`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`vector_colors_capacity`) = c("SWIGFunction", class('vector_colors_capacity'))

# Start of delete_vector_colors

`delete_vector_colors` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_vector_colors', self, PACKAGE='Conv');
  
}

attr(`delete_vector_colors`, 'returnType') = 'void'
attr(`delete_vector_colors`, "inputTypes") = c('_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t')
class(`delete_vector_colors`) = c("SWIGFunction", class('delete_vector_colors'))

# Start of accessor method for std::vector< Color_Interop >
setMethod('$', '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_colors___nonzero__, '__len__' = vector_colors___len__, 'pop' = vector_colors_pop, '__getslice__' = vector_colors___getslice__, '__setslice__' = vector_colors___setslice__, '__delslice__' = vector_colors___delslice__, '__delitem__' = vector_colors___delitem__, '__getitem__' = vector_colors___getitem__, '__setitem__' = vector_colors___setitem__, 'append' = vector_colors_append, 'empty' = vector_colors_empty, 'size' = vector_colors_size, 'swap' = vector_colors_swap, 'clear' = vector_colors_clear, 'get_allocator' = vector_colors_get_allocator, 'pop_back' = vector_colors_pop_back, 'resize' = vector_colors_resize, 'push_back' = vector_colors_push_back, 'front' = vector_colors_front, 'back' = vector_colors_back, 'assign' = vector_colors_assign, 'reserve' = vector_colors_reserve, 'capacity' = vector_colors_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< Color_Interop >
setMethod('delete', '_p_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t', function(obj) {delete_std__vectorT_Color_Interop_std__allocatorT_Color_Interop_t_t(obj)})
# Start of new_map_int_background

`map_int_background__SWIG_0` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_int_background__SWIG_0', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_background);
  ans
  
}

attr(`map_int_background__SWIG_0`, 'returnType') = '_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t'
attr(`map_int_background__SWIG_0`, "inputTypes") = c('_p_std__lessT_int_t')
class(`map_int_background__SWIG_0`) = c("SWIGFunction", class('map_int_background__SWIG_0'))

# Start of new_map_int_background

`map_int_background__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_map_int_background__SWIG_1', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_background);
  ans
  
}

attr(`map_int_background__SWIG_1`, 'returnType') = '_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t'
class(`map_int_background__SWIG_1`) = c("SWIGFunction", class('map_int_background__SWIG_1'))

# Start of new_map_int_background

`map_int_background__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_int_background__SWIG_2', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_background);
  ans
  
}

attr(`map_int_background__SWIG_2`, 'returnType') = '_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t'
attr(`map_int_background__SWIG_2`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t')
class(`map_int_background__SWIG_2`) = c("SWIGFunction", class('map_int_background__SWIG_2'))

`map_int_background` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 3
  if (argc == 0) {
    f <- map_int_background__SWIG_1; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__lessT_int_t') && length(argv[[1]]) == 1 ) {
      f <- map_int_background__SWIG_0; 
    }
    else if ( extends(argtypes[1], '_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t') && length(argv[[1]]) == 1 ) {
      f <- map_int_background__SWIG_2; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for map_int_background with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of map_int_background_empty

`map_int_background_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_background_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_background_empty`, 'returnType') = 'logical'
attr(`map_int_background_empty`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t')
class(`map_int_background_empty`) = c("SWIGFunction", class('map_int_background_empty'))

# Start of map_int_background_size

`map_int_background_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_background_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_background_size`, 'returnType') = 'integer'
attr(`map_int_background_size`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t')
class(`map_int_background_size`) = c("SWIGFunction", class('map_int_background_size'))

# Start of map_int_background_swap

`map_int_background_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_map_int_background_swap', self, v, PACKAGE='Conv');
  
}

attr(`map_int_background_swap`, 'returnType') = 'void'
attr(`map_int_background_swap`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t', '_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t')
class(`map_int_background_swap`) = c("SWIGFunction", class('map_int_background_swap'))

# Start of map_int_background_clear

`map_int_background_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_background_clear', self, PACKAGE='Conv');
  
}

attr(`map_int_background_clear`, 'returnType') = 'void'
attr(`map_int_background_clear`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t')
class(`map_int_background_clear`) = c("SWIGFunction", class('map_int_background_clear'))

# Start of map_int_background_get_allocator

`map_int_background_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_map_int_background_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t", ref=ans);
  
  ans
  
}

attr(`map_int_background_get_allocator`, 'returnType') = '_p_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t'
attr(`map_int_background_get_allocator`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t')
class(`map_int_background_get_allocator`) = c("SWIGFunction", class('map_int_background_get_allocator'))

# Start of map_int_background_erase

`map_int_background_erase` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as.integer(x);
  ;.Call('R_swig_map_int_background_erase', self, x, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_background_erase`, 'returnType') = 'integer'
attr(`map_int_background_erase`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t', 'integer')
class(`map_int_background_erase`) = c("SWIGFunction", class('map_int_background_erase'))

# Start of map_int_background_count

`map_int_background_count` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as.integer(x);
  ;.Call('R_swig_map_int_background_count', self, x, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_background_count`, 'returnType') = 'integer'
attr(`map_int_background_count`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t', 'integer')
class(`map_int_background_count`) = c("SWIGFunction", class('map_int_background_count'))

# Start of delete_map_int_background

`delete_map_int_background` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_map_int_background', self, PACKAGE='Conv');
  
}

attr(`delete_map_int_background`, 'returnType') = 'void'
attr(`delete_map_int_background`, "inputTypes") = c('_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t')
class(`delete_map_int_background`) = c("SWIGFunction", class('delete_map_int_background'))

# Start of accessor method for std::map< int,MapBackground_Interop >
setMethod('$', '_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t', function(x, name)

{
  accessorFuns = list('empty' = map_int_background_empty, 'size' = map_int_background_size, 'swap' = map_int_background_swap, 'clear' = map_int_background_clear, 'get_allocator' = map_int_background_get_allocator, 'erase' = map_int_background_erase, 'count' = map_int_background_count);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::map< int,MapBackground_Interop >
setMethod('delete', '_p_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t', function(obj) {delete_std__mapT_int_MapBackground_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapBackground_Interop_t_t_t(obj)})
# Start of new_map_int_polyline

`map_int_polyline__SWIG_0` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_int_polyline__SWIG_0', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_polyline);
  ans
  
}

attr(`map_int_polyline__SWIG_0`, 'returnType') = '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t'
attr(`map_int_polyline__SWIG_0`, "inputTypes") = c('_p_std__lessT_int_t')
class(`map_int_polyline__SWIG_0`) = c("SWIGFunction", class('map_int_polyline__SWIG_0'))

# Start of new_map_int_polyline

`map_int_polyline__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_map_int_polyline__SWIG_1', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_polyline);
  ans
  
}

attr(`map_int_polyline__SWIG_1`, 'returnType') = '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t'
class(`map_int_polyline__SWIG_1`) = c("SWIGFunction", class('map_int_polyline__SWIG_1'))

# Start of new_map_int_polyline

`map_int_polyline__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_int_polyline__SWIG_2', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_polyline);
  ans
  
}

attr(`map_int_polyline__SWIG_2`, 'returnType') = '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t'
attr(`map_int_polyline__SWIG_2`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`map_int_polyline__SWIG_2`) = c("SWIGFunction", class('map_int_polyline__SWIG_2'))

`map_int_polyline` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 3
  if (argc == 0) {
    f <- map_int_polyline__SWIG_1; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__lessT_int_t') && length(argv[[1]]) == 1 ) {
      f <- map_int_polyline__SWIG_0; 
    }
    else if ( extends(argtypes[1], '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t') && length(argv[[1]]) == 1 ) {
      f <- map_int_polyline__SWIG_2; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for map_int_polyline with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of map_int_polyline_empty

`map_int_polyline_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_polyline_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_polyline_empty`, 'returnType') = 'logical'
attr(`map_int_polyline_empty`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`map_int_polyline_empty`) = c("SWIGFunction", class('map_int_polyline_empty'))

# Start of map_int_polyline_size

`map_int_polyline_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_polyline_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_polyline_size`, 'returnType') = 'integer'
attr(`map_int_polyline_size`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`map_int_polyline_size`) = c("SWIGFunction", class('map_int_polyline_size'))

# Start of map_int_polyline_swap

`map_int_polyline_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_map_int_polyline_swap', self, v, PACKAGE='Conv');
  
}

attr(`map_int_polyline_swap`, 'returnType') = 'void'
attr(`map_int_polyline_swap`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t', '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`map_int_polyline_swap`) = c("SWIGFunction", class('map_int_polyline_swap'))

# Start of map_int_polyline_clear

`map_int_polyline_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_polyline_clear', self, PACKAGE='Conv');
  
}

attr(`map_int_polyline_clear`, 'returnType') = 'void'
attr(`map_int_polyline_clear`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`map_int_polyline_clear`) = c("SWIGFunction", class('map_int_polyline_clear'))

# Start of map_int_polyline_get_allocator

`map_int_polyline_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_map_int_polyline_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t", ref=ans);
  
  ans
  
}

attr(`map_int_polyline_get_allocator`, 'returnType') = '_p_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t'
attr(`map_int_polyline_get_allocator`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`map_int_polyline_get_allocator`) = c("SWIGFunction", class('map_int_polyline_get_allocator'))

# Start of map_int_polyline_erase

`map_int_polyline_erase` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as.integer(x);
  ;.Call('R_swig_map_int_polyline_erase', self, x, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_polyline_erase`, 'returnType') = 'integer'
attr(`map_int_polyline_erase`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t', 'integer')
class(`map_int_polyline_erase`) = c("SWIGFunction", class('map_int_polyline_erase'))

# Start of map_int_polyline_count

`map_int_polyline_count` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as.integer(x);
  ;.Call('R_swig_map_int_polyline_count', self, x, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_polyline_count`, 'returnType') = 'integer'
attr(`map_int_polyline_count`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t', 'integer')
class(`map_int_polyline_count`) = c("SWIGFunction", class('map_int_polyline_count'))

# Start of delete_map_int_polyline

`delete_map_int_polyline` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_map_int_polyline', self, PACKAGE='Conv');
  
}

attr(`delete_map_int_polyline`, 'returnType') = 'void'
attr(`delete_map_int_polyline`, "inputTypes") = c('_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t')
class(`delete_map_int_polyline`) = c("SWIGFunction", class('delete_map_int_polyline'))

# Start of accessor method for std::map< int,MapPolyline_Interop >
setMethod('$', '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t', function(x, name)

{
  accessorFuns = list('empty' = map_int_polyline_empty, 'size' = map_int_polyline_size, 'swap' = map_int_polyline_swap, 'clear' = map_int_polyline_clear, 'get_allocator' = map_int_polyline_get_allocator, 'erase' = map_int_polyline_erase, 'count' = map_int_polyline_count);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::map< int,MapPolyline_Interop >
setMethod('delete', '_p_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t', function(obj) {delete_std__mapT_int_MapPolyline_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapPolyline_Interop_t_t_t(obj)})
# Start of new_map_int_icon

`map_int_icon__SWIG_0` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_int_icon__SWIG_0', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_icon);
  ans
  
}

attr(`map_int_icon__SWIG_0`, 'returnType') = '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t'
attr(`map_int_icon__SWIG_0`, "inputTypes") = c('_p_std__lessT_int_t')
class(`map_int_icon__SWIG_0`) = c("SWIGFunction", class('map_int_icon__SWIG_0'))

# Start of new_map_int_icon

`map_int_icon__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_map_int_icon__SWIG_1', PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_icon);
  ans
  
}

attr(`map_int_icon__SWIG_1`, 'returnType') = '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t'
class(`map_int_icon__SWIG_1`) = c("SWIGFunction", class('map_int_icon__SWIG_1'))

# Start of new_map_int_icon

`map_int_icon__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_int_icon__SWIG_2', other, PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_int_icon);
  ans
  
}

attr(`map_int_icon__SWIG_2`, 'returnType') = '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t'
attr(`map_int_icon__SWIG_2`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`map_int_icon__SWIG_2`) = c("SWIGFunction", class('map_int_icon__SWIG_2'))

`map_int_icon` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  f <- NULL;
# dispatch functions 3
  if (argc == 0) {
    f <- map_int_icon__SWIG_1; 
  } else if (argc == 1) {
    if ( extends(argtypes[1], '_p_std__lessT_int_t') && length(argv[[1]]) == 1 ) {
      f <- map_int_icon__SWIG_0; 
    }
    else if ( extends(argtypes[1], '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t') && length(argv[[1]]) == 1 ) {
      f <- map_int_icon__SWIG_2; 
    }
  };
  if (is.null(f)) {
    stop("cannot find overloaded function for map_int_icon with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of map_int_icon_empty

`map_int_icon_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_icon_empty', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_icon_empty`, 'returnType') = 'logical'
attr(`map_int_icon_empty`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`map_int_icon_empty`) = c("SWIGFunction", class('map_int_icon_empty'))

# Start of map_int_icon_size

`map_int_icon_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_icon_size', self, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_icon_size`, 'returnType') = 'integer'
attr(`map_int_icon_size`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`map_int_icon_size`) = c("SWIGFunction", class('map_int_icon_size'))

# Start of map_int_icon_swap

`map_int_icon_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_map_int_icon_swap', self, v, PACKAGE='Conv');
  
}

attr(`map_int_icon_swap`, 'returnType') = 'void'
attr(`map_int_icon_swap`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t', '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`map_int_icon_swap`) = c("SWIGFunction", class('map_int_icon_swap'))

# Start of map_int_icon_clear

`map_int_icon_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_int_icon_clear', self, PACKAGE='Conv');
  
}

attr(`map_int_icon_clear`, 'returnType') = 'void'
attr(`map_int_icon_clear`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`map_int_icon_clear`) = c("SWIGFunction", class('map_int_icon_clear'))

# Start of map_int_icon_get_allocator

`map_int_icon_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_map_int_icon_get_allocator', self, as.logical(.copy), PACKAGE='Conv');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t", ref=ans);
  
  ans
  
}

attr(`map_int_icon_get_allocator`, 'returnType') = '_p_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t'
attr(`map_int_icon_get_allocator`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`map_int_icon_get_allocator`) = c("SWIGFunction", class('map_int_icon_get_allocator'))

# Start of map_int_icon_erase

`map_int_icon_erase` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as.integer(x);
  ;.Call('R_swig_map_int_icon_erase', self, x, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_icon_erase`, 'returnType') = 'integer'
attr(`map_int_icon_erase`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t', 'integer')
class(`map_int_icon_erase`) = c("SWIGFunction", class('map_int_icon_erase'))

# Start of map_int_icon_count

`map_int_icon_count` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as.integer(x);
  ;.Call('R_swig_map_int_icon_count', self, x, as.logical(.copy), PACKAGE='Conv');
  
}

attr(`map_int_icon_count`, 'returnType') = 'integer'
attr(`map_int_icon_count`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t', 'integer')
class(`map_int_icon_count`) = c("SWIGFunction", class('map_int_icon_count'))

# Start of delete_map_int_icon

`delete_map_int_icon` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_map_int_icon', self, PACKAGE='Conv');
  
}

attr(`delete_map_int_icon`, 'returnType') = 'void'
attr(`delete_map_int_icon`, "inputTypes") = c('_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t')
class(`delete_map_int_icon`) = c("SWIGFunction", class('delete_map_int_icon'))

# Start of accessor method for std::map< int,MapIcon_Interop >
setMethod('$', '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t', function(x, name)

{
  accessorFuns = list('empty' = map_int_icon_empty, 'size' = map_int_icon_size, 'swap' = map_int_icon_swap, 'clear' = map_int_icon_clear, 'get_allocator' = map_int_icon_get_allocator, 'erase' = map_int_icon_erase, 'count' = map_int_icon_count);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::map< int,MapIcon_Interop >
setMethod('delete', '_p_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t', function(obj) {delete_std__mapT_int_MapIcon_Interop_std__lessT_int_t_std__allocatorT_std__pairT_int_const_MapIcon_Interop_t_t_t(obj)})

defineEnumeration("_uwp_color",
 .values=c("RED" = .Call('R_swig_uwp_color_RED_get',FALSE, PACKAGE='Conv'),
"BLUE" = .Call('R_swig_uwp_color_BLUE_get',FALSE, PACKAGE='Conv'),
"GREEN" = .Call('R_swig_uwp_color_GREEN_get',FALSE, PACKAGE='Conv')))

defineEnumeration("_uwp_patternInterpType",
 .values=c("LEFT" = .Call('R_swig_uwp_patternInterpType_LEFT_get',FALSE, PACKAGE='Conv'),
"RIGHT" = .Call('R_swig_uwp_patternInterpType_RIGHT_get',FALSE, PACKAGE='Conv'),
"LINEAR" = .Call('R_swig_uwp_patternInterpType_LINEAR_get',FALSE, PACKAGE='Conv'),
"SPLINE" = .Call('R_swig_uwp_patternInterpType_SPLINE_get',FALSE, PACKAGE='Conv')))

defineEnumeration("_WaterWatchEnums__ScriptNodeType",
 .values=c("Id" = .Call('R_swig_WaterWatchEnums_Id_get',FALSE, PACKAGE='Conv'),
"Fun_Call" = .Call('R_swig_WaterWatchEnums_Fun_Call_get',FALSE, PACKAGE='Conv'),
"Unused_Return_Fun_Call" = .Call('R_swig_WaterWatchEnums_Unused_Return_Fun_Call_get',FALSE, PACKAGE='Conv'),
"Arg_List" = .Call('R_swig_WaterWatchEnums_Arg_List_get',FALSE, PACKAGE='Conv'),
"Equation" = .Call('R_swig_WaterWatchEnums_Equation_get',FALSE, PACKAGE='Conv'),
"Var_Decl" = .Call('R_swig_WaterWatchEnums_Var_Decl_get',FALSE, PACKAGE='Conv'),
"Assign_Decl" = .Call('R_swig_WaterWatchEnums_Assign_Decl_get',FALSE, PACKAGE='Conv'),
"Array_Call" = .Call('R_swig_WaterWatchEnums_Array_Call_get',FALSE, PACKAGE='Conv'),
"Dot_Access" = .Call('R_swig_WaterWatchEnums_Dot_Access_get',FALSE, PACKAGE='Conv'),
"Lambda" = .Call('R_swig_WaterWatchEnums_Lambda_get',FALSE, PACKAGE='Conv'),
"Block" = .Call('R_swig_WaterWatchEnums_Block_get',FALSE, PACKAGE='Conv'),
"Scopeless_Block" = .Call('R_swig_WaterWatchEnums_Scopeless_Block_get',FALSE, PACKAGE='Conv'),
"Def" = .Call('R_swig_WaterWatchEnums_Def_get',FALSE, PACKAGE='Conv'),
"While" = .Call('R_swig_WaterWatchEnums_While_get',FALSE, PACKAGE='Conv'),
"If" = .Call('R_swig_WaterWatchEnums_If_get',FALSE, PACKAGE='Conv'),
"For" = .Call('R_swig_WaterWatchEnums_For_get',FALSE, PACKAGE='Conv'),
"Ranged_For" = .Call('R_swig_WaterWatchEnums_Ranged_For_get',FALSE, PACKAGE='Conv'),
"Inline_Array" = .Call('R_swig_WaterWatchEnums_Inline_Array_get',FALSE, PACKAGE='Conv'),
"Inline_Map" = .Call('R_swig_WaterWatchEnums_Inline_Map_get',FALSE, PACKAGE='Conv'),
"Return" = .Call('R_swig_WaterWatchEnums_Return_get',FALSE, PACKAGE='Conv'),
"File" = .Call('R_swig_WaterWatchEnums_File_get',FALSE, PACKAGE='Conv'),
"Prefix" = .Call('R_swig_WaterWatchEnums_Prefix_get',FALSE, PACKAGE='Conv'),
"Break" = .Call('R_swig_WaterWatchEnums_Break_get',FALSE, PACKAGE='Conv'),
"Continue" = .Call('R_swig_WaterWatchEnums_Continue_get',FALSE, PACKAGE='Conv'),
"Map_Pair" = .Call('R_swig_WaterWatchEnums_Map_Pair_get',FALSE, PACKAGE='Conv'),
"Value_Range" = .Call('R_swig_WaterWatchEnums_Value_Range_get',FALSE, PACKAGE='Conv'),
"Inline_Range" = .Call('R_swig_WaterWatchEnums_Inline_Range_get',FALSE, PACKAGE='Conv'),
"Do" = .Call('R_swig_WaterWatchEnums_Do_get',FALSE, PACKAGE='Conv'),
"Try" = .Call('R_swig_WaterWatchEnums_Try_get',FALSE, PACKAGE='Conv'),
"Catch" = .Call('R_swig_WaterWatchEnums_Catch_get',FALSE, PACKAGE='Conv'),
"Finally" = .Call('R_swig_WaterWatchEnums_Finally_get',FALSE, PACKAGE='Conv'),
"Method" = .Call('R_swig_WaterWatchEnums_Method_get',FALSE, PACKAGE='Conv'),
"Attr_Decl" = .Call('R_swig_WaterWatchEnums_Attr_Decl_get',FALSE, PACKAGE='Conv'),
"Logical_And" = .Call('R_swig_WaterWatchEnums_Logical_And_get',FALSE, PACKAGE='Conv'),
"Logical_Or" = .Call('R_swig_WaterWatchEnums_Logical_Or_get',FALSE, PACKAGE='Conv'),
"Reference" = .Call('R_swig_WaterWatchEnums_Reference_get',FALSE, PACKAGE='Conv'),
"Switch" = .Call('R_swig_WaterWatchEnums_Switch_get',FALSE, PACKAGE='Conv'),
"Case" = .Call('R_swig_WaterWatchEnums_Case_get',FALSE, PACKAGE='Conv'),
"Default" = .Call('R_swig_WaterWatchEnums_Default_get',FALSE, PACKAGE='Conv'),
"Noop" = .Call('R_swig_WaterWatchEnums_Noop_get',FALSE, PACKAGE='Conv'),
"Class" = .Call('R_swig_WaterWatchEnums_Class_get',FALSE, PACKAGE='Conv'),
"Binary" = .Call('R_swig_WaterWatchEnums_Binary_get',FALSE, PACKAGE='Conv'),
"Arg" = .Call('R_swig_WaterWatchEnums_Arg_get',FALSE, PACKAGE='Conv'),
"Global_Decl" = .Call('R_swig_WaterWatchEnums_Global_Decl_get',FALSE, PACKAGE='Conv'),
"Constant" = .Call('R_swig_WaterWatchEnums_Constant_get',FALSE, PACKAGE='Conv'),
"Compiled" = .Call('R_swig_WaterWatchEnums_Compiled_get',FALSE, PACKAGE='Conv'),
"ControlBlock" = .Call('R_swig_WaterWatchEnums_ControlBlock_get',FALSE, PACKAGE='Conv'),
"Postfix" = .Call('R_swig_WaterWatchEnums_Postfix_get',FALSE, PACKAGE='Conv'),
"Assign_Retroactively" = .Call('R_swig_WaterWatchEnums_Assign_Retroactively_get',FALSE, PACKAGE='Conv'),
"Error" = .Call('R_swig_WaterWatchEnums_Error_get',FALSE, PACKAGE='Conv')))


